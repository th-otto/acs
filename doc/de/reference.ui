!begin_node Die Referenz - geordnet nach Gruppen

!subtoc [all] !depth 1

Hier folgt die vollst„ndige Referenz aller von (!I)ACSpro(!i) zur Verfgung
gestellten Konstanten, Datenstrukturen und Datentypen, Variablen und
Funktionen.

(!I)(!B)Anmerkung:(!b) Da nichts so schnell veraltet wie ein gedrucktes Buch,
sollte stets in der Online-Hilfe (z.B. fr den ST-Guide) und der
History nachgeschlagen werden, wo stets die aktuellsten Informationen
zu finden sind.(!i)

(!I)Anmerkung:(!i) Momentan sind alle Beispiele in C notiert. Bei Gelegenheit
werden diese Beispiele nach Pascal bertragen. Die C-Beispiele sind
jedoch bewužt so geschrieben, daž auch reine Pascal-Programmierer sie
ohne - oder nur mit geringer - C-Kenntnis verstehen sollten.

!begin_node Die Konstanten

(!I)ACSpro(!i) definiert einige Konstanten, die in verschiedene Kategorien
eingeteilt werden k”nnen

!subtoc [all] !depth 1

!begin_node Fenster-Flags

Fr die Fenster-Flags in (!link [Awindow.kind] [Awindow.kind]) sind die nachfolgenden Flags
definiert:

!begin_xlist [AW_ICONACCEPT]
!label AW_ICON
 !item [AW_ICON]        Das Fenster wird beim Anw„hlen der CLOSE-Box
                ikonifiziert. Ist dieses Flag NICHT gesetzt, wird das
                Fenster durch den CLOSER gel”scht!

                (!B)Wichtig:(!b) Bitte beachten Sie diesen Unterschied, denn
                er hat weitreichende Konsequenzen.

!label AW_GHOSTICON
 !item [AW_GHOSTICON]   Die Ikone verschwindet nicht beim ™ffnen, sondern wird
                als Geisterikone dargestellt, die zum Toppen angew„hlt
                werden kann.

!label AW_STAY
 !item [AW_STAY]        Der Zustand dieses Fensters soll nicht automatisch
                ver„ndert werden (ikonifiziert oder nicht).
                Normalerweise wird, wenn GEM keine freie Fenster-ID
                mehr hat, ein eigenes geschlossen. Es gibt manchmal
                Fenster, die nicht geschlossen werden sollten.

!label [AW_OBLIST]
 !item [AW_OBLIST]      Der Arbeitsbereich ist eine Liste von Objekten. Diese
                Liste wird je nach Gr”že des Fensters umgebaut. Das
                erste Objekt bleibt immer am selben Platz und bestimmt
                durch den Versatz ob_x und ob_y die Abst„nde zwischen
                den Objekten der Liste.

!label AW_ICONACCEPT
 !item [AW_ICONACCEPT]  Das ikonifizierte Fenster akzeptiert gezogene Objekte.

!label AW_UHSLIDER
 !item [AW_UHSLIDER]    Der Benutzer steuert den horizontalen (!link [Slider] [Slider]) selbst.
                Beim ™ffnen des Fensters nimmt der (!link [Slider] [Slider]) die Gr”že
                wi_slider.w an der Position wi_slider.x ein.

!label AW_UVSLIDER
 !item [AW_UVSLIDER]    Analoges fr den vertikalen (!link [Slider] [Slider]).AW_NOSCROLL Es wird
                nie optimiertes Scrollen durchgefhrt.

!label AW_TOOLBOX
 !item [AW_TOOLBOX]     Dieser Fenstermodus erlaubt es, das Fensterinnere
                anzuw„hlen, ohne das Fenster zuvor zu toppen. Dies ist
                ideal fr Teilelisten und Werkzeuge. Dieser Modus ist
                erst in h”heren Version als AES 3.00 vorhanden (z.B.
                Falcon-TOS, MultiTOS, MagiC, N.AES).
!end_xlist

!end_node


!begin_node Fenster-Status-Flags

Die hier definierten Fenster-Status-Flags werden fr die Komponente
(!link [Awindow.state] [Awindow.state]) ben”tigt und beschreiben den Status eine Fensters.

(!B)Die folgenden Werte sollten nur vom (!I)ACSpro(!i)-System ver„ndert werden:(!b)

!begin_xlist [AWS_FORCEREDRAW]
!label AWS_FULL
 !item [AWS_FULL]         Das Fenster befindet sich momentan in seiner
                  maximalen Ausdehnung.

!label AWS_DIALOG
 !item [AWS_DIALOG]       Derzeit ist ein Dialog (Texteingabe) in diesem
                  Fenster aktiv.

!label AWS_MODIFIED
 !item [AWS_MODIFIED]     Vor dem n„chsten ™ffnen des Fensters wird die init-
                  Routine aufgerufen. Das Flag wird beim Erzeugen oder
                  durch AWS_LATEUPDATE gesetzt.

!label AWS_MODAL
 !item [AWS_MODAL]        Ein modaler Dialog zu diesem Fenster ist derzeit
                  aktiv.

!label AWS_MODAL_WIN
 !item [AWS_MODAL_WIN]    Dieses Fenster ist momentan eines der momentan
                  aktiven modalen Fensterdialoge

!label AWS_ICONIZED
 !item [AWS_ICONIZED]     Das Fenster wurde vom System iconifiziert. Dies ist
                  nicht der iconifizierte Zustand innerhalb von
                  (!I)ACSpro(!i), sondern vielmehr ein systemweit verfgbarer
                  Zustand in neuen Betriebssystemversionen. Zwingend
                  notwendig dafr ist, daž in der Awindow.service-
                  Routine Awi_service aufgerufen wird.

!label AWS_SHADED
 !item [AWS_SHADED]       Das Fenster wurde vom System shaded, d.h. es wurde
                  zusammengeklappt, so daž nur der Fensterbalken zu
                  sehen ist. In diesem Zustand werden die Maus-Formen,
                  die im AOBJECT hinterlegt sind, nicht mehr
                  aktiviert, da das Work-Objekt nicht sichtbar ist.
!end_xlist

(!B)Die folgenden Werte drfen auch per Programm ver„ndert werden:(!b)

!begin_xlist [AWS_FORCEREDRAW]
!label AWS_FORCEREDRAW
 !item [AWS_FORCEREDRAW]  Bei manchen Operationen sendet AES keine REDRAW-
                  Nachricht. Um dennoch das Auffrischen zu erzwingen,
                  kann dieses Flag gesetzt werden. Ein Beispiel, wo
                  dieses Flag innerhalb (!I)ACSpro(!i) zur Anwendung kommt,
                  ist das Verkleinern des Listenfensters. Die AES
                  unterstellt, daž der Inhalt beim Verkleinern nicht
                  ver„ndert wird. Bei Listenfenstern ver„ndert sich
                  dadurch aber die Anordnung und die
                  Bildschirmdarstellung muž daher aufgefrischt werden.

!label AWS_LATEUPDATE
 !item [AWS_LATEUPDATE]   Informationen, die zu diesem Fenster geh”ren, wurden
                  ver„ndert. Die init-Routine wird nach Rckkehr zur
                  Hauptschleife aufgerufen. Ist das Fenster
                  geschlossen, wird nur das Flag AWS_MODIFIED gesetzt.
                  Damit kann das Auffrischen gebndelt werden. Ein
                  Beispiel: Ist das Texte-Fenster des Editors offen
                  und wird eine Kopieroperation von Objekten aus
                  fremden Dateien vorgenommen, werden in der Regel
                  sehr viele neue Texte angelegt. Wrde nun nach jedem
                  Text die Anzeige aufgefrischt, ginge sehr viel Zeit
                  und Speicherplatz verloren. Setzt das offene Fenster
                  immer wieder selbst dieses Flag, wird es immer
                  wieder aufgerufen. Damit kann eine Art Multitasking
                  realisiert werden.

!label AWS_TERM
 !item [AWS_TERM]         Dieses Flag zeigt an, daž sich dieses Fenster in der
                  Terminiersequenz befindet. Gewisse Operationen sind
                  dann berflssig. Ist das Fenster noch offen, wird
                  der ikonifizierte Zustand bergangen.

!label AWS_INTERM
 !item [AWS_INTERM]       Dieses Flag sollte der Benutzer setzen wenn das
                  Fenster beim terminieren ist. Komplexe
                  Terminiersequenzen, z.B. wenn mehrere Fenster
                  beteiligt sind, k”nnen dazu fhren, daž Fenster sich
                  gegenseitig l”schen (= Terminieren) wollen. Anhand
                  dieses Flags kann die Terminierroutine ein doppeltes
                  Durchlaufen verhindern. (!I)ACSpro(!i) selbst beachtet
                  dieses Flag nicht.
!end_xlist

!end_node


!begin_node Objekt-States

(!I)ACSpro(!i) definiert einige der nicht verwendeten Bits von ob_state der
Struktur OBJECT bzw. AESOBJECT. Die definierten Flags fr ob_state
lauten:

!begin_xlist [AOS_DCLICK]
!label AOS_FIXED
 !item [AOS_FIXED]    Im ersten Objekt des Objektbaumes ist dieser Status
              gesetzt, wenn der Objektbaum schon von Zeichen- in
              Pixelkoordinaten konvertiert wurde. Siehe auch Aob_fix.

!label AOS_DCLICK
 !item [AOS_DCLICK]   Dieses Objekt wurde durch einen Doppelklick angew„hlt.
              Der Status ist nur fr die aktuelle ev_obnr gltig.

!label AOS_CONST
 !item [AOS_CONST]    Substrukturen der Objektb„ume werden normalerweise durch
              den Aufruf Aob_create dupliziert bzw. durch Aob_delete
              freigegeben. Das Duplizieren bzw. Freigeben kann durch
              diesen Status unterbunden werden. Das ist sinnvoll um
              Speicher zu sparen und um Freigaben zu verhindern.
              Dieser Status soll nur mit sehr viel Vorsicht eingesetzt
              werden.
!end_xlist

Um bei den Objektnummern zwischen der Toolbar und dem Workobjekt
unterscheiden zu k”nnen, sind die Konstanten (!link [A_TOOLBAR] [A_TOOLBAR]) und (!link [A_MASK] [A_MASK])
definiert worden.

!end_node


!begin_node Objekt-Flags

(!I)ACSpro(!i) definiert einige der nicht verwendeten Bits von ob_flags und
ob_state der Struktur OBJECT bzw. AESOBJECT. Folgende Flags fr
ob_flags sind definiert:

!begin_xlist [AO_DRAGABLE]
!label AEO
 !item [AEO]          Dieses Objekt ist ein erweitertes Objekt. Statt des
              Types OBJECT bzw. AESOBJECT ist der Typ AOBJECT zu
              verwenden.

!label AO_DEFABLE
 !item [AO_DEFABLE]   Dieses Objekt kann zum DEFAULT-Objekt werden. Durch den
              Tastendruck CTRL-TAB wird zum n„chsten DEFAULT-Objekt
              weitergeschaltet. Siehe auch Awi_keys.

!label AO_DRAGABLE
 !item [AO_DRAGABLE]  Das Objekt wird als ziehbar markiert.

!label AO_ACCEPT
 !item [AO_ACCEPT]    Dieses Objekt kann Objekte annehmen.

!label AO_SILENT
 !item [AO_SILENT]    Objekte werden still angenommen. Das heižt, daž das
              Objekt beim Daraufziehen nicht invertiert wird.
!end_xlist

Um bei den Objektnummern zwischen der Toolbar und dem Workobjekt
unterscheiden zu k”nnen, sind die Konstanten (!link [A_TOOLBAR] [A_TOOLBAR]) und (!link [A_MASK] [A_MASK])
definiert worden.

!end_node


!begin_node Objekt-Nummern

Um bei den Objektnummern zwischen der Toolbar und dem Workobjekt
unterscheiden zu k”nnen, sind die folgenden Konstanten definiert

!begin_xlist [A_TOOLBAR]
!label A_TOOLBAR
 !item [A_TOOLBAR]  Einige Funktionen haben keinen eigenen Parameter fr den
            gewnschten Objektbaum z.B. Awi_obchange. Daher wird die
            'obnr' mit der Konstante A_TOOLBAR per Oder verknpft.
            Damit schr„nkt sich zwar die Anzahl m”glicher Objekte im
            Objektbaum auf 4096 ein, was fr die Praxis jedoch mehr
            als ausreichend ist.

!label A_MASK
 !item [A_MASK]     Einige Funktionen liefern m”glicherweise Objektindizes,
            die mit A_TOOLBAR verOdert sind. Um diese und zuknftige
            Flags abzutrennen existiert die Mask A_MASK. Eine
            Verknpfung per Und ergibt den reinen Objektindex.
!end_xlist

!end_node


!begin_node Vordefinierte Fenster-Nachrichten

(!I)ACSpro(!i) definiert einige Nachrichten vor. Der Nummernkreis 1 bis 9999
ist (!I)ACSpro(!i) vorbehalten. Applikationseigenen Nachrichten verbleibt der
Nummernkreis von 10000 bis 32000. Fr (!I)ACSpro(!i)-Erweiterungen, die einem
grožem Kreis zug„nglich gemacht werden, lassen Sie bitte die
entsprechenden Nachrichten beim Support registrieren.

(!B)Allgemeine Nachrichten:(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_ACCLOSED]           Accessory wurde geschlossen

 !item [AS_TERM]               Fenster soll terminieren

 !item [AS_ICONIZED]           Fenster wurde ikonifiziert

 !item [AS_MOUSE]              Die Maus wurde bewegt

 !item [AS_SELECTADD]          Es wurde ein weiteres Objekt selektiert

 !item [AS_SELECTDEL]          Es wurde ein/alle Objekt(e) deselektiert

 !item [AS_UNTOPPED]           GEM-Nachricht UNTOPPED erhalten

 !item [AS_FOCUSCHG]           Der Eingabefokus wurde ver„ndert

 !item [AS_CHECKDRAG]          Prfe ob Fenster gezogene Objekte ann„hme

 !item [AS_OPEN]               Selektierte Objekte ”ffnen

 !item [AS_DELETE]             Selektierte Objekte l”schen

 !item [AS_CHECKDELETE]        Prfe ob gezogene Objekte gel”scht werdn k”nnen

 !item [AS_WIAUTOPOS]          Das Fenster wurde automatisch positioniert

 !item [AS_INFO]               Das Fenster soll informieren

 !item [AS_DRAGGED]            Ein Objekt wurde auf das Fensterikon gezogen

 !item [AS_CHECKDRAGGED]       Prfe ob Fensterikon Objekte ann„hme

 !item [AS_CONFIGDRAG]         Konfiguriere Ziehoperation

 !item [AS_DRAGABORTED]        Ziehoperation wurde auf fremden Fenster beendet

 !item [AS_REALSEL_START]      Start einer neuen Auswahl-Liste

 !item [AS_REALSEL_UPDATE]     Žnderung der Auswahl-Liste

 !item [AS_REALSEL_END]        Ende der Auswahl-Liste

 !item [AS_REALPOP_START]      Start der Popupbedienung

 !item [AS_REALPOP_UPDATE]     Žnderung des Popupeintrags

 !item [AS_REALPOP_END]        Ende des Popups

 !item [AS_EDITCHG]            Neue Taste in der Eingabe

 !item [AS_GEM_MESS]           Unbekannte GEM-Message erhalten

 !item [AS_SCRAP_UPDATE]       Das Klemmbrett wurde erneuert

 !item [AS_SCRAP_IMPORT]       Aufforderung, aus dem Klemmbrett zu importieren

 !item [AS_SCRAP_EXPORT]       Aufforderung, ins Klemmbrett zu exportieren

 !item [AS_REALMENU_START]     Start der Menfhrung

 !item [AS_REALMENU_UPDATE]    Žnderung des Meneintrags

 !item [AS_REALMENU_END]       Ende der Menfhrung

 !item [AS_HELP]               Ausgabe einer Hilfe bers Hilfe-Fenster

 !item [AS_LOOKSTRING]         Suche Text in eigenen Datenstrukturen

 !item [AS_REDRAWFILE]         Aktualisieren eines Laufwerks

 !item [AS_LOADFILE]           Programm soll Datei laden

 !item [AS_SELECTFILE]         Fenster soll Datei(en) selektieren

 !item [AS_SAVEFILE]           Aufforderung zum Sichern

 !item [AS_ALLOWBUBBLE]        Frage, ob eine BubbleGEM-Hilfe angezeigt werden
                       darf

 !item [AS_GETBUBBLE]          Der Text fr eine BubbleGEM-Hilfe wird erfragt

 !item [AS_OLGA_DISCONNECT]    Eine OLGA-Verbindung wurde getrennt

 !item [AS_OLGA_UPDATED]       Eine Datei wurde vom (!link [OLGA-Server] [OLGA-Server]) ge„ndert, das
                       Fenster soll geeignet darauf reagieren

 !item [AS_OLGA_MAKE_INFO]     Ein (!link [OLGA-Client] [OLGA-Client]) hat eine Info-Datei
                       angefordert, die das Fenster bereitstellen soll

 !item [AS_OLGA_CLEAR_INFO]    Der (!link [OLGA-Client] [OLGA-Client]) hat die Info-Datei ausgelesen,
                       sie kann wieder gel”scht werden
!end_xlist

(!B)generischer Desktop(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_PLACEICON]          Plaziere das Ikon

 !item [AS_REMICON]            Entferne das Ikon

 !item [AS_GHOSTICON]          Stelle das Ikon als Ghostikon dar

 !item [AS_NORMICON]           Stelle das Ikon wieder normal dar

 !item [AS_NEWCALL]            Melde (Awindow.create) Routine an

 !item [AS_BACKOBJECT]         Melde andere Hintergrund an

 !item [AS_ICONNEW]            Melde anderes Neu-Icon an

 !item [AS_ICONTRASH]          Melde anderen Papierkorb an

 !item [AS_ICONWINDOW]         Melde anderes Fenster an

 !item [AS_UPDATEICON]         Frische Fensterikonen auf
!end_xlist

(!B)EDITOR-Fenster Nachrichten(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_EDGETENTRY]         Gibt den Zeiger auf den Userdefeintrag zurck

 !item [AS_EDEXT]              Setzt Erweiterung (Extension)

 !item [AS_EDLOADFILE]         Es wird der Name der Datei bergeben, die
                       geladen werden soll

 !item [AS_EDTITLE]            Der Normaltitle wird gesetzt

 !item [AS_EDTITLEDIRTY]       Der Modifizierttitel wird gesetzt

 !item [AS_EDPUTSTRING]        Ein Text wird bergeben

 !item [AS_EDGETSTRING]        Der Edittext wird zurckgeschrieben

 !item [AS_EDGETNEED]          Berechnet den Speicherbedarf des Textes

 !item [AS_EDWINDOW]           Setzt Steuerfenster

 !item [AS_EDTERM]             Das Editorfenster will terminieren

 !item [AS_EDSAVE]             Das Editorfenster ist ungesichert

 !item [AS_EDCLEAN]            Stuft den Text als ummodifiziert ein

 !item [AS_EDHOME]             Die Startposition wird sichtbar

 !item [AS_EDICONTEXT]         šbergibt den Text fr die Editorikone

 !item [AS_EDSAVEIT]           Aufforderung zum Sichern
!end_xlist

(!B)PROTOCOL-Fenster Nachrichten(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_EDGETENTRY]         Gibt den Zeiger auf den Userdefeintrag zurck
!end_xlist

(!B)PLOTTER-Fenster Nachrichten(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_PLOTHANDLE]         Gibt das VDI-Handle zurck

 !item [AS_PLOTMFDB]           Gibt den verwendeten MFDB zurck

 !item [AS_PLOTSIZE]           Setzt eine neue Gr”že

 !item [AS_PLOTENTRY]          Gibt den Zeiger auf den Userdefeintrag zurck
!end_xlist

(!B)Programmspezifische Nachrichten, ab Version 2.2(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_ASKHELP]            Sucht Hilfe-Fenster

 !item [AS_ASKLAZY]            Sucht LAZy-Fenster

 !item [AS_ASKFILE]            Sucht Dateidarstellungsfenster?

 !item [AS_ASKTURNUS]          Sucht TURNUS-Fenster?

 !item [AS_ASKNOTIO]           Sucht NOTIO-Fenster?
!end_xlist

(!B)Interne Nachrichten, ab Version 2.2(!b)

!begin_xlist [AS_REALMENU_UPDATE]
 !item [AS_DOARCHIVE]          LAZy-Shell

 !item [AS_CEWS_BASE]          ACS-intern...

 !item [AS_CEWS_ACSSAVE]       ACS-intern...
!end_xlist

!end_node


!begin_node Die Userdef-Standard-Nachrichten

Die Nachrichten werden durch die Service-Funktion bearbeitet. Sie wird

in Pure-C

!begin_preformatted
        auserblk = (AUSERBLK*)entry->ob_spec.userblk;
        auserblk->ub_serv(entry, Nachricht, Parameter);
!end_preformatted

in Pure-Pascal

!begin_preformatted
        auser := AUSERBLKPtr(entry^.aes.ob_spec.userblk);
        db := auser^.ub_serv(entry, Nachricht, Parameter);
!end_preformatted

aufgerufen. 'entry' ist von Typ OBJECT* bzw ACSOBJECTPtr und ist der
Ojekteintrag, das den Userdef benutzt. Nachricht ist die zu sendende
Nachricht. Parameter der optionale Parameter, der die Nachricht
erg„nzt. Er sollte NULL/NIL sein, wenn diese Nachricht keinen
Parameter hat. Die Wirkung der Nachricht kann bei unterschiedlichen
Userdef unterschiedlich ausfallen. Es sollte jedoch m”glichst analog
reagiert werden.

Analog zu den Fensterservices liefert die Routine den Wert TRUE wenn
eine derartige Nachricht vorgesehen ist und mit Erfolg bearbeitet
wurde. Existiert keine solche Nachricht oder konnte die Bearbeitung
der Nachricht aufgrund von Fehlern nicht durchgefhrt werden, wird
FALSE zurckgegeben.

Die folgenden Nachrichten - mit ihren Datentypen des Parameters - sind
definiert:

!begin_xlist [AUO_FULLUPDATE]
!label AUO_CREATE
 !item [AUO_CREATE]      Userdef wird initialisiert. Hier sollte das Userdef
                 ben”tigten Speicherplatz anfordern und in einen der
                 Userpointer eintragen. Als Parameter wird

                      Fr Pure-C: INT16 *success;

                      Fr Pure-Pascal: success: Integer;

                 bergeben. Falls die Initialisierung nicht klappte,
                 sollte der Wert 'FAIL' zugewiesen werden, um dem
                 Aufrufenden das Mižlingen mitzuteilen

!label AUO_TERM
 !item [AUO_TERM]        Der Userdef wird freigegeben. Allozierter Speicher
                 sollte hier freigegeben werden.

!label AUO_GETVAL
 !item [AUO_GETVAL]      Der Aufrufer wnscht den String-Wert zu lesen

                      Fr Pure-C: char **text;

                      Fr Pure-Pascal: text: Pointer;

                 Der Wert darf kopiert, aber nicht direkt ge„ndert
                 werden.

!label AUO_SETVAL
 !item [AUO_SETVAL]      Der String-Wert wird gesetzt.

                      Fr Pure-C: char *text;

                      Fr Pure-Pascal: text: Pointer;

!label AUO_UPDATE
 !item [AUO_UPDATE]      Das Userdef sollte seinen aktuellen Zustand zeigen.
                 Dazu werden Information ber das Fenster und der
                 Objektnummer gebraucht, die mit AUO_SELF bergeben
                 werden. Aufwendige Userdefs wie der Editor oder der
                 (!link [Slider] [Slider]) merken, das nur Teile durch vorhergehende
                 Nachrichten auszufhren sind und tun daher auch nur
                 das N”tigste (smart update).

!label AUO_FULLUPDATE
 !item [AUO_FULLUPDATE]  Aus irgend einem Grund wird ein Vollupdate gewnscht.
                 Im Gegensatz zu einem entsprechenden (wi-
                 >obchange)(...) wird das Userdef dabei in Kenntnis
                 gesetzt.

!label AUO_SELF
 !item [AUO_SELF]        Dem Userdef wird sein Fenster, sein Objekteintrag und
                 Objektnummer mitgeteilt, die es braucht um selbst„tig
                 Updateoperationen durchzufhren. Dazu wird

                      fr Pure-C: Awiob *wiob;

                      fr Pure-Pascal: wiob: AwiobPtr;

                 bergeben.

!label AUO_OWNER
 !item [AUO_OWNER]       Die per AUO_SELF bergebene Identit„t kann hiermit
                 jederzeit wieder ermittelt werden. Da dies nur in
                 Live-Routinen Sinn macht, wird diese Nachricht
                 normalerweise auch nur bei Objekten mit einer Live-
                 Routine untersttzt.

!label AUO_NEXT
 !item [AUO_NEXT]        Es soll zum n„chsten Wert geschritten werden

!label AUO_PREV
 !item [AUO_PREV]        Es soll zum vorigen Wert geschritten werden

!label AUO_NEXTPAGE
 !item [AUO_NEXTPAGE]    Es soll ein 'Seitensprung' nach vorne erfolgen.

!label AUO_PREVPAGE
 !item [AUO_PREVPAGE]    Es soll ein 'Seitensprung' zurck erfolgen.

!label AUO_BEGIN
 !item [AUO_BEGIN]       Es soll an den Anfang gesprungen werden.

!label AUO_END
 !item [AUO_END]         Es soll an das Ende gesprungen werden.

!label AUO_POS
 !item [AUO_POS]         Die Position soll auf den bergebenen Wert gesetzt
                 werden.

                      Fr Pure-C: INT16 *pos;

                      Fr Pure-Pascal: pos: ^Integer;

!label AUO_GETBUBBLE
 !item [AUO_GETBUBBLE]   Es soll eine BubbleGEM-Hilfe zum UserDef angezeigt
                 werden. Dem Userdef wird der Text bergeben. Der Text
                 kann ver„ndert oder sogar durch NULL bzw. NIL
                 gel”scht werden. Falls ein leerer Text bergeben
                 wird, wird keine BubbleGEM-Hilfe angezeigt.

                      Fr Pure-C: char **text;

                      Fr Pure-Pascal: text: Pointer;
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node

!end_node


!begin_node Die Strukturen

(!I)ACSpro(!i) definiert die folgenden Strukturen:

 Aaction

 Acreate

 Adescr

 Amouse

 AOBJECT

 Asel

 Awindow

 Awiob

 A_dd

 A_FileList

 EDITGETS

 EDITLIVE

 EDITSUBS

 OLGA_Info

 PROTOCOLDATA

 PLOTTERDATA

 SLLIVE

 ULinList

 Queue

!end_node


!begin_node Die Variablen

Alle (!I)ACSpro(!i)-Variablen sind in der Struktur Ablk zusammengefažt. Die
Variable ACSblk zeigt auf diese Struktur. Auf alle Variablen sollte
demnach ber den Zeiger ACSblk zugegriffen werden, z.B. sollte auf die
Variable ev_window ber ACSblk->ev_window zugegriffen werden.

Folgende Variablen existieren (und sind ber den Zeiger ACSblk
zug„nglich):

!subtoc [all] !depth 1


!begin_node AES-orientierte Variablen

!begin_xlist [phys_handle]
 !item [gl_apid]       Die AES-Application-ID

 !item [phys_handle]   VDI-Workstation der AES

 !item [gl_wattr]      Attribut-Breite

 !item [gl_hattr]      Attribut-H”he

 !item [desk]          Desktop-Grenzen

 !item [apterm]        Die Nachricht AP_TERM wurde empfangen

 !item [AESglobal]     Das global-Feld fr AES-Aufrufe

 !item [menu_id]       Men-ID im Accessory-Modus oder -1
!end_xlist

!end_node


!begin_node VDI-orientierte Variablen

!begin_xlist [screenMFDB]
 !item [vdi_handle]    Die virtuelle VDI-Workstation fr (!I)ACSpro(!i)

 !item [gl_wbox]       Zellenbreite eines "Standard-Zeichens"

 !item [gl_hbox]       Zellenh”he eines "Standard-Zeichens"

 !item [gl_wchar]      Maximale Breite eines "Standard-Zeichens"

 !item [gl_hchar]      Maximale H”hr eines "Standard-Zeichens"

 !item [ncolors]       Anzahl der Farben

 !item [nplanes]       Anzahl der Farbebenen

 !item [fonts]         Anzahl der verfgbaren Zeichens„tze

 !item [screenMFDB]    MFDB des Bildschirmes fr Kopieraktionen

 !item [fontid]        Font-ID fr UserDefs

 !item [fheight]       H”he des Fonts fr UserDefs

 !item [fontsid]       Font-ID des kleinen Fonts fr UserDefs

 !item [fsheight]      H”he des kleinen Fonts fr Userdefs
!end_xlist

!end_node


!begin_node Pfad-Variablen

!begin_xlist [alert_name}
 !item [appname]       Kompletter Dateiname (incl. Pfad) der Anwendung

 !item [apppath]       Kompletter Pfad der Anwendung

 !item [apppara]       Parameter der Anwendung

 !item [appfrom]       Aufrufer der Anwendung

 !item [basename]      Name der Anwendung (ohne Extension)

 !item [cfg_path]      Kompletter Pfad fr Konfigurationsdateien

 !item [scrp_path]     Kompletter Pfad des Klemmbretts

 !item [dd_name]       Global verfgbarer Name fr alle D&D-Protokolle

 !item [alert_name]    Eigener Name fr die Titelzeilen von eigenen Alert-
               Boxen
!end_xlist

!end_node


!begin_node Variablen fr die Drag- & Click-Routinen

!begin_xlist [ev_mmokstate]
 !item [ev_window]     Aktuelles Fenster

 !item [ev_object]     Aktueller Objektbaum

 !item [ev_obnr]       Aktueller Objektbaum-Index

 !item [ev_mmox]       X-Koordinate der Maus-Position

 !item [ev_mmoy]       Y-Koordinate der Maus-Position

 !item [ev_mmokstate]  Tastaturstatus

 !item [dia_abort]     Flag fr den Abbruch eines modalen Dialoges
!end_xlist

!end_node


!begin_node Variablen der Event-Schleife

!begin_xlist [ev_mmobutton]
 !item [ev_bmask]      Bitvektor der zu berwachenden Maustasten

 !item [ev_bstate]     Zustand der Maustasten, der eintreten soll

 !item [ev_mmobutton]  Zustand der Mauskn”pfe bei einem Ereignis

 !item [ev_mbreturn]   Anzahl der Mausklicks

 !item [ev_mkreturn]   NKCC-Tastencode der gedrckten Taste

 !item [ev_mbclicks]   Anzahl der Mausklicks, auf die gewartet werden soll
!end_xlist

!end_node


!begin_node Funktions-Zeiger

(!I)ACSpro(!i) bietet verschiedene Benutzereinsprnge an. šber den Zeiger
ACSblk sind fast alle Funktions-Zeiger auf diese Prozedurevariablen
zug„nglich. Die Zeiger werden mit den Adressen von (!I)ACSpro(!i)-Routinen
belegt. Die einzige Ausnahme ist die Routine ACSinit.

!begin_xlist [ACSGEMScript]
 !item [ACSterm]       Funktion, die kurz vor dem Beenden der Anwendung
               aufgerufen wird

 !item [ACSaboutme]    Klick-Routine des Eintrags `šber mich...'

 !item [ACSclose]      Klick-Routine, um die Anwendung zu beenden

 !item [ACSmessage]    Bearbeiten von nicht verarbeitete Messages

 !item [ACStimer]      Timer-Funktion, die in der Event-Schleife regelm„žig
               aufgerufen wird

 !item [ACSinit0]      Initialisierungsfunktion, die nach Initialisierung der
               Variablen, der AES und des VDI und vor Initialisierung
               des (!I)ACSpro(!i)-Systems aufgerufen wird

 !item [ACSmproto]     Protokollieren oder filtern von GEM-Messages

 !item [ACSkey]        Protokollieren oder filtern von Tastendrcken

 !item [ACSbutton]     Protokollieren oder filtern von Maus-Klicks

 !item [ACSmouse]      Protokollieren oder filtern von Maus-Bewegungen

 !item [ACSwikey]      Protokollieren oder filtern von Tastendrcken kurz vor
               der šbergabe an die Awindow.keys-Routine

 !item [ACSerror]      (!I)ACSpro(!i)-globale Fehlerroutine zur Ausgabe von
               Fehlermeldungen

 !item [ACSGEMScript]  Funktion zur Verarbeitung von allgemeinen GEMScript-
               Kommandos

 !item [DEBUG_MEM]     Anzeigen und bearbeiten von Speicherfehlern
!end_xlist

!end_node


!begin_node Sonstige Variablen

!begin_xlist [description]
 !item [ev_mtcount]    Timerintervall (in ms) fr die Event-Schleife

 !item [application]   Flag, ob die Anwendung als Accessory l„uft (FALSE) oder
               nicht (TRUE)

 !item [multitask]     Flag, ob die Anwendung in einer Multitasking-Umgebung
               l„uft

 !item [appexit]       Flag, ob die Anwendung beendet wird

 !item [description]   Oberfl„chenbeschreibungen (Zeiger zum schnellen
               "Auswechseln")

 !item [Aselect]       Die Auswahlliste

 !item [argc]          Die Anzahl der Parameter, die bergeben wurden

 !item [argv]          Das Parameter-Array

 !item [env]           Die Environments der Anwendung

 !item [dither]        Konfiguration des Dither-Modus

 !item [separator]     Zeichen, die als Worttrenner benutzt werden sollen

 !item [mfsel_count]   Maximale Anzahl von Dateien, die ber die Mehrfach-
               Dateiauswahl gew„hlt werden k”nnen sollen
!end_xlist

!end_node

!end_node


!begin_node Die Funktionen

Die von (!I)ACSpro(!i) zur Verfgung gestellten Funktionen lassen sich in
verschiedene Kategorien einteilen.

!subtoc [all] !depth 1


!begin_node Fenster-Funktionen

Der Datentyp Awindow beschreibt ein Fenster. Er ist fr (!I)ACSpro(!i) von
zentraler Bedeutung. Die Struktur enth„lt Zeiger auf verschiedene
Routinen, fr die zun„chst einmal komplett Standardroutinen eingesetzt
werden. Der Benutzer kann sie gegebenfalls durch eigene ersetzen. Fr
die create-Komponente ist das zu empfehlen, da dort diverse
Datenstrukturen neben der Fensterstruktur erzeugt werden k”nnen und
dem Fenster in der user-Komponente quasi als 'lokale' Daten zugewiesen
werden k”nnen, wie im Beispiel zur Komponente Awindow.user ersichtlich
ist.

Eigene Routinen sollten in der Regel die (!I)ACSpro(!i)-Routinen aufrufen und
sich im Verhalten nicht zu sehr von gltigen Standards entfernen, da
dann die Reaktionen des Programmes den Anwender irritieren.

Sollten Sie in eigenen Routinen auf die Werte anderer Fenster Bezug
nehmen (Position etc.), so mssen Sie eventuelle Redraw-Fehler dadurch
vermeiden, indem sie mit Aev_mess die normale Ereignisbearbeitung
erm”glichen.

Technisch ist noch ein Unterschied zwischen einer per create-Routine
erzeugter Fensterstruktur und der 'Vorlage', der sogenannten 'Klasse'
zu betonen: Per create wird eine Kopie der Klasse angelegt, die
Objektb„ume angepažt und diverse Werte initialisiert. Diese
Kopie/Instanz der Klasse muž am Schluž per Awi_delete wieder
freigegeben werden - nicht jedoch die Vorlage/Klasse. Alle weiteren
(!I)ACSpro(!i)-Routinen sind nur fr Instanzen konzipiert.

Die folgenden Standardroutinen sind vorhanden

!begin_xlist [Awi_selfcreate]
 !item [Awi_wid]         Zeiger auf die Fensterstruktur ermitteln

 !item [Awi_root]        Zeiger des Rootfensters ermitteln

 !item [Awi_list]        N„chste existente Fensterstruktur ermitteln

 !item [Awi_down]        Vorheriges Fenster nach oben bringen

 !item [Awi_up]          N„chstes Fenster nach oben bringen

 !item [Awi_show]        Fenster zeigen

 !item [Awi_init]        Fenster initialisieren

 !item [Awi_create]      Fenster erzeugen

 !item [Awi_open]        Fenster ”ffnen

 !item [Awi_closed]      Fenster schliežen

 !item [Awi_delete]      Fenster entfernen

 !item [Awi_topped]      Fenster nach oben bringen

 !item [Awi_fulled]      Fenster auf maximale Gr”že bringen

 !item [Awi_sized]       Fenstergr”že einstellen

 !item [Awi_moved]       Fenster positionieren

 !item [Awi_diaend]      Eingabe in einem offenen Dialog beenden

 !item [Awi_diastart]    Eingabe in einm offenen Dialog starten

 !item [Awi_diaabort]    Modalen (Fenster-)Dialog beenden

 !item [Awi_keys]        Tastendruck auswerten, die Weiterleitung der nicht
                 verarbeiteten Tastendrcke (!I)nicht(!i) an den AV-Server
                 wird unterdrckt

 !item [Awi_keysend]     Tastendruck auswerten, die Weiterleitung der nicht
                 verarbeiteten Tasten an den AV-Server ist m”glich

 !item [Awi_sendkey]     Dummy-Tastenroutine, die aužer der Help-Taste das
                 Senden des Tastendruckes an den AV-Server veranlažt

 !item [Awi_nokey]       Dummy-Tastenroutine, die nichts an den AV-Server
                 senden l„žt und nur die Help-Taste auswertet

 !item [Awi_help]        Zeigt ST-Guide-Hilfe zum Fenster an

 !item [Awi_obview]      Inneres Objekt sichtbar machen

 !item [Awi_service]     Service-Routine

 !item [Awi_sendall]     Nachricht an alle Fenster senden

 !item [Awi_obchange]    Zustand eines Objekts „ndern

 !item [Awi_obredraw]    Objekt zeichnen

 !item [Awi_redraw]      Fensterteile neu zeichnen

 !item [Awi_arrowed]     Pfeil-Operationen durchfhren

 !item [Awi_hslid]       Horizontale Slideroperationen durchfhren

 !item [Awi_vslid]       vertikale Slideroperationen durchfhren

 !item [Awi_scroll]      Bildschirm verschieben

 !item [Awi_dialog]      Routine fr modale Fensterdialoge

 !item [Awi_doform]      Routine fr modale Fensterdialoge, schaltet zur Not
                 auf A_dialog um

 !item [Awi_modal]       Ermitteln, ob modaler Fenstrdialog offen

 !item [Awi_alert]       Analog zu form_alert eine Fenster-Meldung

 !item [Awi_selfcreate]  Kurze create-Routine

 !item [Awi_update]      internes wind_update

 !item [Awi_uoself]      USERDEFs initialisieren

 !item [Awi_gemscript]   GEMScript-Kommandos fr das Fenster bearbeiten

 !item [Awi_ontop]       Das oberste Fenster der Applikation ermitteln

 !item [Awi_layout]      3D-Darstellung und moderne Mens ein-/ausschalten
!end_xlist

!end_node


!begin_node Object-Funktionen

(!I)ACSpro(!i) legt dynamisch Objekte und Objektb„ume an, wenn sie ben”tigt
werden, und l”scht sie nach Gebrauch wieder. Hierfr stehen eine Reihe
von Funktionen zur Erzeugung von Objekten (und deren "Einzelteilen")
sowie zum L”schen der erzeugten Objekte bereit. Dies sind

!begin_xlist [Aob_create]
 !item [Aob_create]  Objektbaum-Kopie erzeugen

 !item [Aob_delete]  Objektbaum freigeben

 !item [Ast_create]  String-Kopie erzeugen

 !item [Ast_delete]  String-Speicherplatz freigeben

 !item [Ate_create]  TEDINFO-Kopie erzeugen

 !item [Ate_delete]  TEDINFO-Speicherplatz freigeben

 !item [Aic_create]  Ikone-Kopie erzeugen

 !item [Aic_delete]  Ikone-Speicherplatz freigeben

 !item [Aim_create]  Bild-Kopie erzeugen

 !item [Aim_delete]  Bild-Speicherplatz freigeben

 !item [Aus_create]  AUSERBLK-Kopie erzeugen

 !item [Aus_delete]  AUSERBLK-Speicherplatz freigeben
!end_xlist

(!I)Achtung:(!i) Die 'Axx_delete'-Aufrufe drfen nur fr Objekte verwendet
werden, die mit dem entsprechenden 'Axx_create' erzeugt wurden.

Ferner werden einige Routinen zum Bearbeiten und Manipulieren der
erzeugten Objektb„ume bereitgestellt. Diese sind

!begin_xlist [Aob_findflag]
 !item [Aob_create]    Objektbaum-Kopie erzeugen

 !item [Aob_delete]    Objektbaum freigeben

 !item [Aob_fix]       Objektbaum-Koordinaten umwandeln

 !item [Aob_offset]    Objekt-Koordinaten berechnen

 !item [Aob_save]      Desktop-Rechteck sichern

 !item [Aob_restore]   Desktop-Rechteck zurckschreiben

 !item [Aob_watch]     Objekt unter Maus anzeigen

 !item [Aob_findflag]  Objekt mit speziellem Flag suchen

 !item [Aob_up]        Elternobjekt suchen

 !item [Aob_puttext]   Text in Objekt schreiben

 !item [Aob_gettext]   Text aus Objekt auslesen

 !item [Aob_printf]    Text formatiert in Objekt schreiben

 !item [Aob_scanf]     Text formatiert aus Objekt auslesen

 !item [Aob_within]    Prfen, ob ein Punkt im Rechteck liegt

 !item [Aob_alias]     (!link [Click-Routine] [Click-Routine]), die den Click an ein anderes Objekt
               weitergibt.
!end_xlist

!end_node


!begin_node Men-Funktionen

(!I)ACSpro(!i) legt dynamisch Objekte und Objektb„ume an, wenn sie ben”tigt
werden, und l”scht sie nach Gebrauch wieder. Hierfr stehen eine Reihe
von Funktionen zur Erzeugung von Objekten (und deren "Einzelteilen")
sowie zum L”schen der erzeugten Objekte bereit. Dies sind

!begin_xlist [Ame_strpopup]
 !item [Aob_create]   Objektbaum-Kopie erzeugen (ein Men ist ja ein
              Spezialfall eines Objektbaumes)

 !item [Aob_delete]   Objektbaum freigeben (ein Men ist ja ein Spezialfall
              eines Objektbaumes)

 !item [Ame_namefix]  Die Positionen der Men-Titel anpassen

 !item [Ame_strpopup] Ein durch einen String beschriebenes Popup-Men anzeigen
              und einen Eintrag ausw„hlen lassen

 !item [Ame_popup]    Ein Popup anzeigen und einen Eintrag ausw„hlen lassen
!end_xlist

!end_node


!begin_node String-Funktionen

(!I)ACSpro(!i) stellt erweiterte String-Funktionen bereit und erweitert so die
Auswahl an Funktionen der Standard-Bilbiothek. Die folgenden
Funktionen existieren:

!begin_xlist [Ach_tolower]
 !item [Ach_tolower]  Buchstaben in Kleinbuchstaben wandeln - Umlaute werden
              korrekt bercksichtigt

 !item [Ach_toupper]  Buchstaben in Grožbuchstaben wandeln - Umlaute werden
              korrekt bercksichtigt

 !item [Ach_isWhite]  Prfen, ob Zeichen ein "Blank" (Leerzeichen, Tabulator,
              Carriage-Return, Line-Feed) ist

 !item [Ast_adc]      String zentriert mit Leerzeichen auffllen

 !item [Ast_add]      Strings hintereinanderh„ngen und auf bestimmte L„nge mit
              Leerzeichen auffllen

 !item [Ast_adl]      String linksbndig mit Leerzeichen auffllen

 !item [Ast_adr]      String rechtsbndig mit Leerzeichen auffllen

 !item [Ast_cmp]      Zwei Strings vergleichen, Grož-/Kleinschreibung (!I)wird(!i)
              bercksichtigt

 !item [Ast_count]    H„ufigkeit von Zeichen im String z„hlen

 !item [Ast_create]   Erzeugen eines neuen Strings gem„ž einer Vorlage

 !item [Ast_delete]   Freigeben und L”schen eines Strings

 !item [Ast_deleteAry] Freigeben und L”schen eines Arrays von Strings - auch
              das Array wird per Ax_free freigegeben

 !item [Ast_icmp]     Zwei Strings vergleichen, Grož-/Kleinschreibung wird
              (!I)nicht(!i) bercksichtigt

 !item [Ast_isEmpty]  Prfen, ob ein String nur Blanks enth„lt

 !item [Ast_filter]   "Nicht erlaubte" Zeichen aus String herausnehmen

 !item [Ast_fcmp]     Dateinamen vergleichen, der erste darf die blichen
              Wildcards '*' und '?' enthalten

 !item [Ast_reverse]  Einen String rckw„rts "lesen"

 !item [Ast_tolower]  Alle Buchstaben (incl. Umlaute) in Kleinbuchstaben
              wandeln

 !item [Ast_toupper]  Alle Buchstaben (incl. Umlaute) in Grožbuchstaben
              wandeln

 !item [Ast_istr]     Einen Substring in einem String
              suchen, Grož-/Kleinschreibung wird (!I)nicht(!i) bercksichtigt
!end_xlist

!end_node


!begin_node Tedinfo-Funktionen

GEM-Eingabefelder werden durch die TEDINFO-Struktur beschrieben. Auch
diese Struktur wird von (!I)ACSpro(!i) dynamisch erzeugt und wieder
freigegeben. Meist wird jedoch das Userdef-BoxEdit verwendet werden,
da es wesentlich flexiblere Kontrollen ber die Eingaben erlaubt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
 !item [Ate_create]  Erzeugen einer TEDINFO-Struktur nach einer Vorlage

 !item [Ate_delete]  Freigeben und L”schen einer TEDINFO-Struktur
!end_enumerate

!end_node


!begin_node Icon-Funktionen

Die Ikonen (neudeutsch 'Icon') werden durch die ICONBLK-Struktur
beschrieben. Auch diese Struktur wird von (!I)ACSpro(!i) dynamisch erzeugt und
wieder freigegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
 !item [Aic_create]  Erzeugen eines Icons nach einer Vorlage

 !item [Aic_delete]  Freigeben und L”schen eines Icons
!end_enumerate

!end_node


!begin_node Image-Funktionen

Die Bilder (neudeutsch 'Images') werden durch die BITBLK-Struktur
beschrieben. Auch diese Struktur wird - wie alle Objekt-Strukturen -
von (!I)ACSpro(!i) dynamisch erzeugt und wieder freigegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
 !item [Aim_create]  Erzeugen eines Images nach einer Vorlage

 !item [Aim_delete]  Freigeben und L”schen eines Images
!end_enumerate

!end_node


!begin_node Userdef-Funktionen

Um die von (!I)ACSpro(!i) erweiterten USERDEF-Objekte handhaben zu k”nnen,
sind folgende Funktion implementiert worden:

!begin_xlist [Aus_create]
 !item [Aus_create]  Erzeugen einer AUSERDEF-Struktur nach einer Vorlage

 !item [Aus_delete]  Freigeben und L”schen einer AUSERDEF-Struktur

 !item [Aus_help]    (!link [Hilfeseite] [Awi_help]) fr das aktuelle Fenster aus ACSblk->ev_window
             aufrufen
!end_xlist

!end_node


!begin_node Ausgabe auf Userdefs

Es gibt analog zu printf aufgebaute Funktionen, um Userdefs mit Daten
zu fllen. Diese Funktionen sind wegen der variablen Parameter
zun„chst nur fr (Pure-)C vorhanden.

Dies sind die Funktionen

!begin_itemize
   !item uputs

   !item uprintf

   !item uvprintf
!end_itemize

!end_node


!begin_node Backplane-Untersttzung

Eine Backplane ist ein Stck Speicher, die sich unter gewissen
Bedingungen wie der Bildschirm verh„lt. Die Backplane kann kleiner
oder gr”žer als der tats„chliche Bildschirm sein. Durch AES- und VDI-
Routinen kann die Backplane bearbeitet werden. Es wird immer in der
aktuellen Farbaufl”ung gearbeitet.

(!B)Hinweis:(!b) Beim Schreiben auf die Backplane mittels VDI und AES mssen
negative LineA-Werte modifiziert werden. Soweit m”glich, sollte darauf
zugunsten von Offscreen-Bitmaps, wie sie z.B. von NVDI angeboten
werden, verzichtet werden. Fr Ash_CallEdDI(0)>=0x0100 sollte darber
eine Offscreen-Bitmap erzeugt und angesprochen werden - dann sind
Abp_start und Abp_end v”llig berflssig!

Die zur Verfgung gestellten FUnktionen sind

!begin_xlist [Abp_img2mfdb]
 !item [Abp_create]    Backplane erzeugen

 !item [Abp_delete]    Backplane-Speicher wieder freigeben

 !item [Abp_start]     Auf Backplane schreiben

 !item [Abp_end]       Wieder auf Bildschirm schreiben

 !item [Abp_img2mfdb]  Wandelt ein Image in ein MFDB

 !item [Abp_mfdb2img]  Wandelt ein MFDB in ein Image
!end_xlist

!end_node


!begin_node Mausoperationen

MIt den Mausoperationen kann die Darstellung des Maus-Zeigers
beeinflužt werden. Zur Verfgung stehen die folgenden Funktionen

!begin_xlist [Amo_unbusy]
 !item [Amo_new]     Neue Mausform setzen

 !item [Amo_busy]    Maus als Biene

 !item [Amo_unbusy]  Vorherige Mausform setzen

 !item [Amo_hide]    Mauszeiger verstecken

 !item [Amo_show]    Mauszeiger wieder zeigen
!end_xlist

!end_node


!begin_node Zieh-Operationen

Alle Objekte der Auswahlliste stammen aus genau einem Fenster. Bei
Fensterwechsel werden die bisher ausgew„hlten Objekte aus der Liste
entfernt. Die Reihenfolge der Aufnahme der Eintr„ge entspricht auch
der Reihenfolge beim Auslesen durch Adr_next.

Die folgenden Funktionen fr die Abfrage und fr die Manipulation der
Auswahlliste stehen zur Verfgung:

!begin_xlist [Adr_unselect]
 !item [Adr_box]       Rechteck aufziehen

 !item [Adr_drag]      Ziehen der Objekte beginnen

 !item [Adr_start]     Auswahllistenabfrage initialisieren

 !item [Adr_next]      N„chstes Auswahllisten-Objekt erfragen

 !item [Adr_add]       Auswahllisten-Objekt aufnehmen

 !item [Adr_del]       Ein Auswahllisten-Objekt entfernen

 !item [Adr_unselect]  Alle Auswahllisten-Objekte entfernen
!end_xlist

(!B)Achtung:(!b) Wenn man mit unmodalen Fensterdialogen arbeitet und dort die
Auswahl eines anderen Fensters ver„ndert, darf man sich natrlich
nicht mehr darauf verlassen, daž die Auswahl dabei unver„ndert bleibt.
Wenn beispielsweise mehrere Objekte eines Fensters ge„ndert werden
sollen und jede Abfrage per Awi_dialog erfolgt, wird bei der
Aktualisierung schon in der Schleife eventuelle Adr_del, Adr_add oder
Adr_unselect bearbeitet. Zur L”sung muž man sich vor den Dialogen ein
Feld von Objektnummern aufbauen und dieses verarbeiten.

Im folgenden Beispiel wird gezeigt, wie man dies z.B. in Pure-C
realisieren k”nnte:

!begin_sourcecode
INT16  *objects, actobnr, len;

/* ... */
if( !Aselect.actlen )
   return;

objects = Ax_malloc(Aselect.actlen*sizeof(*objects));
if( objects==NULL )
   return;

Adr_start();
len = 0;
while( (actobnr=Adr_next())>0 )
   objects[len++] = actobnr;

len = Aselect.actlen;
actobnr = 0;
while( actobnr<len )
{
   neuer_object_name(ev_window, objects[actobnr]);
   /* ... */
   actobnr++;
}
Ax_free(objects);
/* ... */
!end_sourcecode

!end_node


!begin_node Klemmbrett-Funktionen

Das Klemmbrett ist ein von ATARI 'angedachte' M”glichkeit, Daten
zwischen verschiedenen Programmen auszutauschen. Dafr befindet sich
(in der Regel) im Wurzelverzeichnis des Boot- Laufwerks ein Ordner
Namens 'CLIPBRD'. Existiert dieser Ordner nicht, wird von (!I)ACSpro(!i)
versucht, ihn anzulegen - er ist dann in scrp_path zu finden!

Darin befindliche Dateien, die als Reaktion auf die Menpunkte
'Ausschneiden', 'Kopieren' oder 'Einfgen' angelegt wurden, besitzen
verschiedene Klemmbrett-Typen.

Damit der (!I)ACSpro(!i)-Entwickler nun diesen Austausch aktiv untersttzen
kann, wurden neue Funktionen implementiert:

!begin_xlist [Ascrp_clear]
 !item [Ascrp_clear]  L”scht das Klemmbrett

 !item [Ascrp_put]    Schreibt Daten ins Klemmbrett

 !item [Ascrp_get]    Liežt Daten aus dem Klemmbrett
!end_xlist

Bisher vorgeschlagene Datei-Typen fr das Klemmbrett sind:

!begin_xlist [TXT]
 !item [TXT]  reine ASCII-Textdatei, Zeilentrenner CR/LF

 !item [GEM]  GEM-Metafile, siehe VDI-Dokumentation

 !item [IMG]  GEM-Image, das durch Abp_img2mfdb bedient oder durch
      Abp_mfdb2img erzeugt werden kann

 !item [ASC]  ASCII-Textdatei, deren Abs„tze durch CR/LF getrennt sind

 !item [CSV]  ACSII-Datei mit durch Kommata getrennten Zahlen

 !item [DIF]  Exportdatei aus Tabellenkalkulationen

 !item [1WP]  1stWordPlus-Dokument

 !item [RTF]  RichTextFormat
!end_xlist

!end_node


!begin_node NKCC-Funktionen

Die Routinensammlung rund um die NKCC-Tastencodes bietet weiterhin
einige ntzliche oder teilweise notwendige Routinen an:

!begin_xlist [nkc_n2kstate]
 !item [nkc_tos2n]     konvertiert aus dem TOS- ins NKCC-Format

 !item [nkc_n2tos]     konvertiert aus dem NKCC- ins TOS-Format

 !item [nkc_gem2n]     konvertiert aus dem GEM- ins NKCC-Format

 !item [nkc_n2gem]     konvertiert aus dem NKCC- ins GEM-Format

 !item [nkc_n2gemks]   konvertiert aus dem NKCC- ins GEM-Format (incl.
               Sondertastenstatus)

 !item [nkc_gemks2n]   konvertiert aus dem GEM- (incl. Sondertastenstatus) ins
               NKCC-Format

 !item [nkc_n2kstate]  ermittelt aus dem NKCC-Format den dazugeh”rigen
               Sondertastenstatus

 !item [nkc_kstate]    ermittelt schnell den Sondertastenstatus

 !item [nkc_cmp]       Tasten kompatibel vergleichen
!end_xlist

!end_node


!begin_node Datei-Funktionen

Fr das komfortable und h„ufig ben”tigte Arbeiten mit Dateinamen und
Pfaden gibt es nun Routinen, die einen gelieferten Pfadnamen nach
allen Regeln der Kunst auseinander nehmen oder aus Einzelteilen einen
kompletten Dateinamen zusammensetzen. Darber hinaus werden die
Zugriffe auf diverse Dateisysteme und Dateiauswahloxen
vereinheitlicht:

!begin_xlist [Af_parseCmdLine]
 !item [Af_cfgfile]     CFG-Pfad erzeugen

 !item [Af_2drv]        ermittelt Laufwerk aus einer absoluten Dateiangabe

 !item [Af_2path]       ermittelt Pfad aus einer absoluten Dateiangabe

 !item [Af_2name]       ermittelt Datenamen aus einer absoluten Dateiangabe

 !item [Af_2fullname]   ermittelt Namen und Typ aus einer absoluten
                Dateiangabe

 !item [Af_2ext]        ermittelt Typ aus einer absoluten Dateiangabe

 !item [Af_buildname]   Baut Daateinamen aus Einzelteilen auf

 !item [Af_length]      Ermittelt Existenz und L„nger einer Datei bzw. Ordners

 !item [Af_select]      Dateiauswahl

 !item [Af_first_fsel]  Beginn der MultiDateiAuswahl

 !item [Af_next_fsel]   N„chste Datei abholen

 !item [Af_first]       Dateien eines Ordners ermitteln

 !item [Af_next]        N„chste Datei abholen

 !item [Af_readdir]     Ordner komplett einlesen

 !item [Af_freedir]     Ordnerstruktur freigeben

 !item [Af_quote]       Einen Dateinamen ggf. quoten

 !item [Af_unquote]     Ggf. die Quote-Zeichen eines Dateinamen entfernen

 !item [Af_parseCmdLine] Die Parameter einer Kommandozeile in eine lineare
                Liste zerlegen
!end_xlist

!end_node


!begin_node Speicherverwaltung

Diese Routinen stellen eine Speicherverwaltung zur Verfgung, die zum
einen einen ACC-fest ist und darber hinaus bei der Freigabe
feststellt, ob dieser Speicherblock berhaupt angefordert wurde.

Aužerdem erfolgt die Speicherfreigabe verz”gert: Per Ax_free
freigegebene Bl”cke werden nicht sofort dem System wieder zugeteilt,
sondern gesammelt und vor dem Einsprung in die Eventschleife rckw„rts
wieder freigegeben. Einzig sehr grože Speicherbl”cke sollte per
Ax_ifree sofort freigegeben werden.

Um das Allozieren und Freigeben von Speicher zu optimieren, enth„lt
(!I)ACSpro(!i) eine Verwaltung von freien Speicherbl”cken.

!begin_xlist [Ax_getRecycleStat]
 !item [Ax_malloc]  Speicher anfordern

 !item [Ax_recycle] Speicher freigeben, aber ggf. puffern

 !item [Ax_free]    Speicher als frei kennzeichnen

 !item [Ax_ifree]   Speicher sofort freigeben

 !item [Ax_setRecycleSize] Die Verwaltung der freien Listen konfigurieren

 !item [Ax_getRecycleStat] Die aktuelle Statistik der freien Listen abrufen
!end_xlist

(!B)Wie funktioniert die Optimierung mittels "Listen freier Bl”cke"?(!b)
(!I)ACSpro(!i) fhrt intern fr bestimmte Gr”žen von Speicherbl”cken, die
innerhalb (!I)ACSpro(!i) bzw. in einer (!I)ACSpro(!i)-Anwendung ”fter auftreten, eine
Liste an freien Bl”cken. Diese Liste ist am Anfang natrlich leer.
Speicherbl”cke von einer dieser Gr”žen - wie etwa die typischen
Speicherbl”cke fr die Strukturen Awindow, AUSERBLK, TEDINFO,
ULinListe, Daten des File-Selectors oder des Print-Selectors - werden
hierbei beim Aufruf von Ax_recycle() nicht direkt freigegeben, sondern
in der entsprechenden Liste der "freien Bl”cke" gepuffert. Falls
danach ein Speicherblock von dieser Gr”že angefordert werden sollte,
so muž er nicht erneut alloziert werden, sondern wird aus dieser Liste
entnommen.

!begin_itemize
   !item Ax_recycle prft, ob der bergebene Block in eine dieser Listen
     einsortiert werden kann. Falls dies nicht der Fall sein sollte
     oder falls die ermittelte Liste bereits voll sein sollte, so wird
     der Block direkt per Ax_free freigegeben. Andernfalls wird der
     Block in die Liste eingeh„ngt.

   !item Die Funktion Ax_malloc prft dann als erstes, ob zu der
     gewnschten Blockgr”že eine Liste existiert. Wenn dies nicht so
     sein sollte oder die Liste leer lein sollte, so wird - wie bisher
     auch - neuer Speicher alloziert. Andernfalls wird der erste Block
     der ermittelten Liste aus der Liste entfernt und wieder
     zurckgegeben.

   !item Bei der initialisierung des (!I)ACSpro(!i) werden als erstes die Listen
     der "freien Bl”cke" initialisiert.

   !item Beim Beenden der Anwendung wird als Letztes aller Speicher, der
     in den Listen gepuffert wurde, freigegeben.

   !item Das Suchen nach einer Liste fr eine Speicherblock-Gr”že
     geschieht optimiert per bin„rer Suche. Zum Beispiel sind daher
     fr die momentan insgesamt 21 Blockgr”žen, die (!I)ACSpro(!i) bereits
     kennt, maximal 4 Vergleiche notwendig, bis die Liste entdeckt
     wurde oder feststeht, daž es keine Liste zu dieser Gr”že gibt.

   !item Da die Listen selbst mittels der "freigegebenen" Bl”cke aufgebaut
     werden, wird fr jede Liste kein weiterer Speicher ben”tigt.
     Allein die Freigabe des Speichers wird u.U. bis zur Terminierung
     der Anwendung hinausgez”gert.

   !item Mittels der Funktion Ax_setRecycleSize k”nnen die Werte ver„ndert
     werden, neue Blockgr”žen in die Liste aufgenommen oder vorhandene
     Blockgr”žen entfernt werden. Die Funktion Ax_getRecycleStat
     liefert die aktuellen Informationen ber die Listen der freien
     Bl”cke.

   !item (!I)ACSpro(!i) fhrt bereits Listen fr die wichtigsten Strukturen, die
     in (!I)ACSpro(!i)-Anwendungen immer wieder ben”tigt werden drften, wie
     etwa Awindow, TEDINFO, AUSERBLK, BITBLK, MFDB, A_dd, MEMX (intern
     in Speicherverwaltung verwendet).

   !item (!I)ACSpro(!i) kennt momentan 21 Blockg”žen, die in Listen freier Bl”cke
     verwaltet werden. Die interne Verwaltung der Listen ben”tigt pro
     Liste momentan nur 22 Byte.
!end_itemize

(!B)Beispiel:(!b) Die Funktion Awi_delete ruft intern die FUnktion Ax_recycle
folgendermažen auf: Ax_recycle(wind, sizeof(*wind)).

(!B)Tip:(!b) Wenn am Ende der (!I)ACSpro(!i)-Anwendung die Statistik per
Ax_getRecycleStat ermittelt und in eine Datei geschrieben wird, so
l„žt sich die Verwaltung der freien Bl”cke auf jede Anwendung und den
entsprechenden Einsatz-Zweck weiter optimieren.

!end_node


!begin_node System-Funktionen

Globale Routinen, die andere Applikationen, Module oder
Systemeinstellungen betreffen, sind hier zu finden:

!begin_xlist [Ash_thermometer]
 !item [Ash_CallEdDI]   Aufruf einer EdDI-Funktion

 !item [Ash_error]      Fehlerausgabe

 !item [Ash_fileselect] Eine Datei ber die (MagiC-)Dateiauswahlbox ausw„hlen
                lassen

 !item [Ash_font]       Einen Zeichensatz ber den (MagiC-)Font-Selector
                ausw„hlen lassen

 !item [Ash_getcookie]  Ermittelt den Wert von einem (!link [Cookie] [Cookie Jar])

 !item [Ash_getenv]     Sucht Variable in den Environment-Strings

 !item [Ash_gettimer]   Wert des 200Hz-Timers liefern

 !item [Ash_module]     Module nachladen

 !item [Ash_nextdd]     Externe D&D-Partner suchen

 !item [Ash_NVDICookie] Zeiger auf (!link [Cookie] [Cookie Jar])-Struktur von NVDI liefern

 !item [Ash_NVDIDatum]  NVDI-Datum ermitteln

 !item [Ash_NVDIVersion] NVDI-Versionsnummer ermitteln

 !item [Ash_print]      Die WDIALOG-Druck-Dialoge aufrufen

 !item [Ash_prog]       Programm starten

 !item [Ash_sendall]    Mitteilung verschicken

 !item [Ash_thermometer] Ein sog. Thermometer w„hrend einer l„ngeren Aktion
                anzeigen
!end_xlist

!end_node


!begin_node Unsortierte, doppelt verkettete, lineare Liste

Mit Hilfe der linearen Liste k”nnen Daten beliebigen Typs verwaltet
werden. Die Liste ist als unsortierte, doppelt verkettete, lineare
Liste implementiert, die die Daten als typenlosen Zeiger enth„lt.

Zur Verfgung stehen "nur" die beiden Funktionen

!begin_xlist [Alu_create]
 !item [Alu_create]  fr das Erzeugen einer Liste und

 !item [Alu_delete]  fr das L”schen einer Liste,
!end_xlist

da alle anderen Funktionen und Manipulationsm”glichkeiten ber
Funktionszeiger des verwendeten Datentyps ULinList realisiert sind.

!end_node


!begin_node Die Warteschlange (Queue)

Mit Hilfe der Warteschlange (Queue) k”nnen Daten beliebigen Typs
verwaltet werden. Die Queue ist als lineare Liste implementiert, die
die Daten als typenlosen Zeiger enth„lt.

Zur Verfgung stehen "nur" die beiden Funktionen

!begin_xlist [Aqu_create]
 !item [Aqu_create]  fr das Erzeugen einer Queue und

 !item [Aqu_delete]  fr das L”schen einer Queue,
!end_xlist

da alle anderen Funktionen und Manipulationsm”glichkeiten ber
Funktionszeiger des verwendeten Datentyps Queue realisiert sind.

!end_node


!begin_node Die Konfigurations-Strings

Die Konfigurationsstrings - von mir auch Config-Strings oder Cfg-
Strings genannt - bieten eine Konfigurationsm”glichkeit ber ASCII-
Dateien. Diese Dateien sind „hnlich den aus der Windows-Welt bekannten
INI-Dateien aufgebaut. Eine solche Konfigurationsdatei wird in
verschiedene sog. (!I)Parameter-Gruppen(!i) unterteilt. Diese Gruppen werden
ber ihren Namen angesprochen, die erste Gruppe ist die Default-Gruppe
ohne einen Gruppenamen. Der Name steht am Anfang der Gruppe in eckigen
Klammern . Jeder Parameter wird durch seinen Namen angegeben, dem per
Gleichheitszeichen ein Wert zugewiesen wird. Dieses Verfahren drfte
von dem Environment und den Environment-Strings bekannt sein. Die
Namen der Parameter und der Gruppen drfen Leerzeichen enthalten,
einzig die Zeichen '[' und ']' sind fr Gruppennamen, das Zeichen '='
fr Parameternamen nicht erlaubt. In der Datei drfen Kommentare
enthalten sein. Hierzu k”nnen Kommentarzeichen definiert werden. Wird
ein Kommentarzeichen am (!I)Anfang(!i) einer Zeile (aužer fhrenden
Leerzeichen) gefunden, wird diese Zeile ignoriert.

(!B)Hinweis:(!b) Gruppen-Namen, die mit "ACS-" beginnen, sollten fr (!I)ACSpro(!i)
und die diversen Module reserviert sein. Es ist geplant, (!I)ACSpro(!i) und
alle Module auf diese Cfg-Strings umzustellen.

(!I)Beispiel:(!i)

!begin_sourcecode
% Die Kommentar-Zeichen in diesem Beispiel sind '%' und ';',
; so daž diese fnf Zeilen komplett ignoriert werden. Sie bilden
% die sog. Header-Kommentar-Zeilen. Trotzdem werden die Zeilen
; beim Laden und Speichern korrekt bercksichtigt und
% bleiben - so wie sie sind - erhalten!
ProgTitel=Demo-Programm
AnzahlHistory=2

[HistoryInfos 1]
HistDateiname=C:\Pfad\Datei.TXT
HistWindowX=50
HistWindowY=50
HistWindowW=200
HistWindowH=200
HistWindowOpen=TRUE

[HistoryInfos 2]
HistDateiname=C:\Pfad\Datei.TXT
HistWindowX=10
HistWindowY=20
HistWindowW=400
HistWindowH=400
HistWindOpen=FALSE
!end_sourcecode

Folgende Funktionen stehen fr die Handhabung der Cfg-Strings zur
Verfgung

!begin_xlist [Acfg_clearHeader]
 !item [Acfg_create]      Erzeugen der internen Struktur zur Verwaltung der
                  Cfg-Strings

 !item [Acfg_delete]      L”schen und Freigeben der mittels Acfg_create
                  angelegten Struktur

 !item [Acfg_clear]       L”schen der Cfg-Strings und der Verwaltungs-
                  Informationen

 !item [Acfg_clearGroup]  Nur die angelegten Gruppen mit den Strings l”schen

 !item [Acfg_load]        Eine Cfg-Datei laden

 !item [Acfg_save]        Die Cfg-Strings speichern

 !item [Acfg_isChanged]   Prfen, ob Strings ver„ndert wurden

 !item [Acfg_getValue]    Werte von Parametern abfragen - ggf. auch im
                  Environment

 !item [Acfg_setValue]    Werte von Parameter setzen

 !item [Acfg_clearValue]  Parameter aus den Strings l”schen

 !item [Acfg_clearHeader] Kommentar-Header-Zeilen der Cfg-Datei l”schen

 !item [Acfg_setHeader]   Kommentar-Header-Zeilen fr die Cfg-Datei setzen

 !item [Acfg_getHeader]   Kommentar-Header-Zeilen fr die Cfg-Datei ermittelt

 !item [Acfg_headAnzahl]  Anzahl der (!I)gesetzten(!i) - nicht der tats„chlich
                  vorhandenen - Kommentar-Header-Zeilen der Cfg-Datei

 !item [Acfg_grpAnzahl]   Anzahl der vorhandenen Gruppen bestimmen

 !item [Acfg_grpName]     Name einer Gruppe bestimmen

 !item [Acfg_strAnzahl]   Anzahl der Cfg-Strings einer Gruppe bestimmen

 !item [Acfg_strName]     Namen eines Parameters einer Gruppe bestimmen

 !item [Acfg_isCfgfile]   Prfen, ob die Cfg-Strings einem Dateinamen
                  zugeordnet sind

 !item [Acfg_createInfo]  Info-Struktur fr die Cfg-Strings erzeugen

 !item [Acfg_deleteInfo]  Info-Struktur freigeben

 !item [Acfg_setInfo]     Info-Struktur an Cfg-Struktur bergeben

 !item [Acfg_getInfo]     Info-Struktur einer Cfg-Struktur erfragen

 !item [Acfg_copyInfo]    eine Info-Struktur kopieren
!end_xlist

!end_node


!begin_node Event-Support

Fr die Untersttzung von Events sind nur relativ wenige Funktionen
vorgesehen, da aufgrund des Konzepts von (!I)ACSpro(!i) ein Grožteil der
ben”tigten Funktionen bereits anderweitig abgedeckt ist, wie etwa
durch die Fenster-Funktionen.

Zur Verfgung stehen

!begin_xlist [Aev_unhidepointer]
 !item [Aev_quit]           Applikation beenden

 !item [Aev_mess]           GEM-Nachrichten bearbeiten

 !item [Aev_unhidepointer]  Mauszeiger wieder sichtbar machen

 !item [Aev_release]        Wartet bis Maustasten losgelassen
!end_xlist

Ferner existieren noch einige Funktionen zur (!link [externen Kommunikation] [Externe Kommunikation]).

!end_node


!begin_node Externe Kommunikation
!alias Protokoll

(!I)ACSpro(!i) kann nun recht komfortabel Nachrichten der wichtigsten
Protokolle versenden. Der Empfang der Nachrichten geschieht vollkommen
automatisch und transparent. Die implementierten Protokolle sind:

!begin_xlist [PureC-Hilfe-Protokoll]
 !item [PureC-Hilfe-Protokoll]  Protokoll zur Ansteuerung der Pure-C-Hilfe und
                        des ST-Guide

 !item [ST-Guide-Protokoll]     "Protokoll" zur Ansteuerung des ST-Guide

 !item [BubbleGEM-Protokoll]    Das Protokoll zur Ansteuerung von BubbleGEM,
                        der "Blasen-Hilfe"

 !item [GEMScript-Protokoll]    Das Protokoll zum Fernsteuern von Anwendungen
                        und erweiterten Kommunikationsm”glichkeiten

 !item [OLGA-Protokoll]         Protokoll zur Inter-Programm-Kommunikation, um
                        Dateien durch andere Programme bearbeiten zu
                        lassen

 !item [DHST-Protokoll]         Protokoll, um gespeicherte Dateien bei einem
                        Document-History-Server abzulegen. Dieser
                        fhrt system-global ber verwendete Dateien
                        Buch und kann diese auch wieder laden lassen.
!end_xlist

Genauere Informationen ber diese Protokolle liegen (!I)ACSpro(!i) bei oder
k”nnen ber Links von der (!I)ACSpro(!i)-Homepage unter
http://acspro.atari.org/ geladen werden.


!begin_node PureC-Hilfe-Protokoll

Die Funktionen, die sich um das PureC-Hilfe-(!link [Protokoll] [Protokoll]) (So weit ich
weiž, sind dies bislang nur PC_HELP und ST-Guide) kmmern, sind

!begin_xlist [Aev_PCHelpVersion]
 !item [Aev_AcHelp]         Hilfe-Seite anzeigen lassen

 !item [Aev_AcVersion]      Versionsnummer ermitteln lassen

 !item [Aev_AcCopy]         Hilfe-Seite ins Klemmbrett kopieren lassen

 !item [Aev_PCHelpVersion]  Letzte gemeldete Versionsnummer erfragen
!end_xlist

!end_node


!begin_node ST-Guide-Protokoll

Die Funktion Aev_STGuideHelp stellt fr (!I)ACSpro(!i)-Anwendungen das
Interface fr die Online-Hilfe dar. Der Aufruf der Hilfe-Seite
geschieht v”llig automatisch durch die Funktionen Awi_keys,
Awi_keysend, Awi_sendkey bzw. Awi_nokey beim Druck auf die HELP-Taste.
Die Funktion Aev_STGuideHelp drfte also nur ben”tigt werden, wenn
eine eigene Routine in Awindow.keys eingetragen wurde.

Das Hilfe-Thema selbst wird aus Awindow.help entnommen und vor Versand
an den ST-Guide per AS_ASK_STGUIDE dem Fenster bekannt gegeben. Dieses
kann das Thema frei „nderen (wie z.B. das Editor-Fenster es tut) oder
sogar die Anzeige der Hilfe unterbinden. Damit erh„lt der
Programmierer die M”glichkeit, jederzeit die Kontrolle ber die
angezeigte Hilfe-Seite zu bernehmen oder den durch (!I)ACSpro(!i)
bereitgestellten Automatismus zu nutzen.

!end_node


!begin_node BubbleGEM-Protokoll

Das BubbleGEM-(!link [Protokoll] [Protokoll]) ist v”llig transparent in (!I)ACSpro(!i) integriert.
Wenn eine BubbleGEM-Hilfe angefordert wird (z.B. durch eine Nachricht
des BubbleGEM-D„mons), so wird ber die Funktion Awi_bubblegem die
Hilfe automatisch aufgerufen.

Wie eigentlich berall in (!I)ACSpro(!i) blich, kann dieser Automatismus
kontrolliert werden. (!I)ACSpro(!i) geht bei Anforderung einer BubbleGEM-Hilfe
folgendermažen vor:

!begin_enumerate
  !item Das Fenster wird zuerst per AS_ALLOWBUBBLE um Erlaubnis gefragt.
     Wenn das Fenster die Nachricht (Rckgabewert TRUE) versteht und
     ein "Verbot" liefert, wird keine BubbleGEM-Hilfe angezeigt, d.h.
     jedes Fenster kann durch Awindow.service BubbleGEM komplett
     ausschalten.

  !item Wenn das Fenster eine BubbleGEM-Hilfe zul„žt (Das ist die
     Default-Einstellung), so wird das Objekt an den Maus-Koordinaten
     bestimmt.

  !item Wenn es sich hier um ein UserDef handelt, so wird dem UserDef die
     Nachricht (!link [AUO_GETBUBBLE] [AUO_GETBUBBLE]) gesandt. Das UserDef hat nun die
     M”glichkeit, den vordefinierten Hilfe-String zu „ndern oder die
     BubbleGEM-Hilfe auszuschalten.

  !item Falls es sich nicht um ein UserDef, sondern um ein Standard-GEM-
     Objekt handelt oder falls das UserDef die Nachricht nicht
     versteht (Rckgabewert der Service-Routine ist FALSE), wird dem
     Fenster die Nachricht AS_GETBUBBLE gesandt, damit dieses einen
     Hilfetext zur Verfgung stellt.

  !item Wenn nun ein Hilfetext zur Verfgung steht, so wird dieser an
     BubbleGEM gesandt. Falls hier ein leerer String (siehe
     Ast_isEmpty) als Hilfetext eingetragen worden sein sollte, wird
     keine BubbleGEM-Hilfe aufgerufen.
!end_enumerate

Die gesamte Kommunikation mit BubbleGEM wird von (!I)ACSpro(!i) komplett
selbst bernommen. Ebenso werden Tastendruck- und Mausklick-Meldungen,
die von BubbleGEM gemeldet werden, wie gewohnt an die richtigen
Empf„nger verteilt. Der (!I)ACSpro(!i)-Entwickler kann also die BubbleGEM-
Kommunikation komplett beeinflussen, hat mit ihr aber berhaupt keine
Arbeit.

!end_node


!begin_node GEMScript-Protokoll

Das GEMScript-(!link [Protokoll] [Protokoll]) ist passiv in erster Stufe in (!I)ACSpro(!i)
implementiert. Im Moment ist (!I)ACSpro(!i) der passive GEMScript-Partner, der
auf eingehende GEMScript-Nachrichten reagiert. Es fehlen noch die
Macroaufnahme und der aktive Verbindungsaufbau. Beide Erweiterungen
von (!I)ACSpro(!i) stehen noch aus und werden in einer der n„chsten Versionen
realisiert sein.

Der Nachrichtenaustausch mittels GEMScript zwischen zwei Anwendungen
wird in drei Phasen unterteilt, der Kontaktaufnahme, der Kommandophase
und dem Abmelden.

Die Kontaktaufnahme erledigt (!I)ACSpro(!i) v”llig selbst„ndig. Als
GEMScript-Version wird die Version 1.2 gemeldet, die hexadezimale
Codierung von Parametern wird natrlich untersttzt - fr den (!I)ACSpro(!i)-
Entwickler v”llig unbemerkt.

Das Abmelden wird von (!I)ACSpro(!i) ebenfalls selbstt„tig beim Beenden
erledigt, sofern der GEMScript-Partner die Verbindung nicht beendet.

In der Kommandophase werden die Kommandos an GEMScript-Funktionen
weitergegeben. Diese k”nnen vom Entwickler ersetzt oder erweitert
werden, wie unter dem Vorgehen von (!I)ACSpro(!i) beim
(!link [Eintreffen eines GEMScript-Kommandos] [GEMScript-Realisierung in ACS]) beschrieben ist.

!end_node


!begin_node GEMScript-Realisierung in ACS

Beim Eintreffen von GEMScript-Kommandos geht (!I)ACSpro(!i) folgendermažen
vor:

!begin_enumerate
  !item Die im ASCIIZZ-Format gesendeten Parameter werden ausgelesen und
     in ein Array von Strings umgewandelt. Die hexadezimal codierten
     Parameter werden umgewandelt.

  !item Die Daten werden der in ACSblk eingetragenen GEMScript-Funktion
     bergeben. Die Default-Funktion ist ACSGEMScript.

  !item Wenn das GEMScript-Kommando von dieser Funktion nicht erfolgreich
     bearbeitet wird, d.h. wenn der Rckgabewert ungleich GSACK_OK
     ist, so wird versucht, dem im zweiten Parameter angegebenen
     Fenster das Kommando zuzuleiten. Falls der zweite Parameter leer
     ist, wird das oberste Fenster verwendet. Falls kein Fenster
     angegeben ist oder das angegebene Fenster nicht identifiziert
     werden kann, wird das Kommando an das Root-Fenster
     weitergeleitet.

  !item Die in Awindow.gemscript eingetragene GEMScript-Funktion des
     ermittelten Fensters wird aufgerufen. Die Default-Funktion ist
     Awi_gemscript.
!end_enumerate

Der von den GEMScript-Funktionen zurckgegebene Fehlercode wird an den
Absender des GEMScript-Kommandos weiter gegeben. Rckgabewerte sollten
- wie in der GEMScript-Dokumentation beschrieben ist - stets ber
einen ASCIIZZ-String gesandt werden. (!I)ACSpro(!i) hilft auch hier. Die
GEMScript-Funktionen bekommen einen Zeiger auf die Struktur
A_GSAntwort bergeben. In der Beschreibung dieser Struktur ist auch
dokumentiert, wann und wie die Rckmeldungen durch die GEMScript-
Funktionen eingetragen werden sollten.

!end_node


!begin_node OLGA-Protokoll

Das Empfangsteil des OLGA-Protokolles wird von (!I)ACSpro(!i) automatisch
erledigt und ggf. an das betroffene Fenster (!link [weitergeleitet] [Vordefinierte Fenster-Nachrichten]). Das
Sendeteil des OLGA-Protokolles liegt in der Verantwortung des
Programmierers. Um ihn zu untersttzen, stehen einige Funktionen zur
Verfgung, die in drei Kategorien unterteilt werden k”nnen.

In der aktuellen (!I)ACSpro(!i)-Version ist der Empfangsteil bis auf das
Inplace-Drawing bereits implementiert. Der Sendeteil ist noch in
Arbeit und wird in einer der n„chsten Versionen hinzukommen.

!begin_xlist [OLGA-Allgemein]
!label OLGA-Server
 !item [OLGA]-Server     Die hier genannten Funktionen untersttzen den
                 Programmierer beim Entwickeln einer (!I)ACSpro(!i)-Anwendung,
                 die als OLGA-Server eingesetzt werden soll bzw. kann.

                  !begin_xlist [Aev_OlgaBreaklink]
                  !item [Aev_OlgaIdle]       Test der OLGA-Verbindung, ob alle
                                     vorherigen Nachrichten
                                     verarbeitet wurden (als OLGA-
                                     Server und als OLGA-CLient)

                  !item [Aev_OlgaBreaklink]  L”schen einer Datei an den OLGA-
                                     Manager melden (als OLGA-Server)

                  !item [Aev_OlgaRename]     Umbenennen einer Datei an den
                                     OLGA-Manager melden (als OLGA-
                                     Server)

                  !item [Aev_OlgaUpdate]     Update einer Datei an den OLGA-
                                     Manager melden (als OLGA-Server)
                  !end_xlist

!label OLGA-Client
 !item [OLGA]-Client     Die aufgelisteten Funktionen stehen dem (!I)ACSpro(!i)-
                 Entwickler zur Verfgung, um eine OLGA-Client-
                 Anwendung zu programmieren.

!label OLGA-Allgemein
 !item [OLGA]-Allgemein  Die folgenden Funktionen sind fr (!I)ACSpro(!i)-Anwendungen,
                 die als OLGA-Server, als OLGA-Client oder beides
                 verwendet werden k”nnen, gedacht. Ferner sind hier
                 Funktionen aufgelistet, die die OLGA-Verbindungen
                 verwalten.

                  !begin_xlist [A_OlgaCreate]
                  !item [A_OlgaCreate]  Erzeugen einer registrierten OLGA-
                                Verbindung, die Verbindung wird noch
                                nicht beim OLGA-manager registriert!
                  !end_xlist
!end_xlist

!end_node


!begin_node DHST-Protokoll

(!I)ACSpro(!i) untersttzt das DHST-(!link [Protokoll] [Protokoll]). Das (!xlink [] [Document-History-Protokoll])
(DHST-(!link [Protokoll] [Protokoll])) dient dazu, eine globale Liste der zuletzt benutzten
Dokumente zu verwalten („hnlich dem Abruf-Men in z.B. Texel) und an
einer einheitlichen Stelle (z.B. Start-Me-Up-Men) schnell abrufbar zu
machen. Bei diesem DHST-Server (wie z.B. SMU) werden alle
gespeicherten Dateien registriert. Der DHST-Server zeigt diese nun an
und bieten an, eine der gelisteten Dateien wieder zu bearbeiten.

(!I)ACSpro(!i) untersttzt das dazu notwendige (!link [Protokoll] [Protokoll]) v”llig transparent.
Die Funktion Aev_DhstAdd l”st das Registrieren der Datei aus, die dazu
notwendige Kommunikation wird komplett von (!I)ACSpro(!i) erledigt, so daž
keine weitere Arbeit entsteht.

Genauere Informationen ber das (!xlink [DHST-Protokoll] [Document-History-Protokoll]) sind in der
Dokumentation von (!xlink [SMU] [Start Me Up! ]) zu finden.

(!B)Hinweis:(!b) Generell ist empfehlenswert, sowohl dem (!link [OLGA-Server] [OLGA-Server]) als auch
dem DHST-Server nach dem Speichern eines Dokumentes mittels der
Funktionen Aev_OlgaUpdate bzw. Aev_DhstAdd Bescheid zu sagen.

!end_node

!end_node


!begin_node Sonstige Funktionen

Zu guter Letzt gibt es einige Routinen, die keiner speziellen Rubrik
zuzuordnen sind und hier aufgelistet werden. Es handelt sich hier um
die Funktionen

!begin_xlist [dotted_xline]
 !item [A_dialog]      Dialog durchfhren

 !item [A_dialog2]     Dialog durchfhren

 !item [alert_str]     Alarmbox aufbauen und anzeigen

 !item [intersect]     Bildet den Schnitt zweier Rechtecke

 !item [xywh2array]    Umrechnen eines Rechtecks

 !item [array2xywh]    Umrechnen eines Rechtecks

 !item [dotted_xline]  Punktierte, horizontale Linie

 !item [dotted_yline]  Punktierte, vertikale Linie

 !item [Avdi_getRGB]   RGB-Farbwerte der NVDI-Farbpalette ermitteln
!end_xlist

!end_node

!end_node


!begin_node Die Erweiterungen der Objekte durch GEM-Userdefs

(!I)ACSpro(!i) erweitert die bestehenden GEM-Objekte durch eigene Userdefs
erheblich. Da im Gegensatz zu "traditionellen" GEM-Userdefs die von
(!I)ACSpro(!i) bereitgestellten Objekte nicht nur ein Aussehen, sondern durch
die Konzepte der Klick-, Drag- und Service-Funktionen auch eine zum
Teil sehr m„chtige Funktionalit„t haben, lassen sich ansprechende
gestaltete GEM- Anwendung mit komfortablen M”glichkeiten in recht
kurzer Zeit entwickeln.

Die von (!I)ACSpro(!i) bereitgestellten Userdefs sind

!subtoc [all] !depth 1


!begin_node Userdef-BoxEdit
!alias BoxEdit

Dieses Objekt wird ab ACSpro V2.3 dazu benutzt, in Fensterdialogen ein
komfortables Eingabeobjekt anzubieten, das gegenber den
ursprnglichen TEDINFO-Objekten eine umfangreiche Cursorsteuerung,
eine Blockselektion und bis zu 255 Zeichen in der Eingabe zul„žt. Der
Rahmen wird erst mit OUTLINED-Flag gezeichnet und nur im 3D-Modus,
wenn mehr als 16 Farben darstellbar sind. Ist das SELECTED-Bit gesetzt
wird das Objekt nicht invertiert, er erscheint vielmehr ein innerer
Rahmen.

(!B)Achtung:(!b) Die ACSpro-Library verlangt diesen Objekttyp (!B)zwingend(!b), um in
Fensterdialogen eine korrekte Cursorsteuerung auszufhren.

Zur Laufzeit kann dieses Objekt mit der Service-Routine Auo_boxed
angesprochen werden. Die dafr vorbereitete (!link [Click-Routine] [Click-Routine]) Aus_boxed
steuert die Textselektion Sie mssen diese Click- Routine nicht
zwingend angeben, da (!I)ACSpro(!i) bei einem EDITABLE-Objekt diese
automatisch anspringt. Dafr (!B)darf(!b) das Objekt leider nicht in modalen
Dialogen (A_dialog) eingesetzt werden!

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_boxed

 !item [ub_parm]  Bitvektor, der das Aussehen festlegt. Hierbei bedeutet

           !begin_xlist [Bit 28-31]
           !item [Bit 0-2]    ...

           !item [Bit 3]      unsichtbare Zeichen

           !item [Bit 4]      3D-Modus

           !item [Bit 6]      kleine Schrift

           !item [Bit 7]      Kapitalisieren

           !item [Bit 8-11]   Textfarbe

           !item [Bit 11-18]  maximale Textl„nge

           !item [Bit 19-23]  Maskenindex

           !item [Bit 24-27]  Rahmenfarbe unten/rechts

           !item [Bit 28-31]  Rahmenfarbe oben/links
           !end_xlist

 !item [ub_serv]  Auo_boxed

 !item [ub_ptr1]  aktueller Text oder Selektion

 !item [ub_ptr2]  NULL (interne Daten)

 !item [ub_ptr3]  NULL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_boxed/Aus_boxed/Auo_boxed

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Slider
!alias Slider

Zusammen mit der click-Routine Aus_slider und den Nachrichten
entfaltet dieses Userdef seine volle Funktionalit„t. Es bietet einen
Liveupdate, dies heižt der aktuelle Sliderwert kann sofort
entsprechend angezeigt werden. In den Balken kann ein Text eingetragen
werden. Standardm„žig wird der Zahlenwert eingetragen.

Die Version (!link [A_wislider] [A_wislider]) simuliert mit Hilfe der AES-Fensterslider einen
A_slider. Dabei bleibt das Liveupdate durch den Balken und der
Texteintrag auf der Strecke. (!link [A_wislider] [A_wislider]) hat als Userdef natrlich
keine visuelle Komponente.

Zur Laufzeit kann dieses Objekt mit der Service-Routine Auo_boxed
angesprochen werden. Die dafr vorbereitete (!link [Click-Routine] [Click-Routine]) Aus_boxed
steuert die Textselektion Sie mssen diese Click- Routine nicht
zwingend angeben, da (!I)ACSpro(!i) bei einem EDITABLE-Objekt diese
automatisch anspringt. Dafr (!B)darf(!b) das Objekt leider nicht in modalen
Dialogen (A_dialog) eingesetzt werden!

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_slider bzw. (!link [A_wislider] [A_wislider])

 !item [ub_parm]  Ausrichtung des Sliders horizontal (0) oder vertikal (1)

 !item [ub_serv]  Auo_slider bzw. (!link [Auo_wislider] [Auo_wislider])

 !item [ub_ptr1]  NULL (interne Daten)

 !item [ub_ptr2]  NULL

 !item [ub_ptr3]  NULL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_slider/Aus_slider/Auo_slider

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Editor

Dieses Userdef kann als Editor, Selektor oder als (!link [Protokoll] [Protokoll]) betrieben
werden. Die volle Leistungsf„higheit erreicht dieses Userdef durch den
umfangreichen Satz an Nachrichten, die click-Routine Aus_editor. Das
Userdef arbeitet optional mit einem horizontalen (!link [Slider] [Slider]) und vertikalen
(!link [Slider] [Slider]) zusammen.

Zu diesem Userdef existiert noch ein 'printf'-Interface ber die
Funktionen uputs, uprintf und uvprintf.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_editor

 !item [ub_parm]  0

 !item [ub_serv]  Auo_editor

 !item [ub_ptr1]  NULL (interne Daten)

 !item [ub_ptr2]  NULL

 !item [ub_ptr3]  NULL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_editor/Aus_editor/Auo_editor

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Picture
!alias Picture

Im Gegensatz zum Typ G_IMAGE sind mehrere Planes m”glich. Das Bild
wird auf die Objektgr”že begrenzt. Beim Initialisieren wird ein MFDB
im aktuelle Format erzeugt. Weitere Aufrufe (aužer im Testmode)
benutzen diesen MFDB. Ab Version 2.2 kann man dem Hintergrund eine
eigene Farbe und ein Muster zuordnen, weiterhin wird auch ein 3D-Modus
(in Abh„ngigkeit von AB_NO3D) beachtet.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_picture

 !item [ub_parm]  Bitvektor:

           !begin_xlist [Bit 16-19]
           !item [Bit 0]      Normal-Modus (0) oder Testmode (1) (erzeuge
                      immer einen MFDB - ist fr den (!I)GUI-Editor(!i)
                      gedacht)

           !item [Bit 1]      zentriert (0) oder Kachel (1)

           !item [Bit 4-7]    Kachel-Hintergrundfarbe

           !item [Bit 8-12]   Kachel-vsf_style-Mode

           !item [Bit 16-19]  Kachel-vsf_interior-FLag

           !item [Bit 20]     Kachel-Dither-Flag
           !end_xlist

 !item [ub_serv]  Auo_picture

 !item [ub_ptr1]  Zeiger auf die ursprnglichen Bild-Daten

 !item [ub_ptr2]  NULL (zeigt auf interne Struktur)

 !item [ub_ptr3]  NULL (aktueller MFDB)
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_picture/Auo_picture

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Cycle
!alias Cycle

Links wird die (letzte) Wahl und rechts ein Pfeil nach unten zum
Durchschreiten gezeichnet. Die volle Funktionalit„t wird erst durch
Anklicken mit der Maus erreicht. Die click-Routine zu diesem Userdef
ist Aus_cycle.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_cycle

 !item [ub_parm]  0

 !item [ub_serv]  Auo_cycle

 !item [ub_ptr1]  NULL/NIL oder ein C-String (der ursprngliche Popupstring)

          Die verschiedenen Eintr„ge werden durch Bar '|' getrennt,
          z.B.

          !begin_sourcecode
"Rot|Gelb|Grn".
          !end_sourcecode

          Submens werden durch eckige Klammer beschrieben. Der erste
          Wert ist der Titel, z.B.

          !begin_sourcecode
"Rot|[Gelb|Fast Rot|normales Gelb|Grngelb]"
"|[Grn|Aufpassen!|normale Fahrt|Vollgas]".
          !end_sourcecode


!image (!IMAGES)img00734.img

          Der aktuelle Wert wird mit CHECKED gekennzeichnet.

 !item [ub_ptr2]  NULL (interne Daten)

 !item [ub_ptr3]  NULL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_cycle/Aus_cycle/Auo_cycle

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-3D-Button

!subtoc [all] !depth 1

Dieser Button hat einen linken oberen und einen rechten unteren
Rahmen. Werden hier verschiedene Farben eingestellt, wird ein 3D-
Effekt erreicht. Beim Selektieren werden die Rahmenfarben vertauscht
um den Effekt des Hineindrckens zu erreichen. Sind beide Rahmenfarben
gleich, wird beim Selektieren der innerer Bereich invertiert.

Der Buttontext untersttzt die String Codes.

Die Rahmendicke kann unabh„ngig vom Rahmenversatz eingestellt werden.
Zum Beispiel kann der Rahmen 2 Pixel dick gemacht werden und um 1
Pixel nach innen gesetzt werden, so daž insgesamt das Objekt 1 Pixel
gr”žer wird.

(!B)Wichtig:(!b) AES fordert bei Teilredraws nur die im Redrawrechteck liegen.
Mittels des Flags OUTLINED kann das Objekt in allen Richtungen visuell
um 3 Pixel gr”žer sein als logisch konzipiert, ohne Redrawproblem zu
verursachen.

Dieses Userdef untersttzt einen Dither genannten Mode. Ziel ist einen
Modus zu haben, der in allen Aufl”sung gleichermassen gut wirkt. Dabei
stellt der Benutzer das Muster VOLL (7) und die Farbe HELLGRAU (8)
ein. Diese Kombination kann erst ab 16 Farben umgesetzt werden.

Im 4 Farb Modus wird stattdessen automatisch die Farbe 2 (GRšN)
eingestellt. Wobei in dieser Aufl”sung die Farbe 2 per Controlfeld in
ein HELLGRAU verwandelt sollte um einen guten Eindruck zu haben

In monochrom wird das Muster 4 (50%) verwendet. Visuell wirkt dies wie
HELLGRAU. Zus„tzlich wird der REPLACE-Modus bei Texten erzwungen, da
Fonts im Transparentmodus auf dem Muster 4 nicht so gut lesbar sind.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_3Dbutton

 !item [ub_parm]

           !begin_xlist [Bit 28-29]
           !item [Bit 0-3]    Fllfarbe

           !item [Bit 4-6]    Fllmuster

           !item [Bit 7]      REPLACE-Modus bei Texten ein/aus

           !item [Bit 8-11]   Textfarbe

           !item [Bit 12-15]  Farbe des oberen Rahmens

           !item [Bit 16-19]  Rahmendicke (0 ... 15)

           !item [Bit 20-23]  Rahmenoffset (-8 ... +7)

           !item [Bit 24-27]  Farbe des unteren Rahmens

           !item [Bit 28-29]  Textausrichtung: 0=links, 1=rechts, 2=zentriert
                      (3=Blocksatz)

           !item [Bit 30]     kleine Schrift

           !item [Bit 31]     keine Fllung
           !end_xlist

 !item [ub_serv]  Auo_string

 !item [ub_ptr1]  NULL/NIL oder ein C-String

 !item [ub_ptr2]  NULL/NIL (window)

 !item [ub_ptr3]  NULL/NIL (obnr)
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_3Dbutton/Auo_string

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate


!begin_node String Codes

Das erste Zeichen, das mit dem im (!I)GUI-Editor(!i) eingetragenen Tastencode
bereinstimmt, unabh„ngig von der Grož-bzw. Kleinschreibung, wird
entsprechend der folgenden Regel mit einem VDI-Texteffekt
hervorgehoben:

!begin_xlist [SHIFT]
 !item [ALT]    Unterstrichen

 !item [CTRL]   Hohl

 !item [SHIFT]  Fett

 !item [sonst]  normal
!end_xlist

Hierdurch wird die Tastatur-Untersttzung optisch sichtbar gemacht.

!end_node

!end_node


!begin_node Userdef-FText
!alias FText

Fr Erl„uterungen war es bisher recht umst„ndlich, mehrere G_STRING-
Objekte umzuarbeiten. Mit diesem USERDEF wird der Text einmal
eingegeben und dann kann man den Text selbst schnell umarrangieren.
Der Text wird an Spaces und an Bindestrichen umgebrochen, soweit
m”glich. Bar '|' erzwingt einen Umbruch.

Der Text selbst wird im Transparent Modus gezeichnet. Es werden fixed
(monospaced) Fonts untersttzt.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_ftext

 !item [ub_parm]

           !begin_xlist [Bit 20-31]
           !item [Bit 0-7]    H”he in Pixeln (0 wird durch gl_hchar ersetzt)

           !item [Bit 8-13]   Effekte

           !item [Bit 14-15]  Ausrichtung (0=links, 1=rechts, 2=zentriert,
                      3=Blocksatz)

           !item [Bit 16-19]  Farbindex

           !item [Bit 20-31]  Schrift
           !end_xlist

 !item [ub_serv]  Auo_ftext

 !item [ub_ptr1]  NULL/NIL oder ein C-String

 !item [ub_ptr2]  NULL/NIL (window)

 !item [ub_ptr3]  NULL/NIL (obnr)
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_ftext/Auo_ftext

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Select

Manchmal ist das Invertieren nicht geeignet, um die Anwahl anzuzeigen.
Hier bietet A_select alternativ einen Rahmen an. Sinnvollerweise kommt
dieses USERDEF nur in Mens und Popups vor. Das Objekt muž dann noch
mit Kindern gefllt werden. Zum Editieren ist es etwas problematisch,
da es im Normalzustand unsichtbar ist.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_select

 !item [ub_parm]  0

 !item [ub_serv]  NULL/NIL

 !item [ub_ptr1]  NULL/NIL

 !item [ub_ptr2]  NULL/NIL

 !item [ub_ptr3]  NULL/NIL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_select

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Arrows

Dieses USERDEF stellt Pfeile und Linien zur Verfgung. Es kann nicht
durch Selektieren invertiert werden, dies macht auch keinen besonderen
Sinn. (Siehe auch VDI: v_pline)

Ab Version 2.2 steht auch eine richtig punktierte Linie zur Verfgung.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_pattern

 !item [ub_parm]

           !begin_xlist [Bit 28-30]
           !item [Bit 0-3]    Farbe

           !item [Bit 16-18]  Linientyp (vsl_type)

           !item [Bit 19]     0=1 Pixel breit, 1=3 Pixel breit

           !item [Bit 20-21]  Endetypus Start (vsl_ends)

           !item [Bit 22-23]  Endetypus Ende (vsl_ends)

           !item [Bit 24-26]  Startposition

           !item [Bit 28-30]  Endposition

           !item [Bit 31]     3D-Modus
           !end_xlist

          Die Positionen 4-7 sind um eine halbe Zeichenposition nach
          innen versetzt.


!image (!IMAGES)img00733.img

 !item [ub_serv]  NULL/NIL

 !item [ub_ptr1]  NULL/NIL

 !item [ub_ptr2]  NULL/NIL

 !item [ub_ptr3]  NULL/NIL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_arrows

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Pattern
!alias Pattern

Dieses Userdef erlaubt verschiedene VDI-Muster zu w„hlen. (siehe auch
VDI: v_bar).

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_pattern

 !item [ub_parm]

           !begin_xlist [Bit 22-23]
           !item [Bit 0-3]    Farbe

           !item [Bit 16-20]  Musterindex (vsf_style)

           !item [Bit 21]     Rahmen (vsf_perimeter)

           !item [Bit 22-23]  0=FIS_HATCH, 1=FIS_PATTERN, 2 & 3=ACS-eigen
           !end_xlist

 !item [ub_serv]  NULL/NIL

 !item [ub_ptr1]  NULL/NIL

 !item [ub_ptr2]  NULL/NIL

 !item [ub_ptr3]  NULL/NIL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_pattern

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Innerframe
!alias Innerframe

Das Userdef-Innerframe stellt eine Box dar, die in allen Richtungen um
eine halbe Zeichengr”že nach innen versetzt ist. Ein optionaler String
kann plaziert werden.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_innerframe

 !item [ub_parm]

           !begin_xlist [Bit 24-26]
           !item [Bit 0-3]    Rahmenfarbe links/oben

           !item [Bit 4-7]    Textfarbe

           !item [Bit 8]      Textmodus

           !item [Bit 9-11]   Fllmuster

           !item [Bit 12-15]  Fllfarbe

           !item [Bit 16-23]  Rahmenfarbe rechts/unten

           !item [Bit 24-26]  Textposition:

                       !begin_xlist [0]
                       !item [0]  oben links

                       !item [1]  oben zentriert

                       !item [2]  oben rechts

                       !item [4]  unten links

                       !item [5]  unten zentriert

                       !item [6]  unten rechts
                       !end_xlist

           !item [Bit 27]     grožer/kleiner Text

           !item [Bit 28]     Dither-Modus
           !end_xlist

 !item [ub_serv]  Auo_string

 !item [ub_ptr1]  NULL/NIL oder ein C-String

 !item [ub_ptr2]  NULL/NIL

 !item [ub_ptr3]  NULL/NIL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item A_innerframe, Auo_string

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Title
!alias Title

Es wird ein Text gezeichnet, der unterstrichen ist. Dieses Userdef
kann fr Titel verwendet werden. Tastencodes werden im Text durch
String Codes kenntlich gemacht.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_title

 !item [ub_parm]

           !begin_xlist [Bit 0-1]
           !item [Bit 0-1]    0=Links, 1=Mitte, 2=Rechts

           !item [Bit 2]      0=normale Schrift, 1=kleine Schrift

           !item [Bit 3]      0=transparent, 1=deckend
           !end_xlist

 !item [ub_serv]  Auo_string

 !item [ub_ptr1]  NULL/NIL oder ein C-String

 !item [ub_ptr2]  NULL/NIL

 !item [ub_ptr3]  NULL/NIL
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_title, Auo_string

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Userdef-Checkbox
!alias Userdef-Radiobutton

Dieses Objekt stellt eine Check-Box bzw. einen Radio-Button dar.
Hinterlegte Tasten-Codes werden im Text durch String Codes kenntlich
gemacht.

Die Werte der zum Userdef geh”renden AUSERBLK-Struktur sind
folgendermažen belegt:

!begin_xlist [ub_parm]
 !item [ub_code]  A_checkbox

 !item [ub_parm]  0 = Normal, 1 = 3D-Darstellung (nur bei 16*16 Pixel)

 !item [ub_serv]  Auo_string

 !item [ub_ptr1]  NULL/NIL oder ein C-String

 !item [ub_ptr2]  NULL/NIL

 !item [ub_ptr3]  NULL/NIL
!end_xlist

(!I)Achtung(!i): Ab Version 2.2 wurden die Objekte Checkbox und Radiobutton
zusammengelegt, die Unterscheidung erfolgt nur noch anhand des
RBUTTON-Flags in ob_flags!

(!I)Querverweise:(!i)

!begin_enumerate
  !item A_checkbox, Auo_string

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node

!end_node


!begin_node Vordefinierte Drag-Typen
!alias Drag-Typen

Damit der Empf„nger eines gezogenen Objektes weiž fr was das Objekt
steht, gibt es die Typen. Ein Typ ist ein 16-Bit Wort. Die Applikation
darf den Nummerkreis von 10000 bis 32000 verwenden. (!I)ACSpro(!i) definiert
den Nummernkreis von 0 bis 9999. Nur (!I)ACSpro(!i)-definierte Typen k”nnen
zur Kommunikation zwischen Applikationen und Modulen eingesetzt
werden.

Falls diese Typen nicht reichen, lassen Sie sich ihren neuen Typ
registrieren!

!begin_xlist [AT_ICONWINDOW]
 !item [Kein Typ]       (0)

 !item [AT_ICONWINDOW]  (1)

 !item [AT_NEW]         (2)

 !item [AT_TRASH]       (3)

 !item [AT_MFDB]        (10)

 !item [AT_STRING]      (11)

 !item [AT_FILE]        (20)

 !item [AT_ARCHIVE]     (30)

 !item [AT_TEXT]        (31)

 !item [AT_TURNUS]      (32)

 !item [AT_NOTIO]       (33)
!end_xlist


!begin_node AT_ICONWINDOW

Es handelt sich um das Symbol fr ein Fenster.

!begin_xlist [userp1]
 !item [click]   Das Fenster wird ge”ffnet (wi->open)

 !item [drag]    Dem Fenster wird die Nachricht AS_DRAGGED zugesandt

 !item [userp1]  Zeiger auf das Fenster (Awindow* bzw. (!link [AwindowPtr] [AwindowPtr]))

 !item [userp2]  Zeiger auf die Ikone (CICONBLK * bzw. CICONBLKPtr)
!end_xlist

!end_node


!begin_node AT_NEW

Es handelt sich um das Symbol NEU.

!begin_xlist [userp1]
 !item [click]   Ein Applikationsobjekt wird erzeugt

 !item [drag]    Ein Applikationsobjekt wird erzeugt

 !item [userp1]  nicht belegt

 !item [userp2]  nicht belegt
!end_xlist

!end_node


!begin_node AT_TRASH

Es handelt sich um das Symbol des Papierkorbs.

!begin_xlist [userp1]
 !item [click]   nicht belegt (Infobox)

 !item [drag]    Sendet die Nachricht AS_DELETE an das Fenster, dem die
         Objekte geh”ren

 !item [userp1]  nicht belegt

 !item [userp2]  nicht belegt
!end_xlist

!end_node


!begin_node AT_MFDB

Dieses Objekt enth„llt einen Zeiger auf einen MFDB in Standardformat.
Damit k”nnen Graphiken ausgetauscht werden.

!begin_xlist [userp1]
 !item [click]   nicht belegt

 !item [drag]    nicht belegt

 !item [userp1]  MFDB* bzw. MFDBPtr

 !item [userp2]  nicht belegt
!end_xlist

!end_node


!begin_node AT_STRING

Dieses Objekt enth„llt einen nullterminierten String (C-String). Damit
kann Text ausgetauscht werden.

!begin_xlist [userp1]
 !item [click]   nicht belegt

 !item [drag]    nicht belegt

 !item [userp1]  char * bzw. Pointer

 !item [userp2]  nicht belegt
!end_xlist

!end_node


!begin_node AT_FILE

Dieses Objekt enth„llt einen nullterminierten String (C-String). Er
symbolisiert eine Datei. Der Inhalt ist der zugeh”rige Pfadname.

!begin_xlist [userp1]
 !item [click]   nicht belegt

 !item [drag]    nicht belegt

 !item [userp1]  char * bzw. Pointer

 !item [userp2]  nicht belegt
!end_xlist

!end_node


!begin_node AT_ARCHIVE

Dieses Objekt enth„llt einen nullterminierten String (C-String). Es
ist fr die LAZy-Shell reserviert.

!end_node


!begin_node AT_TEXT

Dieses Objekt enth„llt einen nullterminierten String (C-String).
Einzelne Zeilen werden durch ein '\n' (und optional '\r') getrennt,
womit ber ein Objekt mehrere Zeilen verschickt weden k”nnen.

!begin_xlist [userp1]
 !item [click]   nicht belegt

 !item [drag]    nicht belegt

 !item [userp1]  char * bzw. Pointer

 !item [userp2]  nicht belegt
!end_xlist

!end_node


!begin_node AT_TURNUS

Dieses Objekt ist fr TurnUs reserviert.

!end_node


!begin_node AT_NOTIO

Dieses Objekt ist fr Notio reserviert.

!end_node

!end_node


!begin_node Der "pure" Desktop

Der Desktop einer Anwendung erm”glicht dem Benutzer den Zugriff auf
die wichtigsten Funktionen und Dateien, die sich in Form von Symbolen
auf dem Bildschirm befinden. Unter GEM ist es auch blich, daž der
Desktop eine Menleiste besitzt, die weitere Operationen erm”glicht.

Da sich das Verhalten und die Darstellung des Desktops DESKTOP zu sehr
von dem blichen Verhalten anderer Anwendungen unterschied, verwendet
(!I)ACSpro(!i) nun den "puren Desktop" PUR_DESK als Wurzelfenster. Damit
ergibt sich im Gegensatz zum bisherigen Desktop ein "normales
Applikationsverhalten" - die Modul- und Iconverwaltung liegt dazu in
einem eigenen Module-Fenster. Die Menleiste wird als Systemmenleiste
angemeldet - im Accessory-Modus verschiebt sie sich in das Module-
Fenster.

In allen moderneren Anwendungen sollte der Desktop PUR_DESK verwendet
werden, der Dekstop DESKTOP ist nur noch zur Kompatibilit„t enthalten
und wird in einer der n„chsten Versionen verschwinden.


!image (!IMAGES)img00732.img

!end_node


!begin_node Der generische Desktop

Der bis zur (!I)ACSpro(!i)-Version 2.3 verwendete Desktop DESKTOP ist der
Vorl„ufer des modereren Desktops PUR_DESK.

Der Desktop DESKTOP bietet unter anderem die M”glichkeit, Fenster, die
momentan nicht benutzt werden zu Symbolen werden, zu lassen und das
Verhalten einiger Grundfunktionen zu ver„ndern. Zus„tzlich ist es
m”glich, einige ”fter gebrauchte, eigenst„ndige Module nachzuladen.
Der Desktop wird in einer Multitaskingumgebung in ein Fenster
umgelenkt, damit man immer den Standard-Desktop des GEM benutzen kann.
Der DESKTOP kann vom Programmierer durch einen eigenen ersetzt werden.
Viel ntzlicher aber ist es, daž dieser v”llig abgestellt werden kann.
Der Programmierer kann also auch seine eigene Menleiste installieren.
Der Desktop kann auf verschiedene Weise konfiguriert werden.

In allen moderneren Anwendungen sollte der pure Desktop PUR_DESK
verwendet werden, der Desktop DESKTOP ist nur noch zur Kompatibilit„t
enthalten und wird in einer der n„chsten Versionen verschwinden.

!end_node


!begin_node Das Editor-Fenster und das Editor-Objekt

Hier fehlt noch etwas...

!end_node


!begin_node Das Protokoll-Fenster

Hier fehlt noch etwas...

!end_node


!begin_node Das Plotter-Fenster

Hier fehlt noch etwas...

!end_node


!end_node
