!begin_node Alphabetischer Referenzindex

Hier ist nun die alphabetische Liste aller Variablen, Strukturen und
Funktionen, die (!I)ACSpro(!i) zur VerfÅgung stellt. Ferner wurden alle
wichtigen Konstanten, besonders die Fenster- und Objekt-Nachrichten
hier aufgenommen.

!subtoc [all] !depth 1

!begin_node Aaction

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Datentyp fÅr Klick- & (!link [Drag-Routine] [Click-Routine])

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [C:]                 typedef void (*Aaction)(void);

 !item [Pascal:]            Aaction = Procedure;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Dieser Datentyp wird fÅr Aufrufe der click und drag-Routine verwendet.

Der Routine werden keine Parameter Åbergeben und es wird kein Ergebnis
zurÅckgegeben.

!end_node


!begin_node Ablk
!alias AblkPtr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Alle globalen (!I)ACSpro(!i)-Variablen

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Structur Ablk faût alle globalen (!I)ACSpro(!i)-Variablen zusammen, der
Zeiger ACSblk zeigt auf diese Struktur und stellt so alle Variablen
zur VerfÅgung.

!begin_blist [Pascal:]
 !item [C:]
!begin_sourcecode
typedef struct
{
   int16    gl_apid;
   int16    phys_handle;
   int16    gl_wattr;
   int16    gl_hattr;
   Axywh    desk;
   int16    vdi_handle;
   int16    gl_wbox;
   int16    gl_hbox;
   int16    gl_wchar;
   int16    gl_hchar;
   int16    ncolors;
   int16    nplanes;
   char     appname[128];
   char     apppath[128];
   char     apppara[128];
   char     appfrom[128];
   char     basename[20];
   long     ev_mtcount;
   int16    application;
   int16    multitask;
   int16    appexit;
   Adescr   *description;
   Asel     Aselect;
   Awindow  *ev_window;
   OBJECT   *ev_object;
   int16    ev_obnr;
   int16    ev_mmox, ev_mmoy;
   int16    ev_mmokstate;
   int16    dia_abort;
   MFDB     screenMFDB;
   int16    apterm;
   int16    *AESglobal;
   int16    fonts;
   int16    argc;
   char     **argv;
   char     **env;
   int16    fontid;
   int16    fheight;
   int16    fontsid;
   int16    fsheight;
   void     (*ACSterm)( void );
   void     (*ACSaboutme)( void );
   void     (*ACSclose)( void );
   void     (*ACSmessage)( int16 *ev_mmgpbuf );
   void     (*ACSmproto)( int16 *ev_mmgpbuf );
   void     (*ACStimer)( void );
   int16    (*ACSinit0)( void );
   int16    dither;
   void     (*ACSkey)( int16 *kstate, int16 *key );
   void     (*ACSbutton)( int16 *button,
                  int16 *kreturn );
   void     (*ACSmouse)( void );
   void     (*ACSwikey)( int16 *kstate, int16 *key );
   int16    ev_bmask;
   int16    ev_bstate;
   int16    ev_mmobutton;
   int16    ev_mbreturn;
   int16    ev_mkreturn;
   int16    ev_mbclicks;
   void     (*DEBUG_MEM) (void* defective);
   char     cfg_path [128];
   char     scrp_path[128];
   void     (*ACSerror)( int16 mess, void *para );
   int16    menu_id;
   char     *dd_name;
   char     *alert_name;
   int16    mfsel_count;
   char     separator[256];
   char     *AppLongName;
   UConfig  *cfg;
   int16    (*GEMScript)( int16 anz, char **cmd,
                  A_GSAntwort *antwort );
} Ablk;
!end_sourcecode

 !item [Pascal:]
!begin_sourcecode
AblkPtr = ^Ablk;
Ablk = Record
   gl_apid:      Integer;
   phys_handle:  Integer;
   gl_wattr:     Integer;
   gl_hattr:     Integer;
   desk:         Axywh;
   vdi_handle:   Integer;
   gl_wbox:      Integer;
   gl_hbox:      Integer;
   gl_wchar:     Integer;
   gl_hchar:     Integer;
   ncolors:      Integer;
   nplanes:      Integer;
   appname:      packed array [1..128] of char;
   apppath:      packed array [1..128] of char;
   apppara:      packed array [1..128] of char;
   appfrom:      packed array [1..128] of char;
   basename:     packed array [1..20] of char;
   ev_mtcount:   LongInt;
   application:  Integer;
   multitask:    Integer;
   appexit:      Integer;
   description:  AdescrPtr;
   Aselect:      Asel;
   ev_window:    AwindowPtr;
   ev_object:    ACSTreePtr;
   ev_obnr:      Integer;
   ev_mmox:      Integer;
   ev_mmoy:      Integer;
   ev_mmokstate: Integer;
   dia_abort:    Integer;
   screenMFDB:   MFDB;
   apterm:       Integer;
   AESglobal:    ^Integer;
   fonts:        Integer;
   argc:         Integer;
   argv:         Pointer;
   env:          Pointer;
   fontid:       Integer;
   fheight:      Integer;
   fontsid:      Integer;
   fsheight:     Integer;
   ACSterm:      Procedure;
   ACSaboutme:   Procedure;
   ACSclose:     Procedure;
   ACSmessage:   Procedure( Var ev_mgpbuff: ARRAY_8 );
   ACSmproto:    Procedure( Var ev_mgpbuff: ARRAY_8 );
   ACStimer:     Procedure;
   ACSinit0:     Function: Integer;
   dither:       Integer;
   ACSkey:       Procedure( Var kstate: Integer;
                       key: Integer );
   ACSbutton:    Procedure( Var button : Integer;
                       Var breturn : Integer );
   ACSmouse:     Procedure;
   ACSwikey:     Procedure (var kstate : Integer;
                       Var key : Integer );
   ev_bmask:     Integer;
   ev_bstate:    Integer;
   ev_mmobutton: Integer;
   ev_mbreturn:  Integer;
   ev_mkreturn:  Integer;
   ev_mmobutton: Integer;
   ev_mbreturn:  Integer;
   ev_mkreturn:  Integer;
   ev_mbclicks:  Integer;
   DEBUG_MEM:    Procedure( defective: Pointer );
   cfg_path:     packed array [1..128] of char;
   scrp_path:    packed array [1..128]of char;
   ACSerror:     Procedure( mess: Integer;
                       para: Pointer );
   menu_id:      Integer;
   dd_name:      Pointer;
   alert_name:   Pointer;
   mfsel_count:  Integer;
   separator:    packed array [1..256] of char;
   AppLongName:  Pointer;
   cfg:          UConfigPtr;
   GEMScript:    Function(
                       int16 anz, char **cmd,
                       A_GSAntwort *antwort
                    ) : Integer;
End;
!end_sourcecode
!end_blist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen
  !item ACSblk
!end_enumerate

!end_node


!begin_node Abp_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Backplane erzeugen

 !item [Kategorie:]         Backplane-UnterstÅtzung

 !item [C:]                 MFDB *Abp_create( int16 w, int16 h );

 !item [Pascal:]            Function Abp_create( w, h: Integer ) : MFDBPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Abp_create erzeugt eine Backplane mit der Weite 'w' und
der Hîhe 'h' unter Beachtung von 'nplanes'. Der Inhalt wird mit 0
gefÅllt. Sollte eine monochrome Bitmap erwÅnscht sein, muû kurzfristig
um diesen Aufruf herum nplanes auf 1 gesetzt werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Backplane-UnterstÅtzung

  !item Abp_delete
!end_enumerate

!end_node


!begin_node Abp_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Backplane freigeben

 !item [Kategorie:]         Backplane-UnterstÅtzung

 !item [C:]                 void Abp_delete( MFDB *backplane );

 !item [Pascal:]            Procedure Abp_delete( backplane: MFDBPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Abp_delete gibt den mittels Abp_create erzeugten
Backplane wieder frei.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Backplane-UnterstÅtzung

  !item Abp_create
!end_enumerate

!end_node


!begin_node Abp_end

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichnen auf Backplane deaktivieren

 !item [Kategorie:]         Backplane-UnterstÅtzung

 !item [C:]                 void Abp_end( void );

 !item [Pascal:]            Procedure Abp_end;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Nach Aufruf der Funktion Abp_end zeichnen die AES und das VDI wieder
auf den Bildschirm.

(!B)Hinweis:(!b) Die Funktion sollte nur genutzt werden, wenn die Offscreen-
Bitmaps (z.B. von NVDI) nicht zur VerfÅgung stehen (also fÅr
Ash_CallEdDI(0)<0x0100). Intern werden LineA-Variablen und der
Bildschirmspeicher (per Setscreen) verbogen - also schmutzige Tricks!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Backplane-UnterstÅtzung

  !item Abp_start
!end_enumerate

!end_node


!begin_node Abp_img2mfdb

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Graphik vom IMG-Format in MFDB umwandeln

 !item [Kategorie:]         Backplane-UnterstÅtzung

 !item [C:]                 int16 Abp_img2mfdb( IMG_HEADER *org, MFDB **dest,
                                int16 do_trnsfm );

 !item [Pascal:]            Function Abp_img2mfdb( org: IMG_HEADERPTR;
                                   dest: Pointer; trnsfm: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Abp_img2mfdb packt ein im IMG-Format vorliegendes und
geladenens Bild aus, wandelt es in einen MFDB, der dann weiter
verwendet werden kann. Die Bilddaten mÅssen dabei genau hinter dem
IMG-HEADER liegen (wie dies bei einer Datei der Fall ist). Dabei wird
ein XIMG-HEADER erkannt und korrekt bedient, die Auswertung der Farben
muû jedoch selbst vorgenommen werden.

(!I)Nur wenn OK zurÅckgeliefert wurde, sind die Daten in 'dest' gÅltig.(!i)

Hierbei ist 'org' der voliegende IMG-HEADER, in 'dest' wird ein Zeiger
auf den erzeugten MFDB zurÅckgeliefert. Wird 'do_trnsfm' auf TRUE
gesetzt, wird der MFDB auch noch in das gerÑteabhÑngige Format (fÅr
jede Plane) transformiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Backplane-UnterstÅtzung

  !item Abp_mfdb2img
!end_enumerate

!end_node


!begin_node Abp_mfdb2img

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Graphik vom IMG-Format in MFDB umwandeln

 !item [Kategorie:]         Backplane-UnterstÅtzung

 !item [C:]                 int16 Abp_mfdb2img( MFDB* org, IMG_HEADER **dest,
                                long *img_len );

 !item [Pascal:]            Function Abp_mfdb2img (org: MFDBPTR;
                                   dest: Pointer; len: Longint
                                ): Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Abp_mfdb2img wandelt ein als MFDB vorliegendes Bild in
ein Image um. Dabei werden nur die Bilddaten konvertiert, wenn ein
XIMG-HEADER erzeugt werden soll, mÅssen Sie diesen nach der
Konvertierung selber anlegen. Die komprimierten Image-Bilddaten
befinden sich direkt hinter dem IMG-HEADER.

(!I)Nur wenn OK zurÅckgeliefert wurde, sind die Daten in 'dest' und 'len'
gÅltig.(!i)

Hierbei ist 'org' der Zeiger auf den MFDB, in 'dest' wird ein Zeiger
auf den Zielspeicher zurÅckgeliefert. 'len' beinhaltet die LÑnge der
Bildinformationen (ohne IMG-HEADER!) - wird in 'dest' NULL/NIL
Åbergeben, wird nur diese LÑnge berechnet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Backplane-UnterstÅtzung

  !item Abp_img2mfdb
!end_enumerate

!end_node


!begin_node Abp_start

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichnen auf Backplane aktivieren

 !item [Kategorie:]         Backplane-UnterstÅtzung

 !item [C:]                 void Abp_start( MFDB *backplane );

 !item [Pascal:]            Procedure Abp_start( backplane: MFDBPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Nach Aufruf der Funktion Abp_start erfolgen (!I)alle(!i) AES- und VDI-Ausgaben
auf diesen Backplane. Der Zustand bis zum Aufruf von Abp_end ist sehr
kritisch, da schlieûlich auch die Fehlermeldungen auf den Backplane
geschrieben werden!

(!B)Hinweis:(!b) Die Funktion sollte nur genutzt werden, wenn die Offscreen-
Bitmaps (z.B. von NVDI) nicht zur VerfÅgung stehen (also fÅr
Ash_CallEdDI(0)<0x0100). Intern werden LineA-Variablen und der
Bildschirmspeicher (per Setscreen) verbogen - also schmutzige Tricks!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Backplane-UnterstÅtzung

  !item Abp_end
!end_enumerate

!end_node


!begin_node Acfg_clear

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  UConfig-Struktur neu initialisieren

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 void Acfg_clear( UConfig *cfg, const UCfgInfo
                    *info );

 !item [Pascal:]            Procedure Acfg_clear( cfg: UConfigPtr;
                                   info: UCfgInfoPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_clear lîscht alle Gruppen sowie die darin
enthaltenen Cfg-Strings und die Header-Kommentar-Zeilen, die UConfig-
Verwaltungsstruktur wird neu initialisert. Die Daten der Åbergebenen
Info-Struktur werden Åbernommen. Falls fÅr info der Wert NULL bzw. NIL
Åbergeben wird, werden Default-Werte verwendet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_clearGroup
!end_enumerate

!end_node


!begin_node Acfg_clearAllGroups

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Nur die Cfg-Strings und die Cfg-Gruppen lîschen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 void Acfg_clearAllGroups( UConfig *config );

 !item [Pascal:]            Procedure Acfg_clearAllGroups( config: UConfigPtr);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_clearAllGroups lîscht im Gegensatz zur Funktion
Acfg_clear nur die vorhandenen Gruppen mit ihren Cfg-Strings und lÑût
alle weiteren Daten unangetastet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_clear, Acfg_clearGroup
!end_enumerate

!end_node


!begin_node Acfg_clearGroup

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine Cfg-Gruppe incl. Cfg-Strings lîschen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 void Acfg_clearGroup( UConfig *config, char
                    *kategorie );

 !item [Pascal:]            Procedure Acfg_clearGroup( config: UConfigPtr;
                                 kategorie: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_clearGroup lîscht die Åbergebene Cfg-Gruppe incl.
der darin enthaltenen Cfg-Strings.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_clear, Acfg_clearAllGroups
!end_enumerate

!end_node


!begin_node Acfg_clearHeader

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Am Anfang enthaltene Kommentar-Strings lîschen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 void Acfg_clearHeader( UConfig *config );

 !item [Pascal:]            Procedure Acfg_clearHeader( config: UConfigPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_clearHeader lîscht am Anfang der Cfg-Datei stehende
Kommentar-Strings.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_clearValue

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen einzelnen Cfg-String lîschen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_clearValue( UConfig *config,
                             const char *kategorie, const char *name,
                             char *value );

 !item [Pascal:]            Function Acfg_clearValue( config: UConfigPtr;
                                   kategorie, name, value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_clearValue lîscht den Åbergebenen Parameters aus der
Åbergebenen Gruppe. Der Wert des Parameters wird vor dem Lîschen in
value eingetragen. ZurÅckgegeben wird im Erfolgsfall der Zeiger auf
den Parameter value, andernfalls ein Leerstring.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getValue, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_copyInfo

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten eienr Info-Struktur kopieren

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 UCfgInfo *Acfg_copyInfo( UcfgInfo ödest,
                                 const UCfgInfo *source );

 !item [Pascal:]            Function Acfg_copyInfo(
                                   dest, source: UCfgInfoPtr
                                ) : UCfgInfoPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_copyInfo kopiert alle Daten einer Cfg-Info-Struktur
in eine andere. Dabei werden die in der Cfg-Info-Struktur 'dest' evtl.
vorhandenen Strings per Ast_delete freigegeben, bevor die neuen
Strings per Ast_create angelegt werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine Verwaltungsstruktur der Cfg-Strings erzeugen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 UConfig *Acfg_create( const UCfgInfo *info,
                                int16 load );

 !item [Pascal:]            Function Acfg_create(
                                   info: UCfgInfoPtr; load: Integer
                                ) : UConfigPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_create alloziert und initialisiert die Verwaltungs-
Struktur der Konfigurations-Strings.

öber den Parameter info kann eine Info-Struktur Åbergeben werden,
deren Inhalte in die UConfig-Verwaltungsstruktur Åbernommen werden -
es kann jedoch auch NULL bzw. NIL Åbergeben werden (dann werden
Default-Werte verwendet). Wenn das Flag load gesetzt (TRUE) ist, so
wird die in der evtl. vorhandenen Info-Struktur angegebene CFG-Datei
geladen, sofern sie vorhanden ist. Andernfalls wird die UConfig-
Verwaltungsstruktur nur initialisiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_delete
!end_enumerate

!end_node


!begin_node Acfg_createInfo

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten der Info-Struktur aus den Cfg-Strings
                    auslesen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 UCfgInfo *Acfg_createInfo( void );

 !item [Pascal:]            Function Acfg_createInfo : UCfgInfoPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_createInfo erzeugt eine Cfg-Info-Struktur zur
Konfiguration der Cfg-Strings.

(!B)Hinweis:(!b) Jede mittels Acfg_createInfo erzeugte Struktur sollte auch
per Acfg_deleteInfo wieder freigegeben werden, da sonst Speicher-Lecks
entstehen!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_deleteInfo
!end_enumerate

!end_node


!begin_node Acfg_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine Verwaltungsstruktur der Cfg-Strings lîschen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 void Acfg_delete( UConfig *config );

 !item [Pascal:]            Procedure Acfg_delete( config: UConfigPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_delete lîscht die Åbergebene Cfg-Verwaltungsstruktur
und gibt allen benutzten Speicher frei.

(!B)Hinweis:(!b) Noch nicht gesicherte énderungen werden (!I)nicht(!i) gespeichert,
dies muû ggf. Åber die Funktionen Acfg_isChanged und Acfg_save selbst
realisiert werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_create, Acfg_isChanged, Acfg_save
!end_enumerate

!end_node


!begin_node Acfg_deleteInfo

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen einer neuen Info-Struktur fÅr die Cfg-
                    Strings

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 void Acfg_deleteInfo( UCfgInfo *info );

 !item [Pascal:]            Procedure Acfg_deleteInfo( info: UCfgInfoPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_deleteInfo gibt die Åbergebene Cfg-Info-Struktur
wieder frei.

(!B)Hinweis:(!b) Jede mittels Acfg_createInfo erzeugte Struktur sollte auch
per Acfg_deleteInfo wieder freigegeben werden, da sonst Speicher-Lecks
entstehen!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_createInfo
!end_enumerate

!end_node


!begin_node Acfg_getBool
@xref "Acfg_setBool"
@xref "Acfg_getValue"
@{U}F.19  Acfg_getBool                                              ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines logischen Cfg-Parameters ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_getBool( UConfig *config,
                             const char *kategorie,
                             const char *name );

 !item [Pascal:]            Function Acfg_getBool( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getBool liest den Parameter 'name' der Gruppe
'kategorie' aus und konvertiert ihn in einen logischen Wert. Der Wert
"True" wird nach TRUE konvertiert, alles andere nach FALSE.

(!B)Hinweis:(!b) Da intern auf Acfg_getValue zrÅckgegriffen wird, kann auch
hier bei der Suche auf die Environment-Strings zurÅckgegriffen werden.
Das Verhalten kann Åber die Funktion Acfg_setInfo beeinfluût werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_setBool, Acfg_getValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getChar
@xref "Acfg_setChar"
@xref "Acfg_getValue"
@{U}F.20  Acfg_getChar                                              ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines logischen Cfg-Parameters ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char Acfg_getChar( UConfig *config,
                             const char *kategorie, const char *name);

 !item [Pascal:]            Function Acfg_getChar( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : Char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getChar liest den Parameter 'name' der Gruppe
'kategorie' aus und gibt das erste Zeichen des Wertes zurÅck.

(!B)Hinweis:(!b) Da intern auf Acfg_getValue zrÅckgegriffen wird, kann auch
hier bei der Suche auf die Environment-Strings zurÅckgegriffen werden.
Das Verhalten kann Åber die Funktion Acfg_setInfo beeinfluût werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_setChar, Acfg_getValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getLong
@xref "Acfg_setLong"
@xref "Acfg_getValue"
@{U}F.21  Acfg_getLong                                              ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines logischen Cfg-Parameters ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 INT32 Acfg_getLong( UConfig *config,
                             const char *kategorie, const char *name);

 !item [Pascal:]            Function Acfg_getLong( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : LongInt;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getLong liest den Parameter 'name' der Gruppe
'kategorie' aus und konvertiert den Wert in einen Long-Integer.

(!B)Hinweis:(!b) Da intern auf Acfg_getValue zrÅckgegriffen wird, kann auch
hier bei der Suche auf die Environment-Strings zurÅckgegriffen werden.
Das Verhalten kann Åber die Funktion Acfg_setInfo beeinfluût werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_setLong, Acfg_getValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getHeader

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Header-Kommentar-Zeilen lesen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char **Acfg_getHeader( UConfig *config,


 !item [Pascal:]            Function Acfg_getHeader(
                                   config: UConfigPtr;
                                   head_lines: Array of Pointer
                                ) : ^Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getHeader ÅbertrÑgt die Header-Kommentar-Zeilen der
Cfg-Strings in das Åbergebene Array.

Als RÅckgabewert erhÑlt man 'head_lines' zurÅck.

(!B)Hinweis:(!b) Das Array muû zuvor bereits richtig dimensioniert sein!
HierfÅr steht die Funktion Acfg_headAnzahl zur VerfÅgung

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_setHeader
!end_enumerate

!end_node


!begin_node Acfg_getInfo

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten aus der Info-Struktur in die Cfg-Strings
                    Åbertragen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 UCfgInfo *Acfg_getInfo( UConfig *config,
                                 UCfgInfo *info );

 !item [Pascal:]            Function Acfg_getInfo(
                                   config: UConfigPtr; info:
                    UCfgInfoPtr
                                ) : UCfgInfoPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getInfo ÅbertrÑgt die Info-Daten aus den Cfg-Strings
in die vorbereitete Cfg-Info-Struktur.

Als RÅckgabewert erhÑlt man den Zeiger 'info' auf die Info-Struktur
zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getValue
@xref "Acfg_clearValue"
@{U}F.24  Acfg_getValue                                             ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines Cfg-Parameters ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_getValue( UConfig *config,
                             const char *kategorie, const char *name,
                             char *value );

 !item [Pascal:]            Function Acfg_getValue( config: UConfigPtr;
                                   kategorie, name, value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getValue ermittelt den Wert des Åbergebenen
Parameters in der Åbergebenen Gruppe. ZurÅckgegeben wird der Zeiger
auf den Parameter value.

(!B)Hinweis:(!b) Wenn der Parameter in den Cfg-Strings nicht gefunden wird,
kann die Funktion Acfg_getValue auch in den Environment-Strings nach
dem Wert des Parameters suchen. Das Verhalten kann Åber die Funktion
Acfg_setInfo beeinfluût werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_clearValue, Acfg_setValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getString
@xref "Acfg_clearValue"
@{U}F.25  Acfg_getString                                            ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines Cfg-Parameters ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_getString( UConfig *config,
                             const char *kategorie, const char *name);

 !item [Pascal:]            Function Acfg_getString( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_getString greift mittels eines statischen Strings
auf die Funktion Acfg_getValue zurÅck, um den Wert des Parameters
'name' in der Gruppe 'kategorie' zu ermitteln.

(!B)Hinweis:(!b) Da intern ein statischer String fÅr Acfg_getValue benutzt
wird, ist die Funktion (!I)nicht(!i) multithreading-fest!

(!B)Hinweis:(!b) Wenn der Parameter in den Cfg-Strings nicht gefunden wird,
kann die Funktion Acfg_getValue auch in den Environment-Strings nach
dem Wert des Parameters suchen. Das Verhalten kann Åber die Funktion
Acfg_setInfo beeinfluût werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_clearValue, Acfg_setValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_grpAnzahl

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Anzahl der Cfg-Gruppen ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_grpAnzahl( UConfig *config );

 !item [Pascal:]            Function Acfg_grpAnzahl( config: UConfigPtr ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_grpAnzahl ermittelt die Anzahl der tatsÑchlichen
Cfg-Gruppen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_grpName

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Namen einer Cfg-Gruppe ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_grpName( UConfig *config,
                               int16 grp_nr, char *name )

 !item [Pascal:]            Function Acfg_grpName(
                                   config: UConfigPtr; grp_nr:
                    Integer; name: Pointer             ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_grpName bestimmt den Gruppennamen der in 'grp_nr'
Åbergebenen Gruppe und trÑgt ihn in 'name' ein. Als Ergebnis wird der
Zeiger 'name' zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_headAnzahl

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Anzahl der Kommentar-Strings am Anfang
                    ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_headAnzahl( UConfig *config );

 !item [Pascal:]            Function Acfg_headAnzahl( config: UConfigPtr ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_headAnzahl gibt die Anzahl der Kommentar-Strings am
Anfang der Cfg-Datei zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_isCfgfile

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  PrÅfen, ob den Cfg-Strings der Dateiname
                    zugeordnet ist

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_isCfgfile( UConfig *config,
                             const char *filename );

 !item [Pascal:]            Function Acfg_isCfgfile(
                                   config: UConfigPtr;
                                   filename: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_isCfgfile prÅft, ob der Åbergebene Dateiname den
Cfg-Strings zugeordnet ist oder nicht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_isChanged

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  PrÅfen, ob Cfg-Strings verÑndert wurden

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_isChanged( UConfig *config );

 !item [Pascal:]            Function Acfg_isChanged(
                                   config: UConfigPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_isChanged prÅft, ob die Cfg-Strings seit dem letzten
Laden oder Speichern verÑndert wurden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_load, Acfg_save
!end_enumerate

!end_node


!begin_node Acfg_load

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Cfg-Strings aus einer Datei laden

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_load( UConfig *config,
                             const char *filename );

 !item [Pascal:]            Function Acfg_load(
                                   config: UConfigPtr; filename:
                    Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_load lÑdt die Cfg-Strings aus der angegebenen Datei.

Falls NULL bzw. NIL Åbergeben wird, wird der Dateiname verwendet, der
Åber eine Cfg-Info-Struktur gesetzt werden kann. Falls dann auch dort
kein Dateiname steht, wird nichts geladen.

(!B)Hinweis:(!b) Der Dateiname wird zuvor bearbeitet. Wenn kein Pfad angegeben
wurde, wird der Pfad aus ACSblk->cfg_path verwendet.

(!B)Tip:(!b) Der Dateiname der Datei wird intern in der Cfg-Verwaltungs-
Struktur aufbewahrt. Beim (!link [Speichern] [Acfg_save]) ist die Angabe eines Dateinamens
dann nur nîtig, wenn dieser abweichen sollte!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_save
!end_enumerate

!end_node


!begin_node Acfg_save

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Cfg-Strings in eine Datei siichern

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_save( UConfig *config,
                             const char *filename );

 !item [Pascal:]            Function Acfg_save(
                                   config: UConfigPtr; filename:
                    Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_save lÑdt die Cfg-Strings aus der angegebenen Datei.

Beim Speichern werden zunÑchst evtl. gesetzte Header-Kommentar-Zeilen
gespeichert, falls die zu speichernde erste Zeile nicht selbst ein
Kommentar ist. Beim Laden und Speichern bleiben Kommentare komplett
erhalten, es wird nichts an ihnen verÑndert! Da die Header-Kommentar-
Zeilen per Programm (!link [verÑndert werden kînnen] [Acfg_setHeader]), kann keine einfache
öberprÅfung implementiert werden, ob die Header-Kommentar-Zeilen
bereits vorhanden sind oder nicht.

(!B)Hinweis:(!b) Nach erfolgreichem Speichern der Strings wird das (!link [Change-Flag] [Acfg_isChanged])
zurÅckgesetzt.

(!B)Hinweis:(!b) Der Dateiname wird zuvor bearbeitet. Wenn kein Pfad angegeben
wurde, wird der Pfad aus ACSblk->cfg_path verwendet.

(!B)Hinweis:(!b) Falls NULL bzw. NIL Åbergeben wird, wird der Dateiname
verwendet, der Åber eine Cfg-Info-Struktur gesetzt werden kann. Falls
dann auch dort kein Dateiname steht, wird nichts gesichert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getHeader, Acfg_isChanged, Acfg_load, Acfg_setHeader
!end_enumerate

!end_node


!begin_node Acfg_setBool
@xref "Acfg_getBool"
@xref "Acfg_setValue"
@{U}F.33  Acfg_setBool                                              ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines logischen Cfg-Parameters setzen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_setBool( UConfig *config,
                             const char *kategorie, const char *name,
                             const int16 value );

 !item [Pascal:]            Function Acfg_getBool( config: UConfigPtr;
                                   kategorie, name: Pointer;
                                   value: int16
                                ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_setBool ist das GegentÅck zu Acfg_getBool und setzt
den Parameter 'name' der Gruppe 'kategorie'. Der Wert TRUE wird als
String "True", alles andere als "False" gesetzt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getBool, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_setChar
@xref "Acfg_getChar"
@xref "Acfg_setValue"
@{U}F.34  Acfg_setChar                                              ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines logischen Cfg-Parameters setzen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_setBool( UConfig *config,
                             const char *kategorie, const char *name,
                             const int16 value );

 !item [Pascal:]            Function Acfg_getBool( config: UConfigPtr;
                                   kategorie, name: Pointer;
                                   value: int16
                                ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_setChar ist das GegentÅck zu Acfg_getChar und setzt
den Parameter 'name' der Gruppe 'kategorie'.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getChar, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_setLong
@xref "Acfg_getLong"
@xref "Acfg_setValue"
@{U}F.35  Acfg_setLong                                              ACSpro@{u}

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines logischen Cfg-Parameters setzen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 INT32 Acfg_setLong( UConfig *config,
                             const char *kategorie, const char *name,
                             const INT32 value );

 !item [Pascal:]            Function Acfg_setLong( config: UConfigPtr;
                                   kategorie, name: Pointer;
                                   value: INT32
                                ) : INT32;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_setLong ist das GegentÅck zu Acfg_getLong und setzt
den Parameter 'name' der Gruppe 'kategorie'.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getLong, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_setHeader

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Header-Kommentar-Zeilen setzen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char **Acfg_setHeader( UConfig *config,
                             int16 anzahl, const char **head_lines );

 !item [Pascal:]            Function Acfg_setHeader(
                                   config: UConfigPtr; anzahl:
                    Integer;
                                   head_lines: Array of Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_setHeader ÅbertrÑgt die Åbergebenen Strings in die
Cfg-Strings als Header-Kommentar-Zeilen.

Als RÅckgabewert erhÑlt man 'head_lines' zurÅck.

(!B)Hinweis:(!b) Das Kommentarzeichen am Anfang der Zeile wird (!I)nicht(!i) eingefÅgt
und (!I)muû(!i) in den Åbergebenen Strings stehen!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getHeader
!end_enumerate

!end_node


!begin_node Acfg_setInfo

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten aus der Info-Struktur in die Cfg-Strings
                    Åbertragen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 UCfgInfo *Acfg_setInfo( UConfig *config,
                                 const UCfgInfo *info );

 !item [Pascal:]            Function Acfg_setInfo(
                                   config: UConfigPtr; info:
                    UCfgInfoPtr
                                ) : UCfgInfoPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_setInfo ÅbertrÑgt die Daten aus der vorbereiteten
Info-Struktur in die Cfg-Strings.

Als RÅckgabewert erhÑlt man den Zeiger 'info' auf die Info-Struktur
zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_getInfo
!end_enumerate

!end_node


!begin_node Acfg_setValue

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Wert eines Cfg-Parameters setzen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_setValue( UConfig *config,
                             const char *kategorie, const char *name,
                             const char *value );

 !item [Pascal:]       Function Acfg_setValue( config: UConfigPtr;
                                   kategorie, name, value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_setValue setzt den Wert des Åbergebenen Parameters
in der Åbergebenen Gruppe. Wenn die Gruppe noch nicht existiert, so
wird sie angelegt, ebenso der Parameter. ZurÅckgegeben wird im
Erfolgsfall der Zeiger auf den Parameter value, andernfalls ein
Leerstring.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_clearValue, Acfg_getValue
!end_enumerate

!end_node


!begin_node Acfg_strAnzahl

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Anzahl der Cfg-Strings in einer Cfg-Gruppe
                    ermitteln

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_strAnzahl( UConfig *config, const int16
                    grp_nr );

 !item [Pascal:]            Function Acfg_strAnzahl(
                                   config: UConfigPtr; grp_nr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_strAnzahl ermittelt die Anzahl der Cfg-Strings in
der Cfg-Gruppe.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])
!end_enumerate

!end_node


!begin_node Acfg_strIsComment

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  PrÅfen, ob ein Cfg-String eine Kommentarzeile ist

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 int16 Acfg_strIsComment( UConfig *config,
                             const int16 grp_nr, const int16 str_nr );

 !item [Pascal:]            Function Acfg_strIsComment(
                                   config: UConfigPtr; grp_nr: Integer
                                   str_nr: Integer             ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_strIsComment prÅft, ob der durch 'str_nr' angegebene
String der mittels 'grp_nr' angegebenen Gruppe eine Kommentarzeile
ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_strName
!end_enumerate

!end_node


!begin_node Acfg_strName

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Namen eines Cfg-Parameters bestimmen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_strName( UConfig *config, const int16
                    grp_nr,
                             const int16 str_nr, char *name );

 !item [Pascal:]            Function Acfg_strName(
                                   config: UConfigPtr; grp_nr: Integer
                                   str_nr: Integer; name: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_strName trÑgt in 'name' den Namen des durch 'str_nr'
angegebenen Cfg-Strings in der durch 'grp_nr' bezeichnten Gruppe ein.
Als Ergebnis wird 'name' zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_strValue
!end_enumerate

!end_node


!begin_node Acfg_strValue

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wert eines Cfg-Parameters bestimmen

 !item [Kategorie:]         (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

 !item [C:]                 char *Acfg_strValue( UConfig *config, const int16
                    grp_nr,
                             const int16 str_nr, char *value );

 !item [Pascal:]            Function Acfg_strValue(
                                   config: UConfigPtr; grp_nr: Integer
                                   str_nr: Integer; value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Acfg_strName trÑgt in 'value' den Wert des durch 'str_nr'
angegebenen Cfg-Strings in der durch 'grp_nr' bezeichnten Gruppe ein.
Als Ergebnis wird 'value' zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Konfigurations-Strings] [Die Konfigurations-Strings])

  !item Acfg_strName
!end_enumerate

!end_node


!begin_node Ach_isWhite

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  String auf Leerstring prÅfen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ach_isWhite( char ch );

 !item [Pascal:]            Function Ach_isWhite( ch: char ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ach_isWhite prÅft, ob ein Zeichen ein "weiûes
Leerzeichen" ist, d.h. eines der Zeichen Tabulator, Carriage-Return,
Line-Feed oder das Leerzeichen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen
!end_enumerate

!end_node


!begin_node Ach_tolower

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen ggf. in Kleinbuchstaben wandeln

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char Ach_tolower( char ch );

 !item [Pascal:]            Function Ach_tolower( ch: char ) : char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ach_tolower konvertiert ein Zeichen in einen
Kleinbuchstaben. Die Umlaute werden hierbei korrekt erkannt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ach_toupper
!end_enumerate

!end_node


!begin_node Ach_toupper

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen ggf. in Groûbuchstaben wandeln

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char Ach_toupper( char ch );

 !item [Pascal:]            Function Ach_toupper( ch: char ) : char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ach_toupper konvertiert ein Zeichen in einen
Kleinbuchstaben. Die Umlaute werden hierbei korrekt erkannt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ach_tolower
!end_enumerate

!end_node


!begin_node Acreate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Datentyp fÅr Create-Routinen

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [C:]                 typedef Awindow *(*Acreate)( void *extra );

 !item [Pascal:]       Acreate = Function( x: Pointer ) : (!link [AwindowPtr] [AwindowPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Dieser Datentyp wird fÅr die create-Routine der Fenster verwendet. Der
Routine wird ein Zeiger unbestimmten Typs Åbergeben. Je nach Aufgabe
des Fensters wird sich dieser Typ unterscheiden. Einem Editorfenster
kînnte man z.B. den Dateinamen mitgeben. Wenn kein Parameter notwendig
ist, sollte NULL bzw. NIL Åbergeben werden. Als Ergebnis erhÑlt man
einen Zeiger auf das erzeugte Fenster. LÑût sich das Fenster nicht
erzeugen, sollte bei eigenen Routinen NULL bzw. NIL zurÅckgegeben
werden.

!end_node


!begin_node ACSaboutme

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  öber die Anwendung informieren

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSaboutme)( void );

 !item [Pascal:]            ACSaboutme: Procedure;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSaboutme verweist, wird
aufgerufen, wenn der Benutzer den ersten Eintrag des Accessory-MenÅs
angewÑhlt hat. Hier kann - z.B. im (!I)ACSpro(!i)-(!I)GUI-Editor(!i) - eine eigene
Routine eingetragen werden.

Die Default-Routine zeigt einen Dialog, der Åber (!I)ACSpro(!i) informiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSblk

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeiger auf die globalen (!I)ACSpro(!i)-Variablen

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 Ablk *ACSblk;

 !item [Pascal:]            ACSblk: AblkPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Ab (!I)ACSpro(!i) der Version 2.00 sind alle Variablen Komponenten der
Struktur Ablk. Der Zeiger ACSblk zeigt auf eine solche Struktur. öber
diesen Zeiger sind alle globalen Variablen verfÅgbar.

Um Variablen, die schon in ACS 1.x existierten, mit kleinen
EinschrÑnkung verfÅgbar zu machen, wurden in der Header-Datei ACS.H
Macros definiert. Dadurch ist es leicht, Projekte von ACS 1.x nach 2.x
zu konvertieren. Entfernt man das Makro __ACS1__ aus ACS.H, kînnen
diese Makros in C nicht mehr verwendet werden. In C dÅrfen alter und
neuer Stil nicht gemischt werden, da der Preprozessor diese nicht
unterscheiden kann.

(!B)Hinweis:(!b) (!I)Generell sollte allerdings im "neuen Stil" Åber den Zeiger
ACSblk auf die Variablen zugegriffen werden.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Ablk, AblkPtr
!end_enumerate

!end_node


!begin_node ACSbutton

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!link [Protokoll] [Protokoll])- & Filter-Routine fÅr Mausklicks

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSbutton)( int16 *button, int16 *kreturn);

 !item [Pascal:]            ACSbutton: Procedure( Var button, kreturn: Integer);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSbutton verweist, wird vor
der Bearbeitung der GEM-Maustasten aufgerufen. Im (!I)ACSpro(!i)-(!I)GUI-Editor(!i)
kann eine eigene Routine eingetragen werden. Man kann diese verwenden
um Tasten zu protokollieren oder zu filtern. Um zu filtern mÅssen die
Werte geeignet verÑndert werden.

Die Defaultroutine tut nichts.

'button' enthÑlt die Bitmaske der gedrÅckten Maustasten, 'kreturn'
enthÑlt die Anzahl der Klicks (siehe auch evnt_button). Die
Mauspositionen befinden sich im ACSblk.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSclose

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beenden der Anwendung

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSclose)( void );

 !item [Pascal:]            ACSclose: Procedure;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSclose verweist, wird vom
puren Desktop aufgerufen, wenn der MenÅpunkt 'Beenden' angewÑhlt
wurde. Im (!I)ACSpro(!i)-(Builder) kann eine eigene Routine eingetragen
werden, die z.B. zuvor eine Sicherheitsabfrage durchfÅhrt.

Die Default-Routine Routine ruft ihrerseits Aev_quit auf - dies sollte
eine eigene Routine am Ende auch machen, um (!I)ACSpro(!i) zur Beendigung der
Anwendung zu veranlassen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSerror

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Fehler-Routine zur Ausgabe von Fehlern

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSerror)( int16 mess, void *para );

 !item [Pascal:]            ACSerror: Procedure( mess: Integer; para: Pointer);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSerror verweist, wird zur
Ausgabe von aufgetretenen Fehlern verwendet.

Alle (!I)ACSpro(!i)-Programme oder Module sollten Åber diese Routine und den
Standard-Fehlernummern ihre Fehler-meldungen ausgeben! Normalerweise
ist dafÅr die leistungsfÑhige Routine Ash_error zustÑndig, die man
sauber Åber ACSblk aufrufen sollte.

In 'mess' wird eine Fehlernummer kodiert, der optionale Parameter
'para' kann auf weitere Daten zeigen, die man bei eigenen Nummern
anzeigen lassen mîchte. Wenn man eine eigene Routine stattdessen
benutzen will - z.B. weil man eigene Fehlernummern sauber ausgeben
mîchte - sollte man sich Åber ACSblk einklinken.

Dies geschieht beispielsweise in Pure-C Åber

     ACSblk->ACSerror = my_error_call;

In Pure-Pascal geschieht dies beispielsweise durch

     ACSblk^.ACSerror := my_error_call;

Die Routine 'my_error_call' sollte dann derart vorgehen, daû nur die
eigenen Fehlernummern ausgewertet werden, ansonsten sollte dann direkt
Ash_error angesprungen werden - andere Module verlassen sich darauf!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, Ash_error
!end_enumerate

!end_node


!begin_node ACSGEMScript

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Generelle GEMScript-Kommandos verarbeiten

 !item [Kategorie:]         (!link [Variablen] [Die Variablen]), GEMScript-Protokoll

 !item [C:]                 int16 (*ACSGEMScript)( int16 anz, char **cmd,
                             A_GSAntwort *antwort )

 !item [Pascal:]            ACSGEMScript: Function(
                                         anz: Integer; cmd: Pointer;
                                         antwort: A_GSAntwortPtr
                                      ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSGEMScript verweist, wird
Bearbeitung von GEMScript-Kommandos verwendet. Die Default-Funktion
heiût Aev_GEMScript.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item GEMScript-Protokoll
!end_enumerate

!end_node


!begin_node ACSinit

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Initialisierung der Anwendung

 !item [Kategorie:]         Die Variablen, Funktions-Zeiger

 !item [C:]                 int16 ACSinit( void );

 !item [Pascal:]            Function ACSinit : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion ACSinit (!B)muss(!b) selbst programmiert werden. Zu diesem
Zeitpunkt ist von (!I)ACSpro(!i) aus schon alles initialisiert.

öblicherweise werden Fenster angelegt, gegebenfalls geîffnet und die
Reaktion auf das (!I)Neu(!i)-Symbol festgelegt. Danach wird in die
(Event-)Hauptschleife gesprungen. RÅckgabewerte sind OK und FAIL. Bei
FAIL wird die Applikation beendet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSinit0

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Initialisierungen (!I)vor(!i) der Initialisierung des
                    (!I)ACSpro(!i)-Systems

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 (*ACSinit0)( void );

 !item [Pascal:]            ACSinit0: Function : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion ACSinit0 wird nach der Initialisierung der AES, der VDI-
Variablen und der Pfade durchlaufen. Das Rootfenster ist noch nicht
initialisiert. RÅckgabewerte sind OK und FAIL. Bei FAIL wird die
Applikation beendet. Im (!I)ACSpro(!i)-(!I)GUI-Editor(!i) kann eine eigene ROutine
eingetragen werden.

Die Defaultroutine macht einfach nichts.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSkey

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!link [Protokoll] [Protokoll])- & Filter-Routine fÅr TastendrÅcke

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSkey)( int16* kstate, int16* key );

 !item [Pascal:]            ACSkey: Procedure( Var kstate, key: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSkey verweist, wird vor
der Bearbeitung der GEM- TastendrÅcke aufgerufen. Es kann eine eigene
Routine eingetragen werden. Man kann sie verwenden um TastendrÅcke zu
protokollieren, zu filtern oder eine programmeigene Tastaturtabelle zu
implementieren. Die Tasten sind seid per NKCC codiert. Um zu filtern
mÅssen die Werte geeignet verÑndert werden.

Die Defaultroutine macht nichts.

(!B)Hinweis:(!b) Auch in modalen Dialogen wird diese Routine aufgerufen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, ACSwikey
!end_enumerate

!end_node


!begin_node ACSmessage

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Verarbeiten von Meldungen, die (!I)ACSpro(!i) unbekannt
                    sind

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSmessage)( int16 *ev_mmgpbuf );

 !item [Pascal:]            ACSmessage: Procedure( Var ev_mmgpbuff: ARRAY_8 );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSmessage verweist,
bearbeitet die GEM-Nachrichten, die (!I)ACSpro(!i) nicht kennt. Es kann eine
eigene Routine eingetragen werden.

Die Defaultroutine macht nichts.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, ACSmproto
!end_enumerate

!end_node


!begin_node ACSmoduleterm

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beednen eines ACS-Moduls

 !item [Kategorie:]         Modul-Programmierung

 !item [C:]                 void ACSmoduleterm( void );

 !item [Pascal:]            Die Funktion steht in Pure-Pascal nicht zur
                    VerfÅgung, da in Pure-Pascal leider keine Module
                    entwickelt werden kînnen.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion ACSmoduleterm existiert nur fÅr nachladbare Module. Nur
das Modul kann sich abmelden. Es muû selbst wissen ob dies zulÑssig.
Sollten Daten oder Programmcode noch anderweitig referenziert werden,
darf das Modul nicht abgemeldet werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Modul-Programmierung

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSmouse

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!link [Protokoll] [Protokoll])- & Filter-Routine fÅr Maus-Bewegungen

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSmouse)( void );

 !item [Pascal:]            ACSmouse: Procedure;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSmouse verweist, wird vor
der Bearbeitung der Maus-Bewegungen aufgerufen. Man kann sie verwenden
um Mausbewegungen zu protokollieren oder zu filtern. Um zu filtern
mÅssen die Werte geeignet verÑndert werden.

Die Werte befinden sich im ACSblk->ev_mmox und ACSblk->ev_mmoy.

Die Defaultroutine tut nichts.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSmproto

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!link [Protokoll] [Protokoll])- & Filter-Routine fÅr GEM-Nachrichten

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSmproto)( int16 *ev_mmgpbuf );

 !item [Pascal:]            ACSmproto: Procedure( Var ev_mmgpbuff: ARRAY_8 );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSmproto verweist, wird vor
der Bearbeitung der GEM-Nachrichten aufgerufen. Es kann eine eigene
Routine eingetragen werden. Man kann sie verwenden um Nachrichten zu
protokollieren, oder zu filtern. Um zu filtern mÅssen die Werte des
Feldes geeignet verÑndert werden.

Die Defaultroutine macht nichts.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, ACSmessage
!end_enumerate

!end_node


!begin_node ACSterm

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abschluû-Routine vor der Beendigung des Programmes

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSterm)( void );

 !item [Pascal:]            ACSterm: Procedure;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSterm verweist, wird
aufgerufen, bevor das Programm terminiert wird.

(!B)Wichtig:(!b) Dieser Aufruf wird von (!I)ACSpro(!i) getÑtigt. Das Programm ruft die
Routine (!B)nie(!b) direkt auf.

Die Defaultroutine macht einfach gar nichts.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACStimer

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abschluû-Routine vor der Beendigung des Programmes

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACStimer)( void );

 !item [Pascal:]            ACStimer: Procedure;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACStimer verweist, wird
jedesmal innerhalb der Hauptschleife aufgerufen. Der Aufruf ist von
Awi_update(BEG_UPDATE) umschlossen.

Die Defaultroutine macht nichts.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, ACSmproto
!end_enumerate

!end_node


!begin_node ACSwikey

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!link [Protokoll] [Protokoll])- & Filter-Routine fÅr TastendrÅcke an
                    Fenster

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*ACSwikey)( int16* kstate, int16* key );

 !item [Pascal:]            ACSwikey: Procedure( Var kstate, key: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion, auf die der Funktionszeiger ACSwikey verweist, wird nach
Auswertung der Tastencodes fÅr MenÅ und Objekt aufgerufen, aber vor
Aufruf von Awindow.keys durchlaufen. Es kann eine eigene Routine
eingetragen werden. Man kann sie verwenden um TastendrÅcke an den
Dialog zu protokollieren, zu filtern oder eine programmeigene
Tastaturtabelle zu implementieren. Die Tasten sind per NKCC codiert.
Um zu filtern mÅssen die Werte geeignet verÑndert werden.

Die Defaultroutine macht nichts.

(!B)Hinweis:(!b) Auch in modalen Dialogen wird diese Routine aufgerufen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, ACSkey
!end_enumerate

!end_node


!begin_node Adescr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Initialisierungsstruktur von (!I)ACSpro(!i)

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   char magic[8];
   int16 version;
   int16 dx, dy;
   int16 flags;
   char acc_reg[32];
   Awindow *root;
   Awindow *acc;
   Amouse mouse[32];
} Adescr;
!end_sourcecode

 !item [Pascal:]    
!begin_sourcecode
Adescr = RECORD
   magic: packed array [0..7] of char;
   version: Integer;
   dx, dy: Integer;
   flags: Integer;
   acc_reg: packed array [0..31] of char;
   root: AwindowPtr;
   acc: AwindowPtr;
   mouse: Array [0..31] of Amouse;
END;
!end_sourcecode

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Structur Adescr ist die Initialisierungsstruktur von (!I)ACSpro(!i). Die
Komponenten der Struktur bedeuten

!begin_xlist [version]
!label Adescr.magic
 !item [magic]     Name der (!I)ACSpro(!i)-Library.

!label Adescr.version
 !item [version]   Versionsnummer des (!I)ACSpro(!i).

!label Adescr.dx
!label Adescr.dy
 !item [dx, dy]    Diese Werte in Zeichenpositionen beschreiben einen Rahmen
           um den Desktop. (!I)ACSpro(!i) verhindert, daû Fenster auûerhalb
           dieses Rahmens plaziert werden. Negative Werte geben an, um
           wieviele Zeichenpositionen Fenster aus dem Desktop
           herausragen kînnen.

!label Adescr.flags
 !item [flags]     Diese Flags steuern das allgemeine Verhalten. Es existieren
           folgende Konstanten: AB_CLICKMENU, AB_MOVIES, AB_ACUSTIC,
           AB_HIDEPOINTER, AB_CENTERDIALOG, AB_GDOSFONT,
           AB_SMARTREDRAW, AB_MENUFIRST, AB_NO3D, AB_LAZYEVAL,
           AB_NOMEMCHECK, AB_NOTRANSICON,

           !begin_xlist [Grow-/Shrink-Boxes]
            !item [Pulldown MenÅ (AB_CLICKMENU)] (!nl)
                             Dies gilt fÅr MenÅs in Fenstern und
                             erzwingt vom Anwender, daû er die
                             MenÅtitel anwÑhlen muû, bevor diese
                             herunterklappen.

            !item [Grow-/Shrink-Boxes (AB_MOVIES)] (!nl)
                             Das sind die Geisterrahmen, die einmal
                             eingeschaltet dann erscheinen, wenn
                             Fenster geîffnet werden.

            !item [Verstecke Maus (AB_HIDEPOINTER)] (!nl)
               verhindert bei lÑngeren Text, daû der
                             Mauszeiger unangenehm flimmert.

            !item [Fehler akustisch (AB_ACUSTIC)] (!nl)
                             meldet einige Fehler akustisch und nicht
                             optisch.

            !item [Zentriere Dialog (AB_CENTERDIALOG)] (!nl)
                            plaziert die Dialoge in der Mitte des
                             Bildschirms, sonst werden sie gestaffelt.

            !item [Lade GDOS-Fonts (AB_GDOSFONT)] (!nl)
              stellt alle Schriften des Systems zur
                             VerfÅgung, erfordert aber unter UmstÑnden
                             eine lÑngere Startphase des Programms.

            !item [Taste zuerst MenÅ (AB_MENUFIRST)] (!nl)
             erzwingt die Verarbeitung von Tasten im
                             MenÅbaum vor dem Work-Objektbaum.
            !end_xlist

!label Adescr.acc_reg
 !item [acc_reg]   Hier steht der Text, der bei Accessories in der MenÅleiste
           registriert wird.

!label Adescr.root
 !item [root]      Zeigt auf die Fensterstruktur des Rootfensters. In der
           PASCAL-Version steht NIL fÅr den generischen Desktop
           DESKTOP.

!label Adescr.acc
 !item [acc]       Im Accessorybetrieb kann ein vom Rootfenster abweichendes
           Fenster gewÑhlt werden. Sonst ist NULL bzw. NIL
           einzutragen.

!label Adescr.mouse
 !item [mouse]     Hier sind die 32 Mausformen der Palette eingetragen.
!end_xlist

!end_node


!begin_node Adr_add

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objekt in die Auswahlliste aufnehmen

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 void Adr_add( Awindow *window, const int16 obnr );

 !item [Pascal:]            Procedure Adr_add( window: (!link [AwindowPtr] [AwindowPtr]); obnr:
                    Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_add nimmt das Objekt obnr aus dem Arbeitsobjekt in
die Auswahlliste auf. Wenn das neue Objekt zu einem anderen Fenster
als die bisherigen gehîrt, wird die Liste zuvor gelîscht. Die Routine
versetzt das neue Objekt in den Status (!I)SELECTED(!i) und sorgt fÅr die
Auffrischung des Bildschirms. Dem Fenster wird die Nachricht
AS_SELECTADD zugesandt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen

  !item Adr_del, Adr_unselect
!end_enumerate

!end_node


!begin_node Adr_box

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein Rechteck aufziehen und Objekte in Auswahlliste
                    Åbernehmen

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 void Adr_box( int16 x, int16 y );

 !item [Pascal:]            Procedure Adr_box( x, y: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_box zieht ein Rechteck an den Koordinaten auf. Alle
tangierten Objekte werden in die Auswahlliste Åbernommen. Wird
gleichzeitig die SHIFT-Taste gedrÅckt, bleiben die bisher ausgewÑhlten
Objekte in der Liste. Der Aufsetzpunkt bestimmt das Fenster. WÑhrend
des Aufziehens nimmt die Maus den Mausformindex 2 (defaultmÑûig die
zeigende Hand) an.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen
!end_enumerate

!end_node


!begin_node Adr_del

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objekt aus der Auswahlliste herausnehmen

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 void Adr_del( Awindow *window, const int16 obnr );

 !item [Pascal:]            Procedure Adr_del( window: (!link [AwindowPtr] [AwindowPtr]); obnr:
                    Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_del entfernt das Objekt obnr des Arbeitsobjektes aus
der Auswahlliste. Das (!I)SELECTED(!i)-Flag wird gelîscht und der Bildschirm
wird aufgefrischt. Dem Fenster wird die Nachricht AS_SELECTDEL
zugesandt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen

  !item Adr_add, Adr_unselect
!end_enumerate

!end_node


!begin_node Adr_drag

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Objekte der Auswahlliste ziehen ("draggen")

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 void Adr_drag( int16 x, int16 y );

 !item [Pascal:]            Procedure Adr_drag( x, y: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_drag beginnt das Ziehen der Objekte aus der
Auswahlliste an den Koordinaten x, y. Wenn Åber einem annehmenden
Objekt der Mausknopf losgelassen wird, wird dessen drag-Routine
aufgerufen. Sonst bewegen sich die Objekte auf ihren Ursprung zurÅck.
WÑhrend des Ziehens nimmt die Maus den Mausformindex 3 (defaultmÑûig
die schiebende Hand) an.

Das Ziehen kann konfiguriert werden. Dazu wird zu Beginn dem Fenster,
dem die Objekte gehîren, die Nachricht AS_CONFIGDRAG zugesandt. Bei
annehmenden Objekten, die also das Flag (!link [AO_ACCEPT] [AO_ACCEPT]) gesetzt haben, wird
dem empfangenden Fenster die Nachricht AS_CHECKDRAG zugesandt. Es kann
damit das Annehmen vor einer visuellen Reaktion verweigern!

Zum Beispiel nimmt der Papierkorb im DESKTOP das Neu-Ikon nicht an!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen
!end_enumerate

!end_node


!begin_node Adr_next

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NÑchste zu bearbeitende Objekt-Nummer

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 int16 Adr_next( void );

 !item [Pascal:]            Function Adr_next : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_next gibt die nÑchste Objektnummer der Auswahlliste
zurÅck. Vor dem ersten Aufrufen muû durch Adr_start initialisiert
werden. Diese Routine beachtet zwischen zwei Adr_next erfolgte
Adr_del-Aufrufen. Ist kein weiteres Element in der Liste, wird der
Wert -1 zurÅckgegeben.

Wenn das Objekt aus der Toolbar stammt, ist der RÅckgabewert per OR
mit (!link [A_TOOLBAR] [A_TOOLBAR]) verkÅpft worden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen

  !item Adr_start, Adr_del
!end_enumerate

!end_node


!begin_node Adr_start

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abfrage der Auswahlliste initialisieren

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 int16 Adr_start( void );

 !item [Pascal:]            Function Adr_start : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_start initialisiert die Abfrage der Auswahlliste. Das
nÑchste Erfragen mit Adr_next gibt das erste Objekt zurÅck

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen

  !item Adr_next
!end_enumerate

!end_node


!begin_node Adr_unselect

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Alle Objekte aus der Auswahlliste herausnehmen

 !item [Kategorie:]         Zieh-Operationen

 !item [C:]                 void Adr_unselect( void );

 !item [Pascal:]            Procedure Adr_unselect;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Adr_unselect entfernt alle Objekte aus der Auswahlliste.
Die Objekte werden ohne den Status (!I)SELECTED(!i) gezeichnet. Dem Fenster
wird die Nachricht AS_SELECTDEL mit dem Parameter (!I)NULL(!i) bzw. (!I)NIL(!i)
zugesandt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Zieh-Operationen

  !item Adr_add, Adr_del
!end_enumerate

!end_node


!begin_node AESglobal

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das initialisierte 'global'-Feld der AES

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 *AESglobal;

 !item [Pascal:]            AESglobal: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable AESglobal zeigt auf das initialisierte 'global'-Feld,
welches bei appl_init gefÅllt wird. Darin werden Werte wie
Versionnummern und Anzahl paralleler Prozesse eingetragen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node Aev_AcCopy

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Hilfe-Seite ins Klemmbrett kopieren

 !item [Kategorie:]         PureC-Hilfe-Protokoll

 !item [C:]                 int16 Aev_AcCopy( char *help_acc,
                             Awindow *window );

 !item [Pascal:]            Function Aev_AcCopy(
                                   help_acc, referenz: Pointer;
                                   window: (!link [AwindowPtr] [AwindowPtr])
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_AcCopy versucht, die aktuelle Hilfe-Seite vom PureC-
Hilfe-Accessory in das Klemmbrett kopieren zu lassen.

Wenn die Hilfeanforderung korrekt abgesendet werden konnte, so wird
TRUE zurÅckgegeben, andernfalls FALSE.

Wenn ein Fenster Åbergeben wird, so wird diesem bei Eintreffen der
Antwort vom Accessory die Nachricht AS_PC_VERSION gesandt.

In help_acc kann ein Hilfe-Accessory vorgegeben werden. Wird das
Åbergebene Accessory nicht gefunden oder ist der Zeiger NULL bzw. NIL,
so wird zunÑchst nach der PureC-Hilfe (PC_HELP.ACC), dann nach dem
ST-Guide gesucht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item PureC-Hilfe-Protokoll
!end_enumerate

!end_node


!begin_node Aev_AcHelp

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Hilfe-Seite Åber das PureC-Hilfe-Protokoll
                    anzeigen

 !item [Kategorie:]         PureC-Hilfe-Protokoll

 !item [C:]                 int16 Aev_AcHelp( char *help_acc,
                             char *referenz, Awindow *window );

 !item [Pascal:]            Function Aev_AcHelp(
                                   help_acc, referenz: Pointer;
                                   window: (!link [AwindowPtr] [AwindowPtr])
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_AcHelp versucht, eine Hilfe-Seite zur Åbergebenen
Referenz anzeigen zu lassen.

Wenn die Hilfeanforderung korrekt abgesendet werden konnte, so wird
TRUE zurÅckgegeben, andernfalls FALSE.

Wenn ein Fenster Åbergeben wird, so wird diesem bei Eintreffen der
Antwort vom Accessory die Nachricht AS_PC_VERSION gesandt.

In help_acc kann ein Hilfe-Accessory vorgegeben werden. Wird das
Åbergebene Accessory nicht gefunden oder ist der Zeiger NULL bzw. NIL,
so wird zunÑchst nach der PureC-Hilfe (PC_HELP.ACC), dann nach dem
ST-Guide gesucht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item PureC-Hilfe-Protokoll
!end_enumerate

!end_node


!begin_node Aev_AcVersion

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Versionsnummer des PureC-Hilfe-Accessories
                    ermitteln

 !item [Kategorie:]         PureC-Hilfe-Protokoll

 !item [C:]                 int16 Aev_AcVersion( char *help_acc,
                             Awindow *window );

 !item [Pascal:]            Function Aev_AcVersion(
                                   help_acc: Pointer; window:
                    (!link [AwindowPtr] [AwindowPtr])
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_AcVersion versucht, die Versionsnummer des PureC-
Hilfe-Accessories zu ermitteln.

Wenn die Hilfeanforderung korrekt abgesendet werden konnte, so wird
TRUE zurÅckgegeben, andernfalls FALSE.

Wenn ein Fenster Åbergeben wird, so wird diesem bei Eintreffen der
Accessory-Antwort die Nachricht AS_PC_VERSION gesandt.

Das bevorzugte Hilfe-Accessory kann hierbei in help_acc vorgegeben
werden. Falls das Åbergebene Accessory nicht gefunden wird oder der
Zeiger NULL bzw. NIL ist, so wird zunÑchst nach der PureC-Hilfe
(PC_HELP.ACC), dann nach dem ST-Guide gesucht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item PureC-Hilfe-Protokoll

  !item Aev_PCHelpVersion
!end_enumerate

!end_node


!begin_node Aev_DhstAdd

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dokument beim DHST-Server registrieren

 !item [Kategorie:]         DHST-Protokoll

 !item [C:]                 int16 Aev_DhstSaved( const char *file );

 !item [Pascal:]            Function Aev_DhstSaved( const char *file ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_DhstAdd registriert die Åbergebene Datei beim DHST-
Server (z.B. (!link [Start Me Up!] [Start Me Up!])). Dieser listet - sofern installiert -
system-global alle gespeicherten Dateien auf und erlaubt das schnelle
Bearbeiten einer der in der Liste enthaltenen Dateien.

Die beiden an Aev_DhstAdd Åbergebenen Strings werden zusammen mit
ACSblk->AppLongName und ACSblk->appname nach Kopieren in globalen
Speicher an den DHST-Server gesendet. Der RÅckgabewert gibt an, ob der
Versand erfolgreich (TRUE) war oder nicht (FALSE).

(!B)Hinweis:(!b) Die Åbergebenen Strings werden vor dem Versenden in globalen
Speicher kopiert, d.h. hier kînnen "ganz normal" Strings verwendet
werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item DHST-Protokoll

  !item (!xlink [] [Document-History-Protokoll])

  !item Aev_DhstSaved
!end_enumerate

!end_node


!begin_node Aev_DhstSaved

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Datei beim DHST-Server registrieren

 !item [Kategorie:]         DHST-Protokoll

 !item [C:]                 int16 Aev_DhstSaved( const char *file );

 !item [Pascal:]            Function Aev_DhstSaved( file: Pointer ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die FUnktion Aev_DhstSaved extrahiert als Dokumentnamen mittels
Af_2fullname den reinen Dateinamen und registriert mit diesem per
Aev_DhstAdd die Datei beim DHST-Server.

(!B)Hinweis:(!b) Die Åbergebenen Strings werden vor dem Versenden in globalen
Speicher kopiert, d.h. hier kînnen "ganz normal" Strings verwendet
werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item DHST-Protokoll

  !item (!xlink [] [Document-History-Protokoll])

  !item Aev_DhstAdd
!end_enumerate

!end_node


!begin_node Aev_GEMScript

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Generelle GEMScript-Kommandos verarbeiten

 !item [Kategorie:]         GEMScript-Protokoll

 !item [C:]                 int16 Aev_GEMScript( int16 anz, char **cmd,
                             A_GSAntwort *antwort );

 !item [Pascal:]            Function Aev_GEMScript(
                                   anz: Integer; cmd: Pointer;
                                   antwort: A_GSAntwortPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_GEMScript bearbeitet einige standardmÑûig in (!I)ACSpro(!i)
implementierte GEMScript-Kommandos. Diese sind

!begin_xlist [AppGetLongName]
 !item [AppGetLongName]  Gibt den Namen der Anwendung zurÅck. Dies wird aus
                 ACSblk->AppLongName genommen. Default ist hier der
                 Name aus ACSblk->basename.

 !item [CheckCommand]    PrÅft, ob das angegebene Kommando verstanden wird

 !item [GetAllCommands]  Liefert eine Liste der vom Fenster verstandenen
                 GEMScript-Kommandos zurÅck

 !item [GetFront]        Gibt den Namen des obersten Fensters zurÅck

 !item [KeyPress]        Simuliert einen Tastendruck

 !item [Quit]            Die Anwendung wird Åber Aev_quit beendet
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen, GEMScript-Protokoll
!end_enumerate

!end_node


!begin_node Aev_mess

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dringende GEM-Nachrichten (z.B. WM_REDRAW)
                    bearbeiten

 !item [Kategorie:]         Event-Support

 !item [C:]                 void Aev_mess( void );

 !item [Pascal:]            Procedure Aev_mess;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_mess bearbeitet anstehende GEM-Nachrichten. Sie wird
eingesetzt um Fenster vor der RÅckkehr zur Hauptschleife aufzufrischen
(Nachricht WM_REDRAW).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Event-Support
!end_enumerate

!end_node


!begin_node Aev_PCHelpVersion

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Versionsnummer des PureC-Hilfe-Protokoll ermitteln

 !item [Kategorie:]         PureC-Hilfe-Protokoll

 !item [C:]                 int16 Aev_PCHelpVersion( void );

 !item [Pascal:]            Function Aev_PCHelpVersion : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_PCHelpVersion liefert die zuletzt erhaltene
Versionsnummer des PureC-Hilfe-Accessories zurÅck. Falls diese nicht
existiert oder keine RÅckmeldung kam, so wird 0 geliefert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item PureC-Hilfe-Protokoll

  !item Aev_SendAcVersion
!end_enumerate

!end_node


!begin_node Aev_OlgaBreaklink

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen einer Datei an den OLGA-Manager melden

 !item [Kategorie:]         OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server])

 !item [C:]                 int16 Aev_OlgaBreaklink( const char *datei );

 !item [Pascal:]            Function Aev_OlgaBreaklink( datei: Pointer ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_OlgaBreaklink meldet dem OLGA-Manager, daû eine Datei
nicht mehr fÅr das OLGA-Protokoll zur VerfÅgung steht - z.B. weil sie
gelîscht wurde. Dieser informiert dann die evtl. vorhandenen Clients.

Der RÅckgabewert gibt an, ob die Nachricht an den OLGA-Manager
versandt werden konnte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server])

  !item OLGA_Info
!end_enumerate

!end_node


!begin_node Aev_OlgaIdle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Test der OLGA-Verbindung

 !item [Kategorie:]         OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server]), (!link [OLGA-Client] [OLGA-Client])

 !item [C:]                 int16 Aev_OlgaIdle( void );

 !item [Pascal:]            Function Aev_OlgaIdle : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_OlgaIdle prÅft eine bestehende OLGA-Verbindung.
Momentan hat dies keinerlei Auswirkungen.

Der RÅckgabewert gibt an, ob die Nachricht an den OLGA-Manager
versandt werden konnte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server]), (!link [OLGA-Client] [OLGA-Client])

  !item OLGA_Info
!end_enumerate

!end_node


!begin_node Aev_OlgaRename

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Umbenennen einer Datei an den OLGA-Manager melden

 !item [Kategorie:]         OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server])

 !item [C:]                 int16 Aev_OlgaRename( const char *old_datei,
                             const char *new_datei );

 !item [Pascal:]            Function Aev_OlgaRename(
                                   old_datei, new_datei: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_OlgaRename meldet ein Umbenennen einer Datei an den
OLGA-Manager. Dieser informiert dann die evtl. vorhandenen Clients. Es
steht im Ermessen jeder Anwendung, beim Sichern unter einem neuen
Dateinamen ein Umbenennen zu veranlassen (siehe Nachricht OLGA_RENAME
in der OLGA-Dokumentation).

Der RÅckgabewert gibt an, ob die Nachricht an den OLGA-Manager
versandt werden konnte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server])

  !item OLGA_Info
!end_enumerate

!end_node


!begin_node Aev_OlgaUpdate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Nach dem Speichern den OLGA-Manager verstÑndigen

 !item [Kategorie:]         OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server])

 !item [C:]                 int16 Aev_OlgaUpdate( const char *datei );

 !item [Pascal:]            Function Aev_OlgaUpdate( datei: Pointer ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_OlgaUpdate - oder noch besser Awi_saved - sollte nach
dem Speichern einer Datei als (!link [OLGA-Server] [OLGA-Server]) aufgerufen werden, um die
evtl. vorhandenen OLGA-Clients vom Update zu benachrichtigen. Wenn es
sich bei der angegebenen Datei um eine registrierte (!link [OLGA-Verbindung] [OLGA_Infos])
handelt, so werden die dort registrierten Angaben verwendet, ganz
besonders die Information Åber eine evtl. verfÅgbare Info-Datei (siehe
auch Nachricht OLGA_UPDATE in der OLGA-Dokumentation).

Der RÅckgabewert gibt an, ob die Nachricht an den OLGA-Manager
versandt werden konnte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item OLGA-Protokoll, (!link [OLGA-Server] [OLGA-Server])

  !item Awi_saved

  !item OLGA_Infos
!end_enumerate

!end_node


!begin_node Aev_quit

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beenden der Applikation

 !item [Kategorie:]         Event-Support

 !item [C:]                 void Aev_quit( void );

 !item [Pascal:]            Procedure Aev_quit;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_quit veranlaût das Beenden der Applikation. Nach der
RÅckkehr zur Hauptschleife wird diese beendet.

Typischerweise wird diese Funktion als Klick-Routine fÅr den
"Beenden"-Eintrag im HauptmenÅ verwendet.

(!B)Hinweis:(!b) Die Anwendung sollte Åber Aev_quit() beendet werden. Das
Terminieren der Anwendung wird daraufhin von (!I)ACSpro(!i) gesteuert
durchgefÅhrt, jedem Fenster (!B)auûer(!b) dem Root-Fenster (normalerweise der
pure Desktop) wird die Nachricht AS_TERM gesandt. Erst wenn alle
Fenster beendet sind, wird das Root-Fenster beendet. (!I)Wenn das
Terminieren der Fenster selbst veranlaût wird, so wird i.A. das Root-
Fenster zu frÅh gelîscht, es gibt also beim Zugriff auf das nicht mehr
existierende Fenster alle Varianten von (!link [Fehlermeldung] [Fehlermeldung]) bis zu
AbstÅrzen!(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Event-Support
!end_enumerate

!end_node


!begin_node Aev_release

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Auf das Loslassen der Maustasten warten

 !item [Kategorie:]         Event-Support

 !item [C:]                 void Aev_release( void );

 !item [Pascal:]            Procedure Aev_release;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_release wartet so lange, bis die Maustasten
losgelassen wurden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Event-Support
!end_enumerate

!end_node


!begin_node Aev_STGuideHelp

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Hilfe-Seite einer ST-Guide-Hilfe anzeigen lassen

 !item [Kategorie:]         ST-Guide-Protokoll

 !item [C:]                 int16 Aev_STGuideHelp( char *hyp_text,
                             char *referenz, Awindow *window )

 !item [Pascal:]            Function Aev_STGuideHelp(
                                   hyp_text, referenz: Pointer;
                                   window: (!link [AwindowPtr] [AwindowPtr])
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_STGuideHelp versucht, eine Hilfe-Seite zur
Åbergebenen Referenz in der optional angegebenen Datei anzeigen zu
lassen. Wenn die Hilfeanforderung korrekt an den ST-Guide abgesendet
werden konnte, so wird TRUE zurÅckgegeben, andernfalls FALSE.

Wenn ein Fenster Åbergeben wird, so wird diesem bei Eintreffen der
Antwort vom Accessory die Nachricht AS_PC_VERSION gesandt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item ST-Guide-Protokoll
!end_enumerate

!end_node


!begin_node Aev_unhidepointer

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Mauszeiger sichtbar machen

 !item [Kategorie:]         Event-Support

 !item [C:]                 void Aev_unhidepointer( void );

 !item [Pascal:]            Procedure Aev_unhidepointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_unhidepointer macht den wegen eines Tastendrucks
versteckten Mauszeiger wieder sichtbar.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Event-Support
!end_enumerate

!end_node


!begin_node Aev_WmRedraw

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Redraw-Nachricht verschicken

 !item [Kategorie:]         Externe Kommunikation

 !item [C:]                 int16 Aev_WmRedraw( const int16 dest_id,
                             const int16 wind_id, const Axywh *area );

 !item [Pascal:]            Function Aev_WmRedraw(
                                   dest_id, wind_id: int16;
                                   Var area: Axywh
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aev_WmRedraw versendet eine Redraw-Nachricht fÅr den in
'area' Åbergebenen Bildschirm-Ausschnitt. Wenn das in 'wind_id'
Åbergebene Fenster-Handle negativ ist, wird durch form_dial das
Neuzeichnn aller betroffenen Fenster erzwungen. Da die AES auflaufende
Redraw-Nachrichten zusammenfassen, dÅrfte hierbei nichts flackern.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Externe Kommunikation
!end_enumerate

!end_node


!begin_node Af_2drv

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Laufwerksangabe aus Dateipfad extrahieren

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 int16 Af_2drv( const char *file );

 !item [Pascal:]            Function Af_2drv( file: Pointer ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_2drv analysiert das Laufwerk, das in 'file' angegeben
wurde - ist dies nicht in der Dateiangabe vorhanden wird das aktuelle
Laufwerk ermittelt. RÅckgabewert ist analog zu Dgetdrv.

Beispielsweise wird fÅr Af_2drv("D:\TEMP\READ_ME.TXT") der Wert 3
geliefert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_buildname, Af_2ext, Af_2fullname, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_2ext

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dateityp aus Dateipfad extrahieren

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_2ext( char *dest, const char *file );

 !item [Pascal:]            Function Af_2ext( dest, file: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_2ext ermittelt aus der Dateiangabe in 'file' wird der
abschlieûende Dateityp und legt ihn in 'dest' ab. Konnte kein Dateityp
erkannt werden, wird ein Leerstring abgelegt. Die RÅckgabe ist der
Zeiger auf 'dest'.

Zum Beispiel steht nach Af_2ext(dest, "D:\TEMP\READ_ME.TXT") in dest
der String "TXT".

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_buildname, Af_2drv, Af_2fullname, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_2fullname

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dateinamen incl. Suffix aus Dateipfad extrahieren

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_2fullname( char *dest, const char *file);

 !item [Pascal:]            Function Af_2fullname( dest, file: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_2fullname ermittelt aus der Dateiangabe in 'file' den
abschlieûenden Dateinamen inklusive des Typs und legt ihn in 'dest'
ab. Konnte kein Name erkannt werden, wird ein Leerstring abgelegt. Die
RÅckgabe ist der Zeiger auf 'dest'.

Zum Beispiel steht nach Af_2fullname(dest, "D:\TEMP\READ_ME.TXT") in
dest der String "READ_ME.TXT".

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_buildname, Af_2drv, Af_2ext, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_2name

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Reinen Dateinamen aus Dateipfad extrahieren

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_2name( char *dest, const char *file );

 !item [Pascal:]            Function Af_2name( dest, file: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_2name ermittelt aus der Dateiangabe in 'file' den
abschlieûenden Dateinamen und legt ihn in 'dest' ab. Konnte kein Name
erkannt werden, wird ein Leerstring abgelegt. Die RÅckgabe ist der
Zeiger auf 'dest'.

Zum Beispiel steht nach Af_2name(dest, "D:\TEMP\READ_ME.TXT") in dest
der String "READ_ME".

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_buildname, Af_2drv, Af_2ext, Af_2fullname, Af_2path
!end_enumerate

!end_node


!begin_node Af_2path

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Pfadangabe aus Dateipfad extrahieren

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_2path( char *dest, const char *file );

 !item [Pascal:]            Function Af_2path(dest, file: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_2path extrahiert aus der Angabe in 'file' den Pfad und
legt ihn in 'dest' ab. Wird kein Pfad erkannt, steht in dest "\". Die
RÅckgabe ist der Zeiger auf 'dest'.

Zum Beispiel steht nach Af_2path(dest, "D:\TEMP\READ_ME.TXT") in dest
der String "\TEMP\".

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_buildname, Af_2drv, Af_2ext, Af_2fullname, Af_2name
!end_enumerate

!end_node


!begin_node Af_buildname

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Absoluten Dateipfad zusammensetzen

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_buildname(
                                char *dest, int16 drv,
                                const char *path, const char *name,
                                const char *ext
                             );

 !item [Pascal:]            Function Af_buildname( dest: Pointer; drv: Integer;
                                   path, name, ext: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_buildname baut aus den Angaben von 'drv', 'path',
'name' und 'ext' eine absolute Dateiangabe auf, die in 'dest' abgelegt
wird. Die RÅckgabe ist der Zeiger auf 'dest'.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_2drv, Af_2ext, Af_2fullname, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_cfgfile

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dateinamen zu Dateipfad einer Cfg-Datei ergÑnzen

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_cfgfile( char *file );

 !item [Pascal:]            Function Af_cfgfile( file: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_cfgfile ergÑnzt den Åbergebenen Dateiname zu einem
vollstÑndigen Pfadnamen fÅr eine Konfigurationsdatei. Dazu wird der
cfg_path ausgewertet, der in der Initialisierungsphase einer jeden
(!I)ACSpro(!i)-Applikationen ermittelt wird. Ist dieser Pfad leer, wird
scrp_path ausgewertet, ist auch dieser nicht vorhanden, setzt (!I)ACSpro(!i)
das aktuelle Root-Verzeichnis ein.

FÅr Af_cfgfile ("DESKTOP") wird beispielsweise "C:\HOME\DESKTOP.CFG"
zurÅckgeliefert.

(!B)Achtung:(!b) Da intern ein statischer Puffer verwendet wird, ist diese
Funktion momentan noch nicht multithreading-fest!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen
!end_enumerate

!end_node


!begin_node Af_fileselect

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine Datei Åber die Dateiauswahlbox auswÑhlen
                    lassen

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 ULinList *Af_fileselect( char *title, char *path,
                                char *ext, int16 sort_mode,
                                int16 multi, Awindow *window );

 !item [Pascal:]            Function Af_fileselect(
                                   title, path, ext: Pointer;
                                   sort_mode, multi: Integer;
                                   window: (!link [AwindowPtr] [AwindowPtr])
                                ) : ULinListPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_fileselect ruft den Fileselector auf. Der Parameter
multi gibt an, ob mehrere Dateien selektiert werden kînnen (TRUE) oder
nicht (FALSE). öber window wird angegeben, ob der modale (window=NULL)
oder der nicht-modale Fileselector (window!=NULL) verwendet werden
soll.

!begin_xlist [sort_mode]
 !item [title]      enthÑlt Titelzeile des File-Selectors

 !item [path]       ist Pfad und Dateiname der auszuwÑhlenden Datei (bitte in
            der Form "C:\abc\file.dat" Åbergeben). Der Dateiname kann
            leer sein, dann wird der Pfad voreingestellt.

 !item [ext]        enthÑlt Liste der Extensionen (Dateiendungen), die fÅr die
            Auswahl zugelassen sind (s.u.).

 !item [sort_mode]  gibt die Sortierung bei Verwendung der FSLX-Funktionen
            an (Der Parameter wird vei RÅckgriff auf Af_select bzw.
            Af_first_fsel und Af_next_fsel ignoriert.).

 !item [multi]      gibt an, ob mehrere Dateien ausgewÑhlt werden kînnen
            (=TRUE) - sofern das System dies unterstÅtzt - oder ob nur
            eine Datei ausgewÑhlt werden kann (=FALSE)

 !item [window]     enthÑlt entweder NULL bzw. NIL fÅr den modalen File-
            Selector oder ein Fenster, an das der nicht-modale File-
            Selector die ausgewÑhlten Dateien per Nachricht
            AS_FILESELECT melden soll.
!end_xlist

(!B)Hinweis:(!b) Die Funktion verwendet folgende Strategie:

!begin_itemize
   !item Wenn die FSLX-Funktionen (MagiC) zur VerfÅgung stehen, werden
     diese Åber die Funktion Ash_fileselect genutzt

   !item Andernfalls wird, je nach Parameter multi, entweder Af_select
     oder die Kombination Af_first_fsel und Af_next_fsel verwendet.
!end_itemize

Der RÅckgabewert ist eine lineare Liste der gewÑhlten Dateinamen. Der
Wert NULL signalisiert einen Fehler.

Diese Liste kann auch leer sein. Dann ist entweder 'Abbruch'
ausgewÑhlt worden oder der nicht-modale Fenster-Dialog wurde geîffnet.

Beim Aufruf des nicht-modalen Fileselectors wird stets eine leere
Liste zurÅckgegeben. Eine lineare Liste der gewÑhlten Dateien - oder
NULL im Fehlerfalle - wird dann dem Åbergebenen Fenster mittels der
Nachricht AS_FILESELECT gesandt.

(!B)Hinweis:(!b) Die lineare Liste, die von Af_fileselect geliefert wird, muû
wie bie allen Funktionen, die eine lineare Liste zurÅckgeben, vom
Aufrufer per Alu_delete gelîscht werden! Die per AS_FILESELECT vom
nicht-modalen Fileselector gemeldete Liste wird jedoch automatisch von
(!I)ACSpro(!i) freigegeben.

(!B)Wichtig:(!b) Die folgenden Punkte sind fÅr die Angabe der Extensionen
wichtig:

!begin_itemize
   !item Die zu verwendenden Extensionen kînnen zu Gruppen
     zusammengestellt werden.

   !item Die Extensionen kînnen gruppiert werden, wobei die Gruppen
     verschiedene Alternativen darstellen, die vom Anwender aktiviert
     werden kînnen.

   !item Die Extensionen einer Gruppe werden mit ',' voneinander getrennt,
     die Gruppe wird mit einem Null-Byte '\0' abgeschlossen.

   !item Am Ende der Extensionsgruppen werden (!I)immer(!i) zwei Null-Bytes
     erwartet.

   !item Wenn die FSLX-Funktionen verfÅgbar sind, so werden sie
     aufbereitet und verwendet. Die erste Extensions-Gruppe wird
     voreingestellt, die weiteren kînnen alternativ vom Anwender
     aktiviert werden.

   !item Wenn die FSLX-Funktionen verfÅgbar sind, wird die Extension "*"
     zur Auswhl aller Dateien an das Ende angefÅgt, falls diese
     "Spezial-Extension" nicht bereits in einer der Extensionsgrppen
     auftaucht.

   !item Wenn keine FSLX-Funktionen vorhanden sind und die Dateiauswahl
     mittels Af_select bzw. Af_first_fsel und Af_next_fsel realisiert
     wird, so wird von der ersten Extensionsgruppe die erste Extension
     verwendet.

   !item Wenn keine gÅltige Extension vorhanden ist, wird "*" fÅr die
     FSLX-Funktionen und "*.*" fÅr Af_selet bzw. Af_first_fsel und
     Af_next_fsel verwendet.
!end_itemize

(!B)Beispiel:(!b) Der (!I)GUI-Editor(!i) Åbergibt zum ôffnen der ACS-Dateien den C-
String "ACS,acs\0RSC,rsc\0\0". Dies sind zwei Extensions-Gruppen. Die
erste Gruppe lÑût alle Dateien der Form "*.ACS" und "*.acs" zu, die
zweite Gruppe alle Dateien mit dem Muster "*.RSC", "*.rsc".

!begin_itemize
   !item Falls die FSLX-Funktionen verfÅgbar sind, werden drei Gruppen
     angelegt: "*.ACS,*.acs", "*.RSC,*.rsc" und "*".

   !item Falls auf die "alten" ;-) Funktionen zurÅckgegriffen wird, wird
     die Extension "*.ACS" verwendet.
!end_itemize

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Ash_fileselect, Af_first_fsel, Af_next_fsel, Af_select
!end_enumerate

!end_node


!begin_node Af_first

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die erste Datei eines Ordners ermitteln

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_first( const char *start, A_FileList
                    *fileinfo );

 !item [Pascal:]            Function Af_first( start: Pointer;
                                   fileinfo: (!link [A_FileListPtr] [A_FileListPtr])
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_first îffnet - bei Existenz - den Ordner 'start' und
ermittelt die erste Datei daraus. Dabei werden - sofern mîglich -
lange Dateinamen unterstÅtzt und keine Annahmen Åber die Groû-/
Kleinschreibung gemacht.

Bei einem Fehler (Ordner existiert nicht, keine Datei im Ordner) wird
NULL zurÅckgeliefert, sonst ein Zeiger auf die erste Datei.

(!B)Achtung:(!b) (!I)Da intern statische Daten verwendet werden mÅssen, kann diese
Funktion nicht multithreading-fest sein! Generell sollte die Funktion
Af_readdir bevorzugt werden!(!i)

(!B)Hinweis:(!b) Es sollten alle Dateien mit Af_next bearbeitet werden, da
intern Speicher angefordert wird der in Af_next am Ende der
Bearbeitung wieder freigegeben wird!

(!B)Hinweis:(!b) Diese Funktion ist nur noch aus KompatibilitÑtsgrÅnden
vorhanden und wird in einer der nÑchsten Versionen verschwinden, die
FunktionalitÑt wird dann komplett durch Af_readdir Åbernommen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_next, Af_readdir
!end_enumerate

!end_node


!begin_node Af_first_fsel

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Multi-Datei-Auswahl, RÅckgabe der ersten Datei

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_first_fsel( char *title, char *path,
                                   char *ext );

 !item [Pascal:]            Function Af_first_fsel(
                                   title, path, ext: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_first_fsel ermîglicht dem Anwender die
MultiDateiAuswahl, wobei der Aufruf vîllig analog zu Af_select
erfolgt. Der 'titel' wird ab TOS 1.04 oder bei SELECTRIC bzw. BoxKite
angezeigt. Die Anzeige wird auf Dateien vom Typ 'ext' eingegrenzt.
'path' sollte lang genug gewÑhlt werden (128 Zeichen), da darin der
gewÑhlte Dateiname abgelegt wird, er kann auch vorbelegt werden.

ZurÅckfgeliefert wird NULL bzw. NIL bei Abbruch, sonst der gÅltige
Zeiger auf 'path'. Wurden mehrere Dateien ausgewÑhlt, wird die erste
Datei zurÅckgeliefert, mit Af_next_fsel kînnen die restlichen Dateien
(bis zur RÅckgabe von NULL bzw. NIL) ermittelt werden.

(!B)Achtung:(!b) (!I)Da intern statische Daten verwendet werden mÅssen, kann diese
Funktion nicht multithreading-fest sein!(!i)

(!B)Hinweis:(!b) 'path' bitte in der Form "C:\abc\file.dat" Åbergeben.

(!B)Hinweis:(!b) Anstelle dieser Funktion sollte mîglichst Af_fileselect
verwendet werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item A_fileselect, Af_fileselect, Af_next_fsel, Af_select
!end_enumerate

!end_node


!begin_node Af_freedir

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dateiliste freigeben

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 void Af_freedir( A_FileList *list );

 !item [Pascal:]            Procedure Af_freedir( list: (!link [A_FileListPtr] [A_FileListPtr]) );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_freedir gibt die Dateiliste aus Af_readdir frei.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_readdir
!end_enumerate

!end_node


!begin_node Af_length

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Existenz und LÑnge einer Datei ermitteln

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 long Af_length( const char *file );

 !item [Pascal:]            Function Af_length( file: Pointer ) : Longint;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_length ermittelt die LÑnge von der Åbergebenen Datei.
Kann diese DateilÑnge oder der Ordner nicht ermittelt werden(!), wird
-2 zurÅckgeliefert.

Falls es sich um um einen Ordner handelt , wird -1 zurÅckgegeben.

Diese Funktion kann benutzt werden, um die Existenz einer Datei oder
eines Ordners festzustellen. Falls die Datei bzw. der Ordner
existiert, dann ergibt sich ein RÅckgabewert >=-1.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen
!end_enumerate

!end_node


!begin_node Af_next

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die jeweils nÑchste Datei eines Ordners ermitteln

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_next( A_FileList *fileinfo );

 !item [Pascal:]            Function Af_next( fileinfo: (!link [A_FileListPtr] [A_FileListPtr])) :
                    Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Nachdem eine Datei mit Af_first aus einem Ordner ausgelesen wurde,
kînnen mit der Funktion Af_next nacheinander alle weiteren Dateien
ermittelt werden.

Falls keine weitere Datei vorhanden ist, wird NULL bzw. NIL
zurÅckgeliefert.

(!B)Achtung:(!b) (!I)Da intern statische Daten verwendet werden mÅssen, kann diese
Funktion nicht multithreading-fest sein! Generell sollte die Funktion
Af_readdir bevorzugt werden!(!i)

(!B)Hinweis:(!b) Diese Funktion ist nur noch aus KompatibilitÑtsgrÅnden
vorhanden und wird in einer der nÑchsten Versionen verschwinden, die
FunktionalitÑt wird dann komplett durch Af_readdir Åbernommen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_first, Af_readdir
!end_enumerate

!end_node


!begin_node Af_next_fsel

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die jeweils nÑchste Datei nach eienr Multi-Datei-
                    Auswahl liefern

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_next_fsel( void );

 !item [Pascal:]            Function Af_next_fsel : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Nachdem die ersten Datei per Af_first_fsel ermittelt wurde (und nur
dann!), kînnen mit der Funktion Af_next_fsel alle weiteren,
ausgewÑhlten Dateien der MultiDateiAuswahl abgeholt werden.

ZurÅckgeliefert wird NULL bzw. NIL, wenn keine weitere Datei mehr
ursprÅnglich ausgewÑhlt wurde, sonst ein Zeiger auf diesen Namen.

(!B)Wichtig:(!b) Es sollte nicht nur aus KonsistenzgrÅnden, sondern auch um
den fÅr die MultiDateiAuswahl angeforderten Speicher wieder
freizugeben, alle Dateien mit dieser Funktion ausgelesen werden!

(!B)Achtung:(!b) (!I)Da intern statische Daten verwendet werden mÅssen, kann diese
Funktion nicht multithreading-fest sein!(!i)

(!B)Hinweis:(!b) Anstelle dieser Funktion sollte mîglichst Af_fileselect
verwendet werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item A_fileselect, Af_fileselect, Af_first_fsel, Af_select
!end_enumerate

!end_node


!begin_node Af_parseCmdLine

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die jeweils nÑchste Datei eines Ordners ermitteln

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 ULinList *Af_parseCmdLine( char *file_string )

 !item [Pascal:]            Function Af_parseCmdLine(
                                   file_string: Pointer
                                ) : ULinListPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_parseCmdLine liest eine Kommandozeile und legt die
einzelnen Parameter nacheinander in einer linearen Liste ab. Quoting
wird analog zu Af_unquote berÅcksichtigt.

Falls NULL bzw. NIL zurÅckgegeben wird, so ist ein Fehler aufgetreten.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_unquote
!end_enumerate

!end_node


!begin_node Af_quote

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen Dateinamen ggf. quoten

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_quote( char *dest, char *source );

 !item [Pascal:]            Function Af_quote( dest, source: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_quote bereitet den in 'source' Åbergebenen Dateinamen
in 'dest' so auf, daû er an andere Anwendungen Åbergeben werden kann -
z.B. per VA_START, Pexec o.Ñ.

Wenn im Åbergebenen Dateinamen  (dies schlieût den (optionalen) Pfad
ein) keine Leerzeichen, Tabulatoren oder Quote-Zeichen enthalten sind,
so wird der Åbergebene String nicht verÑndert.

(!B)Hinweis:(!b) Die Funktion ist speziell fÅr den Fall 'dest' gleich 'source'
optimiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_unquote
!end_enumerate

!end_node


!begin_node Af_readdir

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Liste aller Dateien bzw. Unterordner eines
                    Verzeichnisses erstellen

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 A_FileList *Af_readdir( char *start );

 !item [Pascal:]            Function Af_readdir( start: Pointer ) :
                    (!link [A_FileListPtr] [A_FileListPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_readdir stellt in einer Liste den Inhalt eines
Verzeichnisses zur VerfÅgung. Man erspart sich damit unnîtige Routinen
und Strukturen fÅr das Einlesen eines Ordners. Af_readdir verwendet,
sofern vorhanden, die Routinen Dopendir, Dclosedir und Dxreaddir (bzw.
Dreaddir und Fxattr, falls Dxreaddir nicht vorhanden).

Als RÅckgabewert wird der Zeiger auf das erste Listenelement
geliefert. Wenn ein Fehler auftrat, wird NULL bzw. NIL zurÅckgegeben.

Die Dateiliste sollte man zum Schluû mit Af_freedir freigeben.

(!B)Hinweis:(!b) Die Liste wird in einer der nÑchsten Versionen in eine
lineare, unsortierte Liste ULinList umgewandelt werden. Dadurch kann
eine wesentlich bessere Bearbeitung der Daten erreicht werden, da
ULinList einige komfortable Service-Routinen bietet, dies sofort
genutzt werden kînnen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_first, Af_freedir, Af_next
!end_enumerate

!end_node


!begin_node Af_select

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine Datei Åber die Dateiauswahlbox auswÑhlen
                    lassen

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_select( char *title, char *path, char
                    *ext );

 !item [Pascal:]            Function Af_select(
                                   title, path, ext: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_select îffnet die Dateiauswahlbox. Der Titel wird ab
Betriebssystemversion 1.04 oder mit SELECTRIC bez. BoxKite angezeigt.
Die Auswahl wird auf Dateien mit dem Typ 'ext' eingegrenzt, z.B.
'PRG', 'ACS'. 'path' wird um den gewÑhlten Namen der Datei ergÑnzt und
als Wert zurÅckgegeben. Bei 'Abbruch' wird NULL zurÅckgegeben. Ab
Version 2.2 kann auch nur ein Pfad gewÑhlt werden.

(!B)Wichtig:(!b) 'path' sollte groû genug dimensioniert sein um alle Pfade
aufnehmen zu kînnen (> 80 Bytes). Der (alte) Dateiname wird
automatisch entfernt

(!B)Hinweis:(!b) 'path' bitte in der Form "C:\abc\file.dat" Åbergeben.

(!B)Hinweis:(!b) Anstelle dieser Funktion sollte mîglichst Af_fileselect
verwendet werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item A_fileselect, Af_fileselect, Af_first_fsel, Af_next_fsel
!end_enumerate

!end_node


!begin_node Af_unquote

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen Dateinamen ggf. quoten

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 char *Af_unquote( char *dest, char *source );

 !item [Pascal:]            Function Af_unquote( dest, source: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Af_unquote stellt als GegenstÅck zu Af_quote den
Åbergebenen Dateinamen wieder her, falls dieser gequotet sein sollte.

Die Funktion Af_unquote bereitet den in 'source' Åbergebenen
Dateinamen - normalerweise per Kommandozeile oder VA_START erhalten -
in 'dest' auf, so daû er zum ôffnen der Datei verwendet werden kann.

Wenn nach der Entfernung fÅhrender Leerzeichen das erste Zeichen kein
Quote-Zeichen ist - im Moment sind dies die Zeichen " und ' -, so
bleibt der Dateiname unverÑndert. Andernfalls wird der Teilstring
zwischen dem Quote-Zeichen und dem zweiten Auftreten des Quote-
Zeichens nach 'dest' kopiert. Falls im Dateinamen Quote-Zeichen
enthalten sind, so mÅssen diese zweimal hintereinander stehen. DIes
wird zu einem QUote-Zeichen zusammengefaût.

(!B)Hinweis:(!b) Die Funktion ist speziell fÅr den Fall 'dest' gleich 'source'
optimiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Af_quote, Af_parseCmdLine
!end_enumerate

!end_node


!begin_node AGetObjText

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Datentyp fÅr die BubbleGEM-Hilfe (Nachricht
                    AS_GETBUBBLE)

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   int16 obnr;
   char *text;
} AGetObjText;
!end_sourcecode

 !item [Pascal:]    
!begin_sourcecode
AGetObjTextPtr = ^AGetObjText;
AGetObjText = Record
   obnr: Integer;
   text: Pointer;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

!end_node


!begin_node Aic_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen eines neuen Icons

 !item [Kategorie:]         Icon-Funktionen

 !item [C:]                 ICONBLK *Aic_create( const ICONBLK *icon );

 !item [Pascal:]            Function Aic_create( icon: ICONBLKPtr ) :
                    ICONBLKPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aic_create erzeugt eine Kopie des Icons. Die Bilddaten
werden (!B)nicht(!b) dupliziert, sondern nur referenziert. Der Text wird mit
Ast_create erzeugt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Icon-Funktionen

  !item Aic_delete

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Aic_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen eines Icons

 !item [Kategorie:]         Icon-Funktionen

 !item [C:]                 void Aic_delete( ICONBLK *icon );

 !item [Pascal:]            Procedure Aic_delete( icon : ICONBLKPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aic_delete gibt den Speicherplatz der ICONBLK-Struktur
wieder frei.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Icon-Funktionen

  !item Aic_create

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Aim_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen eines neuen Bildes

 !item [Kategorie:]         Image-Funktionen

 !item [C:]                 BITBLK *Aim_create( const BITBLK *bitblk );

 !item [Pascal:]            Function Aim_create( bitblock: BITBLKPtr ) :
                    BITBLKPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aic_create erzeugt eine Kopie des Bildes. Die
eigentlichen Bilddaten werden (!B)nicht(!b) dupliziert, sondern nur
referenziert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Image-Funktionen

  !item Aim_delete
!end_enumerate

!end_node


!begin_node Aim_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen eines Bildes

 !item [Kategorie:]         Image-Funktionen

 !item [C:]                 void Aim_delete( BITBLK *bitblock );

 !item [Pascal:]            Procedure Aim_delete( bitblock : BITBLKPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aim_delete gibt den Speicherplatz dieser BITBLK-Struktur
wieder frei.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Image-Funktionen

  !item Aim_create
!end_enumerate

!end_node


!begin_node alert_name

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Fenster-Titel fÅr modale Alert-Dialoge

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char *alert_name;

 !item [Pascal:]            alert_name: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable alert_name enthÑlt einen alternativen Fenster-Titel fÅr
die modalen Alert-Dialoge.

Damit in modalen Alert-Dialogen Awi_alert nicht nur die vorgegebenen
Fenstertitel erscheinen, kann man Åber die Variable (am besten
kurzfristig) einen Zeiger auf einen neuen Titel eintragen. Wenn hier
NULL bzw. NIL eingetragen ist, werden die bei Awi_alert vorbesetzten
Titel benutzt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, alert_str, Awi_alert
!end_enumerate

!end_node


!begin_node alert_str

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzeigen einer Alert-Box mit Parameter

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 alert_str( const char *alert, const char
                    *para );

 !item [Pascal:]            Function alert_str( alert, para: Pointer ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion alert_str zeigt eine Alarmbox Åber die Funktion Awi_alert
an. Der erste Knopf ist immer der Defaultknopf. Die Nummer des
ausgewÑhlten Knopfes wird zurÅckgegeben. Als Besonderheit wird die
Zeichenkombination '%s' durch den zweiten String 'para' ersetzt. Damit
kînnen auch Alarmboxen mit Texten, z.B. Dateinamen, parametrisiert
werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item Awi_alert, Awi_dialog, Awi_modal
!end_enumerate

!end_node


!begin_node Alu_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen einer linearen Liste

 !item [Kategorie:]         Unsortierte, doppelt verkettete, lineare Liste

 !item [C:]                 ULinList *Alu_create( void );

 !item [Pascal:]            Function Alu_create : ULinListPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Alu_create erzeugt eine lineare, doppelt verkettete Liste
und initialisiert die allozierte Struktur ULinList, die sie
zurÅckgibt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Unsortierte, doppelt verkettete, lineare Liste

  !item ULinList, Alu_delete
!end_enumerate

!end_node


!begin_node Alu_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen einer linearen Liste

 !item [Kategorie:]         Unsortierte, doppelt verkettete, lineare Liste

 !item [C:]                 void Alu_delete( ULinList *liste );

 !item [Pascal:]            Procedure Alu_delete( liste: ULinListPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Alu_delete lîscht eine mit Alu_create erzeugte lineare
Liste und versucht, die verwalteten Daten Åber die in
ULinList.freeElem referenzierte Funktion freizugeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Unsortierte, doppelt verkettete, lineare Liste

  !item ULinList, Alu_create
!end_enumerate

!end_node


!begin_node Akt_GetExportCount

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Maximalen Index der Export-Filter ermitteln

 !item [Kategorie:]         KEYTAB-Funktionen

 !item [C:]                 int16 Akt_GetExportCount( void );

 !item [Pascal:]            Function Akt_GetExportCount : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Akt_GetExportCount liefert den maximalen Index der
Export-Filter. Die Export-Filter wandeln Zeichen aus dem Atari-
Zeichensatz in andere ZeichensÑtze. Die Filter der Nummer
0..AktGetExportCount() (incl.) stehen zur VerfÅgung.

(!B)Hinweis:(!b) Falls KeyTab nicht zur VerfÅgung steht, wird als Ergebnis 0
geliefert. Die Konversions-Funktionen liefern in diesem Falle als
Ergebnis die EIngabe (also im Atari-Zeichensatz) zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item KEYTAB-Funktionen

  !item Akt_GetKeyTab
!end_enumerate

!end_node


!begin_node Akt_getKeyTab

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!link [Cookie] [Cookie Jar])-Struktur von KEYTAB liefern

 !item [Kategorie:]         KEYTAB-Funktionen

 !item [C:]                 KEYT *Akt_getKeyTab( void );

 !item [Pascal:]            Function Akt_getKeyTab : PKEYT;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Akt_getKeyTab liefert einen Zeiger auf die KEYTAB-
Struktur KEYT, die KEYTAB Åber einen (!link [Cookie] [Cookie Jar]) zur VerfÅgung stellt. Wenn
NULL bzw. NIL zurÅckgegeben wird, so ist der (!link [Cookie] [Cookie Jar]) entweder nicht
vorhanden (KEYTAB nicht installiert), oder der "magische Wert" in der
Struktur ist falsch, so daû die Struktur ungÅltig ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item KEYTAB-Funktionen
!end_enumerate

!end_node


!begin_node Ame_namefix

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anpassen der MenÅ-Titel

 !item [Kategorie:]         MenÅ-Funktionen

 !item [C:]                 void Ame_namefix( OBJECT *menu );

 !item [Pascal:]            Procedure Ame_namefix( menu: ACSTreePtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Positionen der MenÅtitel sind von der LÑnge der MenÅtexte
abhÑngig. Diese Routine paût diese Werte an und beachtet dabei die
realen, also um fÅhrende und abschlieûende Leerzeichen bereinigten
TextlÑngen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item MenÅ-Funktionen
!end_enumerate

!end_node


!begin_node Ame_popup

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objektbaum als Popup darstellen

 !item [Kategorie:]         MenÅ-Funktionen

 !item [C:]                 int16 Ame_popup( Awindow *window, OBJECT *popup,
                             int16 x, int16 y );

 !item [Pascal:]            Function Ame_popup(
                                   window: (!link [AwindowPtr] [AwindowPtr]); popup:
                    ACSTreePtr;
                                   x, y: Integer
                                ): Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ame_popup stellt ein Popup-MenÅ auf dem Bildschirm dar
und lÑût den Anwender einen Eintrag auswÑhlen. ZurÅckgegeben wird die
Objektnumer des ausgewÑhlten Popup-Eintrags.

Das Popup-MenÅ popup wird aufgerufen. Es werden die eingetragenen
click-Routinen gestartet. Alternativ kann der RÅckgabewert ausgewertet
werden. Dieser Modus ist fÅr einfache Ja/Nein- Entscheidungen
interessant.

(!I)Anmerkungen:(!i)

 x, y  beschreiben die Startposition des Popups. Alternative kann auch
       -1 angegeben werden, dann erscheint das Popup an der
       Mausposition.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item MenÅ-Funktionen
!end_enumerate

!end_node


!begin_node Ame_strpopup

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objektbaum als Popup darstellen

 !item [Kategorie:]         MenÅ-Funktionen

 !item [C:]                 char *Ame_strpopup( Awindow *window, char *pstr,
                             char *chk, int16 width, int16 x, int16 y);

 !item [Pascal:]            Function Ame_strpopup(
                                   window: (!link [AwindowPtr] [AwindowPtr]); pstr, chk:
                    Pointer;
                                   width, x, y: Integer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ame_strpopup stellt ein durch einen String beschriebenes
Popup-MenÅ auf dem Bildschirm dar und lÑût den Anwender einen Eintrag
auswÑhlen. ZurÅckgegeben wird der Teilstring des Åbergebenen Strings,
der mit dem ausgewÑhlten Popup-Eintrag Åbereinstimmt.

Das Popup-MenÅ wird durch den Åbergebenen String 'pstr' bestimmt.
EintrÑge werden durch '|' getrennt. SubmenÅs werden durch eckige
Klammern '[..]' beschrieben. Der erste Eintrag ist dann der Titel im
aufrufenden Popup. Diese Hierarchie kann beliebig geschachtelt werden.

char *erg;
char *popup="Rot|"
         "[Gelb|Fast Rot|normales Gelb|GrÅngelb]|"
         "[GrÅn|Aufpassen!|normale Fahrt|Vollgas]";

erg = Ame_strpopup(ACSblk->ev_window, popup, popup, 200, -1, -1);

stellt das folgende Popup dar:


!image (!IMAGES)img00734.img

Das Verhalten kann im (!I)GUI-Editor(!i) mit dem Userdef-Cycle getestet
werden.

(!I)Anmerkungen:(!i)

 chk   Der String 'chk' sollte ein Teilstring des 'pstr' sein. Der
       Popup-Eintrag, der mit 'chk' beginnt wird mit dem CHECKED-Flags
       gekennzeichnet. Wenn z.B. chk = pstr gilt, wird der erste
       Eintrag markiert.

 x, y  beschreiben die Startposition des Popups. Alternative kann auch
       -1 angegeben werden, dann erscheint das Popup an der
       Mausposition.

ZurÅckgegeben wird der Beginn des Teilstring von 'pstr', der gewÑhlt
wurde. Wenn nichts gewÑhlt wurde, wird NULL bzw. NIL zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item MenÅ-Funktionen
!end_enumerate

!end_node


!begin_node Amouse

!label AmousePtr
!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beschreibung der Mausform

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   int16 number;
   MFORM *form;
} Amouse;
!end_sourcecode

 !item [Pascal:]     
!begin_sourcecode
AmousePtr = ^Amouse;
Amouse = RECORD
   number: Integer;
   form: MFORMPtr;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Beschreibung der Mausform ist in dieser Struktur untergebracht.
Die Nummern 0 bis 7 bezeichnen die von den AES vordefinierten
Mausformen. Die Komponente form sollte in diesen FÑllen den Wert NULL
bzw. NIL annehmen. FÅr eigendefinierte Formen nimmt number den Wert
255 an. Dann muû form auf eine gÅltige Beschreibung der Mausform
zeigen.

!end_node


!begin_node Amo_busy

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wartende Mausform setzen ("Biene")

 !item [Kategorie:]         Mausoperationen

 !item [C:]                 void Amo_busy( void );

 !item [Pascal:]            Procedure Amo_busy;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Amo_busy setzt die wartende Mausform, normalerweise die
Biene. Die Anzahl der Aufrufe wird mitgezÑhlt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Mausoperationen

  !item Amo_unbusy
!end_enumerate

!end_node


!begin_node Amo_hide

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Maus-Zeiger verstecken bzw. ausschalten

 !item [Kategorie:]         Mausoperationen

 !item [C:]                 void Amo_hide( void );

 !item [Pascal:]            Procedure Amo_hide;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Amo_hide versteckt den Maus-Zeiger.

(!I)Die Anzahl der Aufrufe wird mitgezÑhlt.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Mausoperationen

  !item Amo_show
!end_enumerate

!end_node


!begin_node Amo_new

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Maus-Form setzen

 !item [Kategorie:]         Mausoperationen

 !item [C:]                 void Amo_new( Amouse *mouse );

 !item [Pascal:]            Procedure Amo_new( mouse: (!link [AmousePtr] [AmousePtr]) );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Amo_new setzt die neue Mausform. Die Mausformen werden
durch (!I)ACSpro(!i) automatisch gesetzt. Die innerhalb einer Routine gesetzte
Mausform bleibt hîchstens bis zur RÅckkehr zur Hauptschleife erhalten.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Mausoperationen
!end_enumerate

!end_node


!begin_node Amo_show

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Maus-Zeiger sichtbar machen bzw. einen Aufruf von
                    Amo_hide zurÅcknehmen

 !item [Kategorie:]         Mausoperationen

 !item [C:]                 void Amo_show( void );

 !item [Pascal:]            Procedure Amo_show;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Amo_show macht die Maus wird wieder sichtbar, wenn alle
Amo_hide-Aufrufe kompensiert sind.

(!I)Die Anzahl der Aufrufe wird mitgezÑhlt.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Mausoperationen

  !item Amo_hide
!end_enumerate

!end_node


!begin_node Amo_unbusy

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wartende Maus-Form zurÅcknehmen bzw. einen Aufruf
                    von Amo_busy aufheben

 !item [Kategorie:]         Mausoperationen

 !item [C:]                 void Amo_unbusy( void );

 !item [Pascal:]            Procedure Amo_unbusy;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Amo_unbusy hebt die Wirkung eines Amo_busy-Aufrufes auf.
Wird der busy-Zustand verlassen, erscheint die vorige Mausform.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Mausoperationen

  !item Amo_busy
!end_enumerate

!end_node


!begin_node AOBJECT

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das erweiterte Object AOBJECT

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das erweiterte Objekt ist eines der Kernpunkte von (!I)ACSpro(!i). Der Typ hat
die gleiche Grîûe in Bytes wie der AES-Typ OBJECT bzw AESOBJECT.
Auûerdem liegt die Komponente ob_flags an der gleichen Stelle. (!I)ACSpro(!i)
generiert ObjektbÑume, die immer genau hinter einem normalen OBJECT
dieses AOBJECT, wenn zum Objekt Click- & Drag-Routinen gehîren.

!begin_blist [Kurzbeschreibung:]
 !item [C:]         
!begin_sourcecode
typedef struct
{
   Aaction click;
   Aaction drag;
   int16 ob_flags;
   int16 key;
   void *userp1;
   void *userp2;
   int16 mo_index;
   int16 type;
} AOBJECT;
!end_sourcecode

 !item [Pascal:]    
!begin_sourcecode
AOBJECTPtr = ^AOBJECT
AOBJECT = RECORD
   click: Aaction;
   drag: Aaction;
   ob_flags: Word;
   key: Word;
   userp1: Pointer;
   userp2: Pointer;
   mo_index: Integer;
   aob_type: Integer;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

!begin_xlist [userp1, userp2]
!label AOBJECT.click
 !item [click]           zeigt auf die Routine, die die Aktion durchfÅhrt.

!label AOBJECT.drag
 !item [drag]            enthÑlt den Zeiger auf die Routine, die die
                 Ziehoperation fÅr dieses Objekt bearbeitet.

!label AOBJECT.ob_flags
 !item [ob_flags]        hat das Flag (!link [AEO] [AEO]) gesetzt. Dieses Flag unterscheidet
                 innerhalb des Objektbaumes zwischen den Typen OBJECT
                 bzw. AESOBJECT und AOBJECT. Ist das Objekt
                 gleichzeitig das letzte Objekt im Baum, muû
                 zusÑtzlich das Flag LASTOB gesetzt werden. Weitere
                 Flags haben keine Bedeutung und sollten gelîscht
                 sein.

!label AOBJECT.key
 !item [key]             enthÑlt die Beschreibung des Tastendrucks, auf den
                 das Objekt reagiert. Der Tastenkode ist als NKCC-Code
                 codiert.

!label AOBJECT.userp1
!label AOBJECT.userp2
 !item [userp1, userp2]  sind benutzerdefinierte Zeiger. Nur fÅr
                 systemdefinierte Werte von type sind diese Werte
                 vorgegeben.

!label AOBJECT.mo_index
 !item [mo_index]        beschreibt in den unteren 5 Bits den Mausformindex,
                 der benutzt werden soll, wenn sich die Maus Åber
                 diesem Objekt befindet. Die oberen Bits bleiben
                 reserviert. Der Index 0 bedeutet, daû die Mausform
                 vom Elternobjekt Åbernommen wird.

!label AOBJECT.type
 !item [type]            beschreibt den Typ des erweiterten Objekts, wobei es
                 viele vordefinierte (!link [Drag-Typen] [Drag-Typen]) gibt. Die annehmende
                 (!link [Drag-Routine] [Click-Routine]) kann daran feststellen, ob und wie sie
                 dieses Objekt bearbeitet. Gleichzeitig wird dabei
                 auch die Bedeutung der Benutzerzeiger festgelegt.
!end_xlist

!end_node


!begin_node Aob_alias

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Weiterleiten eines Klick-Events

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_alias( void );

 !item [Pascal:]            Procedure Aob_alias;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_alias ist eine vorbereitete click-Routine. Sie gibt
die Anwahl an das Objekt, dessen Nummer in userp1 steht, weiter. Durch
Typecasting kann der Wert schon im (!I)GUI-Editor(!i) gesetzt werden, in
Pure-C z.B. '(void *) OK_BUT'.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen
!end_enumerate

!end_node


!begin_node Aob_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen und initialisieren eines Objektbaumes

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 OBJECT *Aob_create( const OBJECT *parent );

 !item [Pascal:]            Function Aob_create( parent: ACSTreePtr ) :
                    ACSTreePtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_create erzeugt eine Kopie des Objektbaumes parent und
gibt den Zeiger darauf zurÅck. Ist in den Subobjekten das Flag
(!link [AOS_CONST] [AOS_CONST]) gesetzt, werden die ob_spec- Strukturen nur referenziert und
nicht kopiert.

Enthaltene Userdefs werden mit (!link [AUO_CREATE] [AUO_CREATE]) initialisiert, sofern fÅr
sie in ub_serv eine Service-Routine definiert wurde.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_delete
!end_enumerate

!end_node


!begin_node Aob_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Freigeben eines allozierten Objektbaumes

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_delete( OBJECT *object );

 !item [Pascal:]            Procedure Aob_delete( object : OBJECTPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aic_delete gibt den Objektbaumes wieder frei. Bei
Subobjekten, die das Flag (!link [AOS_CONST] [AOS_CONST]) tragen, werden die ob_spec-
Strukturen nicht freigegeben, da sie ja nur referenziert sind.

Enthaltene Userdefs werden mit (!link [AUO_TERM] [AUO_TERM]) beendet, sofern fÅr sie in
ub_serv eine Service-Routine definiert wurde.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_create
!end_enumerate

!end_node


!begin_node Aob_findflag

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Suchen eines Objektes mit bestimmten Flags

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_findflag(OBJECT *obj, int16 obnr,
                                int16 flag );

 !item [Pascal:]            Function Aob_findflag(
                                   obj: ACSTreePtr; obnr, flag:
                    Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_findflag sucht im Objektbaum obj ab dem Object obnr
das nÑchste Objekt fÅr das das Flag (!link [ob_flags] [AOBJECT.ob_flags]) per UND mit flag
verknÅpft nicht 0 wird. Beim ersten Erfragen sollte obnr zu -1 gesetzt
werden. Falls kein Objekt (mehr) dieses Flag trÑgt, wird -1
zurÅckgegeben. Diese Routine folgt der Hierarchie.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_up
!end_enumerate

!end_node


!begin_node Aob_fix

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Umwandlung Zeichen- in Pixel-Koordinaten

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_fix( OBJECT *object );

 !item [Pascal:]            Procedure Aob_fix( object: ACSTreePtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_fix wandelt die Zeichenkoordinaten des Objektbaumes
object in Pixelkoordinaten um. Das erste Objekt (Nummer 0) erhÑlt den
Status (!link [AOS_FIXED] [AOS_FIXED]). TrÑgt der Baum schon diesen Status, kehrt die
Routine sofort zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen
!end_enumerate

!end_node


!begin_node Aob_flags

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Setzen und Lîschen von Flags in ob_flags

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_flags( Awindow *window, int16 obnr,


 !item [Pascal:]            Function Aob_flags(
                                   window: (!link [AwindowPtr] [AwindowPtr]);
                                   obnr, flag, setflag: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_flags setzt (setflag=TRUE) oder lîscht
(setflag=FALSE) die Flags flag im Objekt mit der Nummer obnr des
Fensters window. Objekte der Toolbar werden wie Åblich durch die OR-
VerknÅpfung mit (!link [A_TOOLBAR] [A_TOOLBAR]) dargestellt.

Beispiel aus dem (!I)ACSpro(!i)-(!I)GUI-Editor(!i):

      Aob_state(window, EDMM_ACCMEN, DISABLED, !is_main);
      Aob_flags(window, EDMM_ACCMEN, EDITABLE, is_main);

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_state
!end_enumerate

!end_node


!begin_node Aob_gettext

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Text aus Objekt auslesen

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_gettext( const OBJECT *ob,
                                const int16 obnr, char *text );

 !item [Pascal:]            Function Aob_gettext (ob: ACSTreePtr;
                                   obnr: Integer; text: Pointer):
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Mit Hilfe der Funktion Aob_gettext kann man aus einem Objekt 'obnr'
des Objektbaums 'ob' den Text nach 'text' auslesen (ab Version 2.3
auch aus Icons). Wird fÅr 'text' NULL bzw. NIL Åbergeben, wird kein
Text zurÅckgegeben, sondern nur der RÅckgabewert (ist die LÑnge des
ausgelesenen Textes) ermittelt. Dies kann etwa fÅr eine dynamische
Textbehandlung sinnvoll sein.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_puttext
!end_enumerate

!end_node


!begin_node Aob_offset

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Koordinatenberechnung eines Objektes

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_offset( Axywh *offset, OBJECT *object,
                             int16 obnr );

 !item [Pascal:]            Procedure Aob_offset( offset: AxywhPtr;
                                   object: ACSTreePtr; obnr: Integer);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_offset berechnet die Koordinaten des Objektes obnr
des Objektbaumes object. Die Werte werden in der Struktur offset
zurÅckgegeben. Statis wie OUTLINED und SHADOWED werden berÅcksichtigt
und sollten demzufolge, wenn die absolut korrekten Ausmaûe des
Objektrechtecks ermittelt werden sollten, kurzfrstig ausgeblendet und
danach wieder restauriert werden.

Die Userdefs, die sich in der (!link [ACS.LIB] [Pure-C-Bibliothek]) befinden, werden berÅcksichtigt.

Mîchte man diese Routine zur Ermittlung der Rechtecks fÅr ein
(!link [Awindow.redraw] [Awindow.redraw])-Aufruf benutzen, muû man die x- und y-Koordinaten noch
um die Objektbaum-Fensterkoordinaten korrigieren:

     fÅr Pure-C:

     offset.x += window.wi_work.x;
     offset.y += window.wi_work.y;

     fÅr Pure-Pascal:

     offset^.x := offset^.x + window^.wi_work.x;
     offset^.x := offset^.x + window^.wi_work.x;

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen
!end_enumerate

!end_node


!begin_node Aob_printf

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Formatierte Ausgabe in Objekt

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_printf( const OBJECT *ob, const int16
                    obnr,
                             const char *format, ... );

 !item [Pascal:]            Die Funktion ist fÅr Pure-Pascal aufgrund der
                    variablen Argumente leider nicht vorhanden.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_printf schreibt in das Objekt 'obnr' des Objektbaums
'ob' einen formatierten Text, der analog zu printf formatiert werden
kann. Dazu steht ein Puffer von 1024 Zeichen LÑnge zur VerfÅgung.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_scanf
!end_enumerate

!end_node


!begin_node Aob_puttext

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Text in Objekt schreiben

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_puttext( const OBJECT *ob,
                             const int16 obnr, char *text );

 !item [Pascal:]            Procedure Aob_puttext( ob: ACSTreePtr;
                                   obnr: Integer; text: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_puttext ermîglicht das Einsetzen eines Textes 'text'
in das Objekt 'obnr' des Objektbaums 'ob'.

Dabei werden alle existierende Objekttypen berÅcksichtigt (ab Version
2.3 auch Icons), es gibt jedoch Details, die man beachten sollte:
Technisch bedingt wird bei G_BUTTON, G_STRING und G_TITLE 'text'
einfach in das Objekt geschrieben, Sie mÅssen wissen, wieviele
Buchstaben hier maximal eingetragen werden dÅrfen - öberlÑngen fÅhren
hier bestenfalls zu Speicherblockfehlern! Bei G_USERDEF (also vielen
Objekten, die von (!I)ACSpro(!i) gestellt werden) wird im AUSERBLK ub_ptr1 der
'text' eingetragen. Sie sollten also bei einem eigenen Userdef darauf
achten, sichtbare Texte dort einzutragen (wo sinnvoll, der A_editor
trÑgt hier andere Daten ein!)! Hierbei spielt die TextlÑnge keine
Rolle, sie wird dynamisch angelegt. Bei den restlichen Objekten wird
die TextlÑnge auf ein in der Objektmaske definiertes Maximum
automatisch beschrÑnkt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_gettext
!end_enumerate

!end_node


!begin_node Aob_restore

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Gesichertes Rechteck auf Bildschirm zurÅckkopieren

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 void Aob_restore( MFDB *save, Axywh *rect );

 !item [Pascal:]            Procedure Aob_restore( save: MFDBPtr; rect:
                    AxywhPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_restore schreibt das, mit Aob_save, gesicherte
Rechteck an das Rechteck rect zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_save
!end_enumerate

!end_node


!begin_node Aob_save

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Rechteck des Bildschirms sichern

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 MFDB *Aob_save( Axywh *rect );

 !item [Pascal:]            Function Aob_save( rect: AxywhPtr ) : MFDBPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_save sichert das durch rect beschriebene Rechteck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_restore
!end_enumerate

!end_node


!begin_node Aob_scanf

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Formatierten Text aus Objekt auslesen

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_scanf( const OBJECT *ob, const int16
                    obnr,
                                const char *format, ... );

 !item [Pascal:]            Die Funktion ist fÅr Pure-Pascal aufgrund der
                    variablen Argumente leider nicht vorhanden.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_scanf lieût aus dem Objekt 'obnr' des Objektbaums
'ob' einen formatierten Text aus, die Auswertung erfolgt vîllig analog
zu scanf. Dazu steht ein Puffer von 1024 Zeichen LÑnge zur VerfÅgung.
Ist 'format' NULL, wird nur die LÑnge ermittelt - siehe Aob_gettext.

Intern geht die Routine Åber sscanf und scheitert dementsprechend
gerne, wenn der auszulesende Text leer ist. Erkennt die Routine
deshalb, daû im Format-String eine Zahl eingelesen werden soll (h, l,
d, o, i, u, x im Format-String) und der Text ist leer, werden vorab 10
durch Leerzeichen getrennte Nullen (0) als Text betrachtet, so daû in
diesem Fall die in den meisten FÑllen erwÅnschten Null-Werte (und kein
MÅll) ermittelt wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_printf
!end_enumerate

!end_node


!begin_node Aob_service

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Nachricht an ein Objekt senden

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_service( OBJECT *tree, int16 obnr,
                             int16 task, void *in_out );

 !item [Pascal:]            Function Aob_service(
                                   tree: OBJECTPtr; obnr, task: int16;
                                   in_out: Pointer
                                ) : MFDBPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_service leitet die Åbergebene Nachricht an das durch
obnr angegebene Objekt weiter - die OR-VerknÅpfung mit (!link [A_TOOLBAR] [A_TOOLBAR]) ist
hier nicht notwendig, schadet aber auch nichts, da Aob_service
sicherheitshalber die Nummer mit (!link [A_MASK] [A_MASK]) maskiert..

Die Funktion fÅhrt einige SicherheitsprÅfungen durch, wenn das Flag
AB_LAZYEVAL in (!link [ACSblk->description->flags] [Adescr]) gelîscht ist. Falls diese
PrÅfungen fehlschlagen, wird der Wert FALSE zurÅckgegeben, andernfalls
das Ergebnis der UserDef-Service-Routine. Falls das Flag gesetzt ist,
wird keinerlei PrÅfung vorgenommen, sondern direkt die Service-Routine
aufgerufen, deren Ergebnis zurÅckgegeben wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Awi_observice
!end_enumerate

!end_node


!begin_node Aob_state

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Setzen und Lîschen von Status-Bits in ob_state

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_state( Awindow *window, int16 obnr,
                             int16 state, int16 setflag );

 !item [Pascal:]            Function Aob_state(
                                   window: (!link [AwindowPtr] [AwindowPtr]);
                                   obnr, state, setflag: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_state setzt (setflag=TRUE) oder lîscht
(setflag=FALSE) die Status state im Objekt mit der Nummer obnr des
Fensters window. Objekte der Toolbar werden wie Åblich durch die OR-
VerknÅpfung mit (!link [A_TOOLBAR] [A_TOOLBAR]) dargestellt.

Beispiel aus dem (!I)ACSpro(!i)-(!I)GUI-Editor(!i):

      Aob_state(window, EDMM_ACCMEN, DISABLED, !is_main);
      Aob_flags(window, EDMM_ACCMEN, EDITABLE, is_main);

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_flags
!end_enumerate

!end_node


!begin_node Aob_up

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eltern-Objekt eines gegebenen Objektes ermitteln

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_up( OBJECT *obj, int16 obnr );

 !item [Pascal:]            Function Aob_up(
                                   obj: ACSTreePtr; obnr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_up findet die Objektnummer des Elternobjektes in obj.
Start ist das Object obnr. Gibt es kein Elternobjekt, wird -1
zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Aob_findflag
!end_enumerate

!end_node


!begin_node Aob_visible

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eltern-Objekt eines gegebenen Objektes ermitteln

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_visible( OBJECT *tree, int16 obnr );

 !item [Pascal:]            Function Aob_visible(
                                   tree: ACSTreePtr; obnr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_visible prÅft, ob das durch 'obnr' bezeichnete Objekt
im Objektbaum 'tree' sichtbar ist. Wenn zwischen dem Objekt und der
Wurzel des Baumes keinerlei Verbindung besteht oder eines der zwischen
Objekt und Wurzel liegenden Eltern-Objekte unsichtbar ist, so ist das
Objekt nicht sichtbar und es wird FALSE zurÅckgegeben, andernfalls
TRUE.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen

  !item Awi_obvisible
!end_enumerate

!end_node


!begin_node Aob_watch

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objekt bei gedrÅckter Maus-Taste Åberwachen

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_watch( Awindow *window, int16 obnr );

 !item [Pascal:]            Function Aob_watch(
                                   window: (!link [AwindowPtr] [AwindowPtr]); obnr: Integer
                                ) : Boolean;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_watch Åberwacht ein Objekt. Das Objekt obnr wird
invers, wenn sich die Maus mit gedrÅcktem Knopf darÅber befindet.
Sonst wird das Objekt normal dargestellt. Es wird TRUE zurÅckgegeben,
wenn der Mausknopf Åber dem Objekt losgelassen wurde, sonst FALSE.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen
!end_enumerate

!end_node


!begin_node Aob_within

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  PrÅfen, ob Koordinate in Rechteck liegt

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Aob_within( const Axywh *rect,
                                int16 x, int16 y );

 !item [Pascal:]            Function Aob_within(
                                   rext AxywhPtr; x, y: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aob_within prÅft, ob sich die Koordinaten 'x,y' innerhalb
des Rechtecks 'recht' befinden (liefert TRUE) oder nicht (liefert
FALSE).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Object-Funktionen
!end_enumerate

!end_node


!begin_node Apd_close

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das oberste Fenster schlieûen

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_close( void );

 !item [Pascal:]            Procedure Apd_close;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_close schlieût das oberste Fenster. Falls es eine
Schlieûbox besitzt, so wird die Routine Awindow.closed aufgerufen,
andernfalls wird dem Fenster die Nachricht AS_TERM gesandt. Im
Erfolgsfall wird das (!link [zuletzt offene Fenster] [Awi_down]) nach oben gebracht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK

  !item Awi_down
!end_enumerate

!end_node


!begin_node Apd_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen von Objekten und Fenstern

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_delete( void );

 !item [Pascal:]            Procedure Apd_delete;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_delete wird zum Lîschen benutzt. Wenn in der
Auswahlliste Objekte enthalten sind, wird dem zugehîrigen Fenster die
Nachricht AS_DELETE gesandt. Andernfalls wird an das oberste Fenster
die Nachricht AS_TERM verschickt, falls dieses nicht gerade das
Wurzel-Fenster ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_info

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Informationen Åber Objekte und Fenster anzeigen

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_info( void );

 !item [Pascal:]            Procedure Apd_info;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_info informiert Åber die selektierten Objekte der
Auswahlliste. Hierzu wird dem zugehîrigen Fenster die Nachricht
AS_INFO gesandt. Falls die Auswahlliste leer ist, so wird die in
ACSblk->ACSaboutme eingetragene Routine aufgerufen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_list

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das nÑchste Fenster der Liste îffnen bzw. nach
                    oben bringen

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_list( void );

 !item [Pascal:]            Procedure Apd_list;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_list îffnet das nÑchste Fenster aus der Fenster-Liste
bzw. bringt es nach oben, falls es schon offen ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK

  !item Awi_show
!end_enumerate

!end_node


!begin_node Apd_module

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Module-Fenster îffnen bzw. nach oben bringen

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_module( void );

 !item [Pascal:]            Procedure Apd_module;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_module bringt das Module-Fenster per Awi_show nach
oben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_new

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die installierte Neu-Routine aufrufen

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_new( void );

 !item [Pascal:]            Procedure Apd_new;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_new ruft die Åber die Nachricht AS_NEWCALL beim
PUR_DESK angemeldete Neu-Routine aus.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_open

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Selektierte Objekte îffnen bzw. Neu-Routine
                    aufrufen

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_open( void );

 !item [Pascal:]            Procedure Apd_open;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_open îffnet Objekte. Wenn in der Auswahlliste Objekte
selektiert sind, so wird dem Fenster, dem die Auswahlliste gehîrt, die
Nachricht AS_OPEN gesandt. Falls nichts selektiert ist, so wird die
Funktion Apd_new aufgerufen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK

  !item Apd_new
!end_enumerate

!end_node


!begin_node Apd_quit

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Anwendung beenden

 !item [Kategorie:]         Der "pure" Desktop

 !item [C:]                 void Apd_quit( void );

 !item [Pascal:]            Procedure Apd_quit;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Apd_quit ruft die in ACSblk->ACSclose eingetragene
Routine auf, um das Terminieren der Anwendung zu veranlassen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Aqu_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen einer Queue (Warteschlange)

 !item [Kategorie:]         Unsortierte, doppelt verkettete, lineare Liste

 !item [C:]                 Queue *Aqu_create( void );

 !item [Pascal:]            Function Aqu_create : QueuePtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aqu_create erzeugt eine Warteschlange und initialisiert
die allozierte Struktur Queue, die sie zurÅckgibt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Warteschlange

  !item Queue, Aqu_delete
!end_enumerate

!end_node


!begin_node Aqu_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen einer linearen Liste

 !item [Kategorie:]         Unsortierte, doppelt verkettete, lineare Liste

 !item [C:]                 void Aqu_delete( Queue *liste );

 !item [Pascal:]            Procedure Aqu_delete( liste: QueuePtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aqu_delete lîscht eine mit Aqu_create erzeugte Queue und
versucht, die verwalteten Daten Åber die in Queue.freeElem
referenzierte Funktion freizugeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Warteschlange

  !item Queue, Aqu_create
!end_enumerate

!end_node


!begin_node appexit

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Falg, ob die Applikation beendet wird

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 appexit;

 !item [Pascal:]            appexit: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable appexit zeigt an, ob die Applikation komplett terminiert
wird. Nur wenn dies (!B)nicht(!b) der Fall ist, darf die Nachricht AS_TERM
unbearbeitet bleiben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk, AS_TERM
!end_enumerate

!end_node


!begin_node appfrom

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Pfad und Namen des aufrufenden Programmes

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char appfrom[128];

 !item [Pascal:]            appfrom: packed array [1..128] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable appfrom enthÑlt den Pfad und Namen des Aufrufenden, wenn
sich der Aufrufer in die Kommandozeile eintrÑgt "Para1 Par2 /Aufrufer"

(!I)Die Variable ist nur gÅltig, wenn das Programm als Applikation lÑuft.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, appname, apppara, apppath, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node application

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Flag, ob das Programm als Applikation oder
                    Accessory lÑuft

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 application;

 !item [Pascal:]            application: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable application zeigt an, ob das Programm als Applikation
(TRUE) oder als Accessory (FALSE) lÑuft.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node appname

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Name und Pfad der Applikation

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char appname[128];

 !item [Pascal:]            appname: packed array [1..128] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable appname enthÑlt den Pfad und Namen der Appikation als C-
String.

(!I)Die Variable ist nur gÅltig, wenn das Programm als Applikation lÑuft.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, apppath, apppara, appfrom, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node apppara

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Komplette Parameterliste der Applikation als C-
                    String

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char apppara[128];

 !item [Pascal:]            apppara: packed array [1..128] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable apppara enthÑlt den kompletten öbergabeparameterstring
der Appikation als C-String.

(!I)Die Variable ist nur gÅltig, wenn das Programm als Applikation lÑuft.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, appname, apppath, appfrom, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node apppath

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Pfad der Applikation als C-String

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char apppath[128];

 !item [Pascal:]            apppath: packed array [1..128] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable apppath enthÑlt nur den Pfad der Appikation als C-String.

(!I)Die Variable ist nur gÅltig, wenn das Programm als Applikation lÑuft.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, appname, apppara, appfrom, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node apterm

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Flag, ob das Programm wird wegen AP_TERM beendet
                    wird

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 apterm;

 !item [Pascal:]            apterm: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable apterm zeigt an, daû eine AP_TERM-Nachricht empfangen
wurde und das Programm nun beendet werden sollte! Diese Nachricht
kommt erst unter MultiTOS, N.AES oder MagiC zum tragen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node argc

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der Applikations-Parameter

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 argc;

 !item [Pascal:]            In Pure-Pascal hat diese Variable keine Bedeutung.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable argc beschreibt die Anzahl der Åbergebenen
Kommandozeilenparameter.

(!B)Achtung:(!b) Der erste Wert sollte der Programmname sein, der beim Atari
leider nicht immer angegeben wird. Bei einem Parameter ist der Wert
von argc 2!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk, apppara, argv, env
!end_enumerate

!end_node


!begin_node argv

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Parameter der Applikation

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char **argv;

 !item [Pascal:]            In Pure-Pascal hat diese Variable keine Bedeutung.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable argv enthÑlt die Parameter der Anwendung beim Start. Im
ersten Eintrag, d.h. in argv[0], sollte sich der Programmname
befinden. Auf dem Atari ist dies leider nicht immer der Fall (siehe
auch argc). In den weiteren Elementen stehen die
Kommandozeileparameter. Der letzte Eintrag argv[argc] ist immer NULL.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk, apppara, argc, env
!end_enumerate

!end_node


!begin_node array2xywh

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Punkte-Paar in Axywh-Struktur umrechnen

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 void array2xywh( Axywh *to, const int16 *from );

 !item [Pascal:]            Procedure array2xywh( to: AxywhPtr; from: Pointer);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion array2xywh rechnet ein Array mit zwei diagonalen
Eckpunkten in eine Axywh-Struktur um.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item xywh2array
!end_enumerate

!end_node


!begin_node Asel

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Datenstruktur der Auswahl-Liste

 !item [Kategorie:]         (!link [Strukturen] [Die Strukturen])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   Awindow *window;
   int16 maxlen;
   int16 actlen;
   int16 next;
   int16 dragback;
   int16 x, y;
   int16 rx, ry;
   int16 *array;
} Asel;
!end_sourcecode

 !item [Pascal:]       
!begin_sourcecode
Asel = RECORD
   window: AwindowPtr;
   maxlen: Integer;
   actlen: Integer;
   next: Integer;
   dragback:Integer;
   x, y: Integer;
   rx, ry: Integer;
   parray: Pointer;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Dies ist die Datenstruktur der Auswahlliste. Die Komponenten bedeuten:

!begin_xlist [dragback]
 !item [window]    EnthÑlt den Zeiger auf die Struktur des Fensters, zu dem
           die ausgewÑhlten Objekte gehîren. Der Eintrag ist nur
           gÅltig, wenn actlen grîûer 0 ist.

 !item [maxlen]    EnthÑlt die maximale Anzahl der EintrÑge. Sie ist zur Zeit
           auf 256 limitiert.

 !item [actlen]    EnthÑlt die aktuelle Anzahl der ausgewÑhlten Objekte.

 !item [next]      Dieser Wert wird fÅr den Aufruf Adr_next benîtigt. Beginnt
           man die Elemente der Liste abzufragen, muû zuvor dieser
           Wert mit 0 belegt werden.

 !item [dragback]  Normalerweise werden die Objekte beim Bearbeiten aus der
           Liste entfernt. Die verbleibenden (unbearbeiteten) Objekte
           schnappen zu ihrem Ursprung zurÅck. Das wird verhindert,
           wenn die drag-Routine den Wert auf FALSE setzt.

 !item [x, y]      Diese Werte beschreiben die Mausposition zum Zeitpunkt des
           Aufnehmens der Ziehliste.

 !item [rx, ry]    Die relative Distanz, die mit der Maus beim Ziehen
           zurÅckgelegt wurde, wird hier eingetragen.

 !item [array]     Zeigt auf das Feld, das die EintrÑge enthÑlt.
!end_xlist

!end_node


!begin_node Ascrp_clear

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten im Klemmbrett lîschen

 !item [Kategorie:]         Klemmbrett-Funktionen

 !item [C:]                 void Ascrp_clear( const char *ext );

 !item [Pascal:]            Procedure Ascrp_clear( ext: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ascrp_clear lîscht Dateien des Klemmbretts. Die Dateien
fÅr den Datenaustausch haben den Namen 'SCRAP' und verschiedene
Klemmbrett-Typen. Ein NULL zw. NUL in 'ext' bedeutet, daû alle diese
Dateien (also 'SCRAP.*') gelîscht werden sollen, ansonsten kann in
'ext' der zu lîschende Typ Åbergeben werden.

Im Erfolgsfall werden die Nachricht SC_CHANGED und SH_WDRAW per
Ash_sendall an alle erreichbaren Anwendungen verschickt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Klemmbrett-Funktionen

  !item Ascrp_get, Ascrp_put
!end_enumerate

!end_node


!begin_node Ascrp_get

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten aus dem Klemmbrett lesen

 !item [Kategorie:]         Klemmbrett-Funktionen

 !item [C:]                 int16 Ascrp_get( char *ext, void **buffer,
                             long *len );

 !item [Pascal:]            Function Ascrp_get(
                                   ext, buffer, len: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ascrp_get liest aus dem Klemmbrett die Datei 'SCRAP' vom
Typ 'ext' oder die erste Datei, die auf den Typ paût ("*" fÅr 'ext'
ist also erlaubt). Wenn in 'buffer' NULL bzw. NIL Åbergeben wird, wird
nur die LÑnge der Daten in 'len' zurÅckgeliefert, sonst ist in
'buffer' der Zeiger auf die Daten.

Bei fehlerfreiem Ablauf wird TRUE zurÅckgeliefert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Klemmbrett-Funktionen

  !item Ascrp_clear, Ascrp_put
!end_enumerate

!end_node


!begin_node Ascrp_put

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten ins Klemmbrett schreiben bzw. anhÑngen

 !item [Kategorie:]         Klemmbrett-Funktionen

 !item [C:]                 int16 Ascrp_put( char *ext, void *buffer,
                             long len, int16 append );

 !item [Pascal:]            Function Ascrp_put(
                                   ext, buffer, len: Pointer;
                                   append: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ascrp_put schreibt die Daten aus dem Speicherbereich
buffer der LÑnge len ins Klemmbrett mit dem Datenamen 'SCRAP' und dem
Typ 'ext'. Sollen die Daten an eine bestehenden Datei angehÑngt werden
(sinnlos bei 'IMG' oder 'GEM'), so ist append auf TRUE zu setzen.

Bei fehlerfreiem Ablauf wird TRUE zurÅckgeliefert und die Nachricht
SC_CHANGED und SH_WDRAW per Ash_sendall an alle erreichbaren
Anwendungen verschickt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Klemmbrett-Funktionen

  !item Ascrp_clear, Ascrp_get
!end_enumerate

!end_node


!begin_node Ash_CallEdDI

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Aufruf einer EdDI-Funktion

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_CallEdDI( int16 fkt_nr );

 !item [Pascal:]            Function Ash_CallEdDI( fkt_nr: int16 ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_CallEdDI ruft die EdDI-Funktion Nummer fkt_nr auf.
Der RÅckgabewert ist der der EdDI-Funktion oder -1, falls keine EdDI-
Funktionen zur VerfÅgung stehen (oder etwas beim Auslesen des (!link [Cookies] [Cookie Jar])
'EdDI' schief ging).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_error

!label Fehlermeldung
!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Standard-Fehlerausgabe-Routine

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 void Ash_error( int16 mess, void *para );

 !item [Pascal:]            Procedure Ash_error( mess: Integer;
                                 para: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_error ist die Standard-Fehlerausgaberoutine. Sie
sollte normalerweise nicht direkt aufgerufen werden, sondern Åber
ACSblk->ACSerror! In 'mess' kann man eine Fehlernummer vergeben, der
optionale Parameter 'para' dient einer zusÑtzlichen DatenÅbergabe, was
vor allem bei eigenen Fehlerroutinen in ACSblk interessant ist.

Diese Routine versteht folgende Nachrichten:

!begin_xlist [AE_DEFECTIVE_MEM]
!label AE_GEN
 !item [AE_GEN]            Genereller Fehler.

!label AE_GEN_MEM
 !item [AE_GEN_MEM]        Allgemeiner Speicherfehler.

!label AE_OUT_OF_MEM
 !item [AE_OUT_OF_MEM]     Nicht genÅgend Speicher.

!label AE_DEFECTIVE_MEM
 !item [AE_DEFECTIVE_MEM]  Zugriff auf fremden Speicher.

!label AE_RANGE_MEM
 !item [AE_RANGE_MEM]      Fehlerhafte Speichergrîûe.

!label AE_ODD_MEM
 !item [AE_ODD_MEM]        Ungerade Speicheradresse.

!label AE_GEN_IO
 !item [AE_GEN_IO]         Allgemeiner Ein-/Ausgabefehler.
!end_xlist

Die folgenden Fehlermeldungen akzeptieren z.B. in 'para' einen
Dateinamen:

!begin_xlist [AE_DEFECTIVE_MEM]
!label AE_OPEN_IO
 !item [AE_OPEN_IO]        Fehler beim ôffnen.

!label AE_CREATE_IO
 !item [AE_CREATE_IO]      Fehler beim Erzeugen.

!label AE_WRITE_IO
 !item [AE_WRITE_IO]       Fehler beim Schreiben.

!label AE_READ_IO
 !item [AE_READ_IO]        Fehler beim Lesen.
!end_xlist

Die restlichen Meldungen sind:

!begin_xlist [AE_DEFECTIVE_MEM]
!label AE_GEN_MOD
 !item [AE_GEN_MOD]        Genereller Modul-Fehler.

!label AE_LOAD_MOD
 !item [AE_LOAD_MOD]       Fehler beim Laden des Moduls.

!label AE_VER_MOD
 !item [AE_VER_MOD]        Fehlerhafte Version des Moduls.

!label AE_MEM_MOD
 !item [AE_MEM_MOD]        Restspeicher kann nicht freigegeben werden.

!label AE_PORT
 !item [AE_PORT]           Fehler bzgl. einer Schnittstelle.

!label AE_COLORS
 !item [AE_COLORS]         Fehlerhafte Farbanzahl (naja!?).

!label AE_REZ
 !item [AE_REZ]            Fehlerhafte Auflîsung (naja, sollte ja eigentlich
                   nie vorkommen!?).

!label AE_VDI
 !item [AE_VDI]            Fehlerhafte VDI-Version.

!label AE_AES
 !item [AE_AES]            Fehlerhafte AES-Version.

!label AE_IMG
 !item [AE_IMG]            Auspacken der IMG-Daten fehlerhaft.

!label AE_DD_WARN
 !item [AE_DD_WARN]        Beim externen D&D ist ein unschlÅssiger Fall
                   aufgetreten.

!label AE_DD_ERR
 !item [AE_DD_ERR]         Beim D&D ist ein Fehler eingetreten.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_fileselect

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine Datei Åber die Dateiauswahlbox auswÑhlen
                    lassen

 !item [Kategorie:]         Datei-Funktionen

 !item [C:]                 ULinList *Ash_fileselect( char *title, int16 x,
                                int16 y, char *path, char *fname,
                                char *patterns, XFSL_FILTER *filter,
                                char *paths, int16 sort_mode,
                                int16 flags, Awindow *meldung );

 !item [Pascal:]            Function Ash_fileselect(
                                   title: Pointer; x, y: int16;
                                   path, fname, patterns: Pointer;
                                   filter: XFSL_FILTER_Ptr;
                                   paths: Pointer;
                                   sort_mode, flags: int16;
                                   meldung: (!link [AwindowPtr] [AwindowPtr])
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_fileselect ruft den (MagiC-)Fileselector auf. Die
Parameter bedeuten hierbei:

!begin_xlist [patterns]
 !item [title]      Titel des Fileselector-Fensters

 !item [x, y]       Position des FIleselectors-Fenster

 !item [path]       Pfad, von dem der Fileselector ausgehen soll

 !item [fname]      Dateiname, der zunÑchst ausgewÑhlt sein soll

 !item [patterns]   Masken fÅr Dateiendungen, die verwendet werden sollen
            Mehrere Dateiendungsmasken sind mit ',' getrennt, am Ende
            jeder Endungsgruppe steht ein Null-Byte. Die Liste wird
            mit zwei Null-Byte abgeschlossen (s. Doku zu den FSLX-
            Funktionen).

 !item [filter]     Zeiger auf Filter-Funktion

 !item [paths]      Liste von Pfaden, die in der Pfad-Historie gezeigt werden
            sollen

 !item [sort_mode]  Sortierung der angezeigten Dateien

 !item [flags]      Verschiedene Einstellungen des Selectors.

 !item [meldung]    FÅr den Wert NULL bzw. NIL wird der modale FIleselector
            aufgerufen. Wenn hier ein Fenster Åbergeben wird, wird vom
            nicht-modalen Fileselector diesem Fenster Åber die Meldung
            AS_FILESELECT die Liste der ausgewÑhlten Dateien
            Åbermittelt.
!end_xlist

Weitere Informationen Åber diese Werte sind bitte der MagiC-
Entwickler-Dokumentation zu entnehmen.

(!B)Hinweis:(!b) Die Funktion verwendet eine FSLX-Dateiauswahl. Wenn daher die
FSLX-Funktionen nicht zur VerfÅgung stehen, wird "die Arbeit
verweigert".

Die Parameter bedeuten im Einzelnen:

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Datei-Funktionen

  !item Ash_print, Ash_font

  !item Af_fileselect, Af_first_fsel, Af_next_fsel, Af_select
!end_enumerate

!end_node


!begin_node Ash_font

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen Zeichensatz Åber den (MagiC-)Font-Selector
                    auswÑhlen lassen

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_font( const char *title, const int16 x,
                             const int16 y, const int16 font_flag,
                             const int16 button_flag,
                             A_FontSel *font, const char *sample,
                             const char *opt_button, A_FontFkt set,
                             A_FontFkt mark, A_FontFkt opt,
                             void *para, Awindow *window );

 !item [Pascal:]            Function Ash_font(
                                   title: Pointer
                                   x, y, font_flag, button_flag :
                    Integer;
                                   font: A_FontSelPtr;
                                   sample, opt_button: Pointer;
                                   set, mark, opt: A_FontFkt;
                                   para: Pointer; window: (!link [AwindowPtr] [AwindowPtr])
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_font

(!B)Hinweis:(!b) Die Funktion verwendet den FNTS-Selector. Wenn daher die
FNTS-Funktionen nicht zur VerfÅgung stehen, wird "die Arbeit
verweigert".

Die Parameter bedeuten im Einzelnen:

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen

  !item Ash_fileselect, Ash_print
!end_enumerate

!end_node


!begin_node Ash_getcookie

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen (!link [Cookie] [Cookie Jar]) aus dem (!link [Cookie Jar] [Cookie Jar]) abfragen

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_getcookie( long cookie, void *val );

 !item [Pascal:]            Function Ash_getcookie(
                                   cookie: Longint; value: Pointer
                                ): Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_getcookie durchsucht den (!link [Cookie Jar] [Cookie Jar]) nach einem
(!link [Cookie] [Cookie Jar]). Wenn der RÅckgabewert TRUE ist, so wurde der Cookie gefunden,
in 'value' wird dann der Zeiger auf den (!link [Cookie] [Cookie Jar])-Wert zurÅckgeliefert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_getenv

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wert einer Environment-Variable ermitteln

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 char *Ash_getenv( char *name );

 !item [Pascal:]            Function Ash_getenv( name: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_getenv sucht im eigenen Environment nach der Existenz
der Variablen 'name'. Der Wert der Variablen oder NULL bzw. NIL wird
zurÅckgeliefert.

Bekannt ist z.B. die Variable "HOME", die den Pfad auf das Anwender-
eigene Verzeichnis besitzen sollte. Im ACSblk wird die Variable
cfg_path mit diesem Inhalt versehen, sofern er existiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_getOSHeader

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wert einer Environment-Variable ermitteln

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 SYSHDR *Ash_getOSHeader( void )

 !item [Pascal:]            Function Ash_getOSHeader : SYSHDRPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_getOSHeader liefert einen Zeiger auf die SYSHDR-
Struktur (manchmal auch OSHEADER genannt) des Betriebssystems.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_gettimer

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wert einer Environment-Variable ermitteln

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 UINT32 Ash_gettimer( void );

 !item [Pascal:]            Function Ash_gettimer : UINR32;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_gettimer liefert den Wert des 200Hz-Timers zurÅck.
Der Wert wird bevorzugt per Ssystem ermitteln (falls vorhanden),
andernfalls wird der Timer "wie Åblich" im Supervisor-Mode ausgelesen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_module

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein (!I)ACSpro(!i)-Modul nachladen

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_module( char *path );

 !item [Pascal:]            Function Ash_module( path: Pointer ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_module lÑdt das Modul 'path' nach, initialisiert und
startet dies.

(!B)Hinweis:(!b) Module besitzen eine eigene Versionsnummer, anhand derer ACS
entscheidet, ob es geladen werden kann (aufgrund einer neuen (!I)ACSpro(!i)-
Version kann diese Notwendigkeit auftauchen). Wundern Sie sich also
nicht, daû eine Ihnen vorliegende Version ein altes Modul mit einer
entsprechenden (!link [Fehlermeldung] [Fehlermeldung]) abweist - in diesem Fall mÅssen Sie sich
eine neue Version des Moduls besorgen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_nextdd

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Externe D&D-Partner ermitteln

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 A_dd *Ash_nextdd( A_dd *act );

 !item [Pascal:]            Function Ash_nextdd( act: (!link [A_ddPtr] [A_ddPtr]) ) : A_ddPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_nextdd ermittelt die externen D&D-Partner. Dazu wird
'act' mit NULL/NIL vorbesetzt, solange weitere Aufrufe dieser Routine
kein NULL bzw. NIL zurÅckliefern, bekommt man weitere Partner in 'act'

(!B)Hinweis:(!b) (!I)Diese Funktion ist nur aus AbwÑrtskompatibilitÑtsgrÅnden
vorhanden! Durch Verwendung der Variablen ListOfApps als
(!link [linearen Liste] [ULinList]) stehen wesentlich komfortablere Mîglichkeiten bereit!(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen

  !item ListOfApps, ULinList
!end_enumerate

!end_node


!begin_node Ash_NVDICookie

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeiger auf (!link [Cookie] [Cookie Jar])-Struktur von NVDI liefern

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 NVDI_STRUC *Ash_NVDICookie( void )

 !item [Pascal:]            Function Ash_NVDICookie : NVDI_STRUCPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_NVDICookie liefert den Eintrag des (!link [Cookies] [Cookie Jar]) 'NVDI' als
Zeiger auf die NVDI-Struktur NVDI_STRUC. Falls der (!link [Cookie] [Cookie Jar]) nicht
gefunden wurde oder ein Fehler auftrat, wird NULL bzw. NIL
zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_NVDIDatum

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NVDI-Datum ermitteln

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 Uint16 Ash_NVDIDatum( void );

 !item [Pascal:]            Function Ash_NVDIDatum : Uint16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_NVDIDatum liefert das NVDI-Datum aus der mittels
Ash_NVDICookie ermittelten NVDI-Struktur und ist damit eine
"Vereinfachung" (incl. FehlerprÅfung) von Ash_NVDICookie()-
>nvdi_datum.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen

  !item Ash_NVDICookie
!end_enumerate

!end_node


!begin_node Ash_NVDIVersion

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NVDI-Versionsnummer ermitteln

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 Uint16 Ash_NVDIVersion( void );

 !item [Pascal:]            Function Ash_NVDIVersion : Uint16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_NVDIVersion liefert die NVDI-Versionsnummer aus der
mittels Ash_NVDICookie ermittelten NVDI-Struktur und ist damit eine
"Vereinfachung" (incl. FehlerprÅfung) von Ash_NVDICookie()-
>nvdi_version.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen

  !item Ash_NVDICookie
!end_enumerate

!end_node


!begin_node Ash_print

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die WDIALOG-Druck-Dialoge aufrufen

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_print( PRN_SETTINGS *setting,
                             int16 x, int16 y, int16 option,
                             char *title, Awindow *window );

 !item [Pascal:]            Function Ash_print(
                                   setting: PRN_SETTINGSPtr;
                                   x, y, option: int16; title:
                    Pointer;
                                   window: (!link [AwindowPtr] [AwindowPtr])
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_print

(!B)Hinweis:(!b) Die Funktion verwendet die PDLG-Druckdialoge. Wenn daher die
PDLG-Funktionen nicht zur VerfÅgung stehen, wird "die Arbeit
verweigert".

Die Parameter bedeuten im Einzelnen:

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen

  !item Ash_fileselect, Ash_font
!end_enumerate

!end_node


!begin_node Ash_prog

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Starten von (externen) Programmen

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 long Ash_prog( char *path, char *command,
                            char **env );

 !item [Pascal:]            Function Ash_prog(
                                   path, command, env: Pointer
                                ) : LongInt;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_prog dient dem Start externer Programme. Das Programm
in 'path' wird gestartet, ihm wird das Einvironment 'env' und die
Kommandozeile 'command' Åbergeben - letztere muû im ersten Byte die
LÑnge der eigentlich darauf folgenden Kommandos kodiert haben. Es wird
zu Beginn der Standard-Pfad und das Standard-Laufwerk auf das
Programms gesetzt.

Unter Multitasking (keine Environment-öbergabe mîglich) wird versucht,
die Programme per shel_write zu starten, wobei MagiC beachtet wird.
Der RÅckgabewert ist hierbei das Ergebnis von shel_write.

Sonst erfolgt ein Start per Pexec. Dabei wird anhand der Typen in der
Environment-Variablen 'GEMSUFFIX' oder anhand des Programmtyps
festgestellt, ob es sich um ein GEM- oder TOS-Programm handelt. Im
letzteren Fall wird der Bildschrim gelîscht, der VT52-Emulator
initialisiert, das Programm gestartet und auf einen abschlieûenden
Tastendruck gewartet.

Erfolgt dieser Aufruf als Accessory, versucht (!I)ACSpro(!i) einen AV-
(!link [Protokoll] [Protokoll])-Server zu finden und Åbergibt diesem - wenn mîglich -
AV_STARTPROG mit diesen Daten (z.B. fÅhrt dann jinnee oder GEMINI den
korrekten Programmstart durch). Dabei wartet (!I)ACSpro(!i) noch auf die
Erfolgsmeldung des AV-(!link [Protokoll] [Protokoll])-Server und liefert dessen Ergebnis
zurÅck.

Es werden bei Bedarf korrekt alle Fenster geschlossen, bei RÅckkehr
wieder geîffnet (nur per Pexec) und eventuelle 'WIND_UPDATE'-
Klammerungen aufgehoben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_sendall

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Nachrichten an alle erreichbaren Applikationen
                    schicken

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_sendall( int16 *buff, long type );

 !item [Pascal:]            Function Ash_sendall(
                                   buff: Pointer; type: Longint
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_sendall schickt allen erreichbaren, externen
Applikationen eine GEM-Nachricht zu, die in 'buff' mit einem 8 int16-
groûen Feld codiert ist (Beispiel: evnt_mesag). Dabei kann man das
Ziel auf bestimmte D&D-Partner einschrÑnken ('type' mit DD_XACC oder
DD_VA per OR verknÅpfen) oder alle im System erreichbaren
Applikationen mittels appl_search ansprechen ('type' auf -1 setzen) -
sofern Ihr TOS diesen Aufruf unterstÅtzt!

Im Erfolgsfall wird TRUE zurÅckgeliefert, sonst FALSE.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!end_node


!begin_node Ash_thermometer

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  WÑhrend einer lÑngeren Aktion einen Laufbalken
                    anzeigen

 !item [Kategorie:]         System-Funktionen

 !item [C:]                 int16 Ash_thermometer( const int16 kind,
                             const char *titel, const int16 color,
                             void *data, A_ThermFkt init,
                             A_ThermFkt start, A_ThermFkt cont,
                             A_ThermFkt fkt, A_ThermFkt stop,
                             A_ThermFkt quit );

 !item [Pascal:]            Function Ash_thermometer(
                                   kind: int16; titel: Pointer;
                                   color: Integer; data: Pointer;
                                   init, start, cont, fkt, stop,
                                   quit: A_ThermFkt
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ash_thermometer stellt ein sog. Thermometer - einen
Laufbalken - wÑhrend einer lÑngeren Aktion in einem Fenster-Dialog zur
VerfÅgung ((!link [siehe Beispiel] [Ash_thermometer - Beispiel])) - diese FunktionalitÑt nenne ich schon so
lange "Thermometer", daû ich gar nicht mehr weiû, warum... ;-)

Der Fenster-Dialog wird durch den Parameter kind beeinfluût. DafÅr
sind die folgenden Konstanten definiert, die per OR verknÅpft werden
mÅssen:

!begin_xlist [THERMO_NONMODAL]
 !item [THERMO_MINIMAL]   Minimales Thermometer

 !item [THERMO_TEXT]      ErlÑuterungstext ist vorhanden

 !item [THERMO_CANCEL]    Abbruch-Button ist vorhanden

 !item [THERMO_PERCENT]   Prozent-Angabe ist vorhanden

 !item [THERMO_NONMODAL]  Das Thermometer lÑuft in einem nicht-modalen Fenster
!end_xlist

Der Parameter color gibt die Farbe des Laufbalkens an, der Wert -1
steht hierbei fÅr einen normalen (!link [3D-Button] [Userdef-3D-Button]).

Die Funktionszeiger init, start, cont, fkt, stop und quit, die
Åbrigens auch NULL bzw. NIL sein dÅrfen, stellen die hinter dem
Thermometer stehende Aktion dar. Sie bilden im Prinzip folgendes
ProgrammgerÅst:
!begin_sourcecode
     init(data);
     if( start(data) )
     {
        while( cont(data) )
           fkt(data);
        stop(data);
     }
     quit(data);
!end_sourcecode

Die Funktionen, die hier Åbergeben werden, bekommen einen Zeiger auf
den Datentyp A_ThermoData Åbergeben. In dieser Struktur werden u.a.
die in data Åbergebenen Daten und die Åbergebenen Funktionszeiger
weitergereicht sowie die fÅr das Thermometer wichtigen Informationen
zurÅckgegeben.

(!B)Hinweise:(!b)

!begin_enumerate
  !item Der in der Struktur A_ThermoData Åbergebene String wird (!I)nach(!i)
     Aufruf der in cont Åbergebenen Funktion als Text im Thermometer
     angezeigt. Um hier einen Text als User-Info anzuzeigen muû der
     Text also jeweils beim PrÅfen der Abbruch-Bedingung gesetzt
     werden, d.h. in init fÅr den Anfangs-Text, in cont fÅr den danach
     folgenden Aufruf von fkt bzw. stop sowie in stop der Text bis zum

  !item Die Funktion init wird aufgerufen, bevor das Fenster erscheint.
     Das Fenster ist aber bereits initialisiert.

  !item Nach dem ôffnen des Fensters wird die Funktion start aufgerufen.

  !item Die Funktion cont wird immer wieder aufgerufen und prÅft, ob die
     Schleife weiterlaufen soll. Hier werden auch die Daten (Daten fÅr
     Prozent-Angabe/Laufbalken-LÑnge, Info-Text) in der Struktur
     A_ThermoData gesetzt, die beim Bildschirm-Update direkt nach cont
     verwendet werden sollen. Ein RÅckgabewert FALSE signalisiert, daû
     die Schleife abgebrochen werden soll, andernfalls erfolgt nach
     dem Bildschirm-Update des Thermometers der Aufruf der Funktion
     fkt.

  !item Die in fkt Åbergebene Funktion fÅhrt die eigentliche Aktion des
     Thermometers aus und entspricht damit dem inneren KernstÅck einer
     Schleife.

  !item Die Funktion stop wird nach Beendigung der Aktionen aufgerufen
     noch bevor das Fenster geschlossen wird.

     Die Funktion hat zwei Rollen. Sie wird beim Anklicken des Buttons
     'Abbrechen' aufgerufen. Wenn sie hier FALSE zurÅck liefert, lÑuft
     die Schleife weiter, andernfalls wird das Thermometer gestoppt
     und beendet. Wenn die Schleife durch den RÅckgabewert FALSE der
     in cont Åbergebenen Funktion "regulÑr" beendet wird, so wird stop
     ebenfalls aufgerufen. Hierbei spielt der RÅckgabewert allerdings
     keine Rolle.

     (!B)Hinweis:(!b) Zur Unterscheidung dieser beiden Aufruf-Varianten sollte
     das in der eigentlichen PrÅf-Funktion cont implementierte
     Abbruch-Kriterium benutzt werden. In A_ThermoData werden die
     Åbergebene Funktionszeiger zu diesem Zweck weitergereicht!

  !item Die in quit Åbergebene Funktion wird nach dem Schlieûen des
     Fensters fÅr AufrÑumarbeiten aufgerufen.
!end_enumerate

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item System-Funktionen
!end_enumerate

!begin_node Ash_thermometer - Beispiel

Das folgende Thermometer


!image (!IMAGES)img00731.img

zeigt quasi eine for-Schleife optisch an und wird durch den folgenden
Code erzeugt.

Die init-Funktion lautet:
!begin_sourcecode
int16 init( ThermoData *thermo )
{
   thermo->aktuell=0;
   thermo->maximum=500;
   strcpy(thermo->text, "ZÑhler-Initialisierung...");
   return TRUE;
}
!end_sourcecode

Die Funktion, die das Abbruch-Kriterium realisiert lautet
!begin_sourcecode
int16 isRunning( ThermoData *thermo )
{
   return (thermo->aktuell<thermo->maximum);
}
!end_sourcecode

Als Schleifen-Funktion wird
!begin_sourcecode
int16 zaehlfkt( ThermoData *thermo )
{
   sprintf(thermo->text, "Aufruf Nr. %li", thermo->aktuell);
}
!end_sourcecode

verwendet. Anstatt hier einfach den ZÑhler thermo->aktuell auszugeben,
werden hier i.a. lÑnger anhaltende Aktionen stehen.

Die start-Funktion wird nicht benîtigt. Die stop-Funktion lautet in
diesem Beispiel
!begin_sourcecode
int16 stop( ThermoData *thermo )
{
   strcpy(thermo->text, "ZÑhler anhalten?");

   return (thermo->cont)(thermo)
               && Awi_alert(2, Nachfrage)==1;
}
!end_sourcecode

wobei Nachfrage eine im (!I)GUI-Editor(!i) definierte Alert-Box ist, mittels
derer nachgefragt wird, ob der ZÑhler beendet werden soll. Wie Sie
sehen, ist im ersten Teil der Abfrage exakt die Abbruch-Bedingung Åber
den Zeiger cont realisiert.

Der Aufruf des Thermometers lautet dann ganz einfach

!begin_sourcecode
     Ash_thermometer(THERMO_PERCENT|THERMO_TEXT|THERMO_CANCEL,
        " Ein kleiner ZÑhler... ", -1, NULL, init,
        (A_ThermFkt)NULL, isRunning, zaehlfkt, stop,
        (A_ThermFkt)NULL);
!end_sourcecode

Hier wird durch den ersten Parameter das Aussehen des Thermometers
angegeben. Wenn die entsprechenden Bits - hier durch Konstanten
dargestellt - nicht gesetzt sind, ist die entsprechende Komponente
nicht vorhanden bzw. ausgeblendet.

!end_node


!end_node


!begin_node Ast_adc

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  String zentriert mit Leerzeichen auffÅllen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_adc( char *string, long len );

 !item [Pascal:]            Function Ast_adc(
                                   string : Pointer; len: LongInt
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_adc fÅllt einen String von beiden Seiten her mit
Leerzeichen auf, so daû der String zentriert steht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_adl, Ast_adr
!end_enumerate

!end_node


!begin_node Ast_add

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Mehrere Strings zusammenhÑngen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_add( int16 anzahl, char *ergebnis, ... )

 !item [Pascal:]            Die Funktion ist in Pure-Pascal wegen der
                    variablen Parameter leider nicht mîglich.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_add hÑngt mehrere Strings nach Entfernen der
Leerzeichen durch Ast_alltrim hintereinander und fÅllt das Ergebnis
linksbÅndig mit Leerzeichen auf eine bestimmte LÑnge auf.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen
!end_enumerate

!end_node


!begin_node Ast_adl

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen String linksbÅndig von rechts her mit
                    Leerzeichen auffÅllen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_adl( char *string, long len );

 !item [Pascal:]            Function Ast_adl(
                                   string : Pointer; len: LongInt
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_adl fÅllt einen String von rechts her mit Leerzeichen
auf, so daû der String linksbÅndig steht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_adc, Ast_adr
!end_enumerate

!end_node


!begin_node Ast_adr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen String rechtsbÅndig von links her mit
                    Leerzeichen auffÅllen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_adr( char *string, long len );

 !item [Pascal:]            Function Ast_adr(
                                   string : Pointer; len: LongInt
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_adr fÅllt einen String von links her mit Leerzeichen
auf, so daû der String rechtsbÅndig steht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_adc, Ast_adl
!end_enumerate

!end_node


!begin_node Ast_alltrim

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  FÅhrende und schlieûende Leerzeichen eines Strings
                    entfernen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_alltrim( char *string );

 !item [Pascal:]            Function Ast_alltrim( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_alltrim ist die Kombination aus Ast_ltrim und
Ast_rtrim. Sie entfernt fÅhrende und abschlieûende Leerzeichen eines
Strings.

(!B)Hinweis:(!b) Die Umwandlung der Zeichen wird direkt im Åbergebenen String
vorgenommen, d.h. der Åbergebene String wird (!I)geÑndert(!i)!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_ltrim, Ast_rtrim
!end_enumerate

!end_node


!begin_node Ast_cmp

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zwei Strings vergleichen (Groû-Kleinschreibung
                    berÅcksichtigen)

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ast_cmp( const char *str_1,
                             const char *str_2 );

 !item [Pascal:]            Function Ast_cmp(
                                   str_1, str_2: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_cmp vergleicht zwei Strings, wobei die Groû-/
Kleinschreibung mit berÅcksichtigt wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_icmp, Ast_fcmp
!end_enumerate

!end_node


!begin_node Ast_count

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  HÑufigkeit der Zeichen eines Strings in einem
                    anderen bestimmen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 long Ast_count( char *string, char *zeichen );

 !item [Pascal:]            Function Ast_count(
                                   string, zeichen: Pointer
                                ) : LongInt;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_count bestimmt in einem String die Anzahl der
Zeichen, die im zweiten String enthaltenen sind.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen
!end_enumerate

!end_node


!begin_node Ast_countASCIZZ

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der Strings in einem ASCIIZZ-String
                    ermitteln

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ast_countASCIZZ( const char *asciizz );

 !item [Pascal:]            Function Ast_countASCIZZ(
                                   string: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_countASCIZZ bestimmt die Anzahl der Strings, die in
einem ASCIIZZ-String enthalten sind. Sie wird z.B. fÅr die
Realisierung von GEMSCript benîtigt, da hier ASCIIZZ-Strings versendet
werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen, GEMScript
!end_enumerate

!end_node


!begin_node Ast_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  String duplizieren

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_create( const char *parent );

 !item [Pascal:]            Function Ast_create( parent : Pointer) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_create kopiert den String 'parent' in einen neu
allozierten Speicherbereich. Nur fÅr den Leerstring wird immer der
selbe String zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Ast_delete
!end_enumerate

!end_node


!begin_node Ast_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Kopie eines String lîschen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 void Ast_delete( char *string );

 !item [Pascal:]            Procedure Ast_delete( string : Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_delete gibt den Speicherplatz des Strings wieder
frei.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Ast_create
!end_enumerate

!end_node


!begin_node Ast_deleteAry

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Array von Strings komplett freigeben

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 void Ast_deleteAry( char **strings,
                            int16 anzahl );

 !item [Pascal:]            Procedure Ast_deleteAry(
                                 strings: array of Pointer;
                                 anz: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_deleteAry gibt das Array (z.B. durch Ast_splitASCIZZ
aufgebaut) wieder frei. Bevor das Array durch Ax_free freigegeben
wird, werden die einzelnen Strings per Ast_delete gelîscht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen, GEMScript

  !item Ast_splitASCIIZZ
!end_enumerate

!end_node


!begin_node Ast_fcmp

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Vergleich zweier Strings mit Wildcards

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ast_fcmp( const char *str_1,
                             const char *str_2 );

 !item [Pascal:]            Function Ast_fcmp(
                                   str_1, str_2: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_fcmp vergleicht zwei Strings, wobei die Groû-/
Kleinschreibung mit berÅcksichtigt wird. Der erste String darf ferner
die Åblichen Wildcardzeichen '*' und '?' enthalten.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_cmp, Ast_icmp
!end_enumerate

!end_node


!begin_node Ast_filter

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen aus String entfernen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_filter( char *string, char *wrg_char );

 !item [Pascal:]            Function Ast_filter(
                                   string, wrg_char: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_filter entfernt aus einem String alle Zeichen eines
anderen Strings, die sog. "nicht erlaubten Zeichen".

(!B)Hinweis:(!b) Die Zeichen wird direkt im Åbergebenen String entfernt, d.h.
der Åbergebene String wird (!I)geÑndert(!i)!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen
!end_enumerate

!end_node


!begin_node Ast_icmp

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zwei Strings vergleichen (!I)ohne(!i) BerÅcksichtigung der
                    Groû-/Kleinschreibung

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ast_icmp( const char *str_1,
                             const char *str_2 );

 !item [Pascal:]            Function Ast_icmp(
                                   str_1, str_2: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_icmp vergleicht zwei Strings, wobei die Groû-/
Kleinschreibung (!I)keine Rolle(!i) spielt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_cmp, Ast_fcmp
!end_enumerate

!end_node


!begin_node Ast_isEmpty

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Auf leeren String ÅberprÅfen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ast_isEmpty( char *string );

 !item [Pascal:]            Function Ast_isEmpty( string: Pointer ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_isEmpty prÅft, ob ein String nur "weiûe Leerzeichen"
(siehe auch Ach_isWhite) enthÑlt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ach_isWhite
!end_enumerate

!end_node


!begin_node Ast_istr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen Substring in einem String suchen, Groû-/
                    Kleinschreibung wird (!I)nicht(!i) berÅcksichtigt

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_istr( const char *s1, const char *s2 )

 !item [Pascal:]            char * Function Ast_istr(
                                   s1, s2: Pointer
                                ) : Pointer)

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_istr sucht im String s1 das erste Vorkommen des
Substrings s2, wobei Groû- und Kleinschreibung (!I)nicht(!i) berÅcksichtigt
wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen
!end_enumerate

!end_node


!begin_node Ast_ltrim

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  FÅhrende Leerzeichen entfernen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_ltrim( char *string );

 !item [Pascal:]            Function Ast_ltrim( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_ltrim schneidet alle fÅhrenden Leerzeichen ab,
entfernt also alle links im String stehenden Leerzeichen.

(!B)Hinweis:(!b) Die Umwandlung der Zeichen wird direkt im Åbergebenen String
vorgenommen, d.h. der Åbergebene String wird (!I)geÑndert(!i)!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_alltrim, Ast_rtrim
!end_enumerate

!end_node


!begin_node Ast_mergeASCIIZZ

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  ASCIIZZ-String in en Array von Strings splitten

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_mergeASCIIZZ( const char **strings,
                             const int16 anzahl, const int16 global )

 !item [Pascal:]            Function Ast_mergeASCIIZZ(
                                   strings: Array of Pointer;
                                   anzahl, global: int16
                                ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_mergeASCIIZZ ist quasi die Umkehrfunktion zu
Ast_splitASCIIZZ. Das String-Array strings, das 'anzahl' Strings
enthÑlt, wird in einen ASCIIZZ-String umgewandelt. Falls global=TRUE
ist, wird hierfÅr globaler Speicher alloziert.

(!B)Hinweis:(!b) Der ASCIIZZ-String muû nach Gebrauch mittels Ax_free bzw.
Ax_glfree freigegeben werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen, GEMScript

  !item Ast_countASCIIZZ, Ast_deleteAry
!end_enumerate

!end_node


!begin_node Ast_reverse

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen String rÅckwÑrts "lesen"

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_reverse( char *reverse, const char
                    *string );

 !item [Pascal:]            Function Ast_reverse( reverse, string : Pointer) :
                    Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_reverse dreht den String 'string' zeichenweise um,
d.h. das erste Zeichn in 'reverse' ist das letzte Zeichen von
ûstring', das letzte Zeichen von 'reverse' ist das erste Zeichen von
'string'.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen
!end_enumerate

!end_node


!begin_node Ast_rtrim

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abschlieûende Leerzeichen entfernen

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_rtrim( char *string );

 !item [Pascal:]            Function Ast_rtrim( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_rtrim schneidet alle nachfolgende Leerzeichen ab,
entfernt also alle rechts im String stehenden Leerzeichen.

(!B)Hinweis:(!b) Die Umwandlung der Zeichen wird direkt im Åbergebenen String
vorgenommen, d.h. der Åbergebene String wird (!I)geÑndert(!i)!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_alltrim, Ast_ltrim
!end_enumerate

!end_node


!begin_node Ast_splitASCIIZZ

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  ASCIIZZ-String in ein Array von Strings splitten

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 int16 Ast_splitASCIZZ( const char *asciizz,
                             char ***strings, int16 *anz )

 !item [Pascal:]            Function Ast_splitASCIZZ(
                                   string: Pointer;
                                   Var strings: array of Pointer;
                                   Var anz: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_splitASCIZZ bestimmt die Anzahl der Strings und
splittet sie in ein Array normaler C-Strings auf. Das Array und die
Anzahl wird Åber die Åbergebenen Parameter geliefert, die Funktion
gibt an, ob sie Erfolg oder Miûerfolg (z.B. Speichermangel) hatte.

(!B)Hinweis:(!b) Das erzeugte Array muû nach Gebracuh mittels Ast_deleteAry
freigegeben werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen, GEMScript

  !item Ast_countASCIIZZ, Ast_mergeASCIIZZ, Ast_deleteAry
!end_enumerate

!end_node


!begin_node Ast_tolower

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  String in Kleinbuchstaben wandeln

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_tolower( char *string );

 !item [Pascal:]            Function Ast_tolower( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_tolower wandelt alle Buchstaben eines Strings in
Kleinbuchstaben um, die Umlaute 'é', 'ô' und 'ö' werden hierbei im
Gegensatz zu strlwr korrekt behandelt.

(!B)Hinweis:(!b) Die Umwandlung der Zeichen wird direkt im Åbergebenen String
vorgenommen, d.h. der Åbergebene String wird (!I)geÑndert(!i)!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_toupper
!end_enumerate

!end_node


!begin_node Ast_toupper

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  String in Groûbuchstaben wandeln

 !item [Kategorie:]         String-Funktionen

 !item [C:]                 char *Ast_toupper( char *string );

 !item [Pascal:]            Function Ast_toupper( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ast_toupper wandelt alle Buchstaben eines Strings in
Groûbuchstaben um, die Umlaute 'Ñ', 'î' und 'Å' werden hierbei im
Gegensatz zu strupr korrekt behandelt.

(!B)Hinweis:(!b) Die Umwandlung der Zeichen wird direkt im Åbergebenen String
vorgenommen, d.h. der Åbergebene String wird (!I)geÑndert(!i)!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item String-Funktionen

  !item Ast_tolower
!end_enumerate

!end_node


!begin_node AS_ACCLOSED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Accessory wurde geschlossen

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das Programm lÑuft als Accessory und hat gerade die GEM-Nachricht
AC_CLOSE empfangen. Das Fenster sollte gegebenenfalls eigene
Strukturen korrigieren, die das rabiate Verhalten von GEM nach sich
zieht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ALLOWBUBBLE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erlaubnis zur BubbleGEM-Hilfe

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *erlaubt;

 (!B)Pascal (in_out):(!b)   erlaubt: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es soll eine BubbleGEM-Hilfe zu einem Objekt aus dem Workobjekt oder
der Toolbar des Fensters angezeigt werden. Das Fenster soll prÅfen, ob
eine BubbleGEM-Hilfe generell mîglich ist oder nicht. In erlaubt soll
der Wert FALSE gespeichert werden, wenn die BubbleGEM-Hilfe abgelehnt
wird. Der Wert ist mit TRUE vorbelegt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ASKHELP

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Fenster zur Hilfe-Anzeige ermitteln

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [AwindowPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bist Du ein Hilfe-Fenster, das Daten gemÑû AS_HELP ausgeben kann? Dann
sollte in 'wind' ein Zeiger auf die eigene Fensterstruktur eingetragen
werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ASKLAZY

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  LAZy-Shell-Werkzeuge-Fenster ermitteln

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [AwindowPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bist Du ein LAZy-Shell-Werkzeuge-Fenster? Dann sollte in 'wind' ein
Zeiger auf die eigene Fensterstruktur eingetragen werden.

Genauere Infos bitte in der Dokumentation zur LAZy-Shell nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ASKFILE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Fenster zur Dateiverzeichnis-Anzeige ermitteln

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [AwindowPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bist Du ein Fenster zur Dateiverzeichnis-Anzeige? Dann sollte in
'wind' ein Zeiger auf die eigene Fensterstruktur eingetragen werden.

(!B)Hinweis:(!b) Genauere Infos bitte in der Dokumentation zur LAZy-Shell
nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ASKNOTIO

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Notio-Fenster ermitteln

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [AwindowPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bist Du ein Notio-Fenster? Dann sollte in 'wind' ein Zeiger auf die
eigene Fensterstruktur eingetragen werden.

Genauere Infos bitte in der Dokumentation zu Notio nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ASKTURNUS

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TurnUs-Fenster ermitteln

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [AwindowPtr]);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bist Du ein TurnUs-Fenster? Dann sollte in 'wind' ein Zeiger auf die
eigene Fensterstruktur eingetragen werden.

Genauere Infos bitte in der Dokumentation zu TurnUs nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_ASK_STGUIDE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Nachfragen vor Anzeigen der ST-Guide-Hilfe

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        AGetSTGuide *data;

 (!B)Pascal (in_out):(!b)   data: ^AGetSTGuide;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Dem Fenster werden die Daten fÅr die ST-Guide-Hilfe zur PrÅfung
Åbergeben. In der Åbergebenen Struktur sind der Hilfe-Titel sowie ggf.
der Dateiname enthalten. Die Strings kînnen modifiziert werden.

(!B)Beispiel:(!b) Um das Hilfe-Thema zu modifizieren, sollte man wie folgt
vorgehen:

     data->hyp_title=Ast_create("Neues Hilfethema");

(!B)Beispiel:(!b) Soll keine Hilfe angezeigt werden, so sollte man
folgendermaûen vorgehen:

     data->hyp_title=NULL;

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_CHECKDELETE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  LîschfÑhigkeit von Objekten aus Objekt-Liste
                    signalisieren?

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *ok;

 (!B)Pascal (in_out):(!b)   in_out: ok: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es sollen Objekte des Fensters gelîscht werden. Dem zugehîrigen
Fenster wird diese Nachricht zugesandt. Das Fenster ÅberprÅft die
Liste Aselect.array um zu entscheiden, ob visuell die LîschfÑhigkeit
signalisiert werden soll. In ok soll der Wert FALSE stehen, wenn das
Lîschen abgelehnt wird. Der Wert TRUE ist vorbelegt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_CHECKDRAG

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Annahmebereitschaft beim Draggen in geîffnetes
                    Fenster signalisieren?

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 pass[2];

 (!B)Pascal (in_out):(!b)   pass: ^Array [0..1] of Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es wurden Objekte auf ein annehmendes Objekt gezogen. Dem zugehîrigen
Fenster wird diese Nachricht zugesandt. Das Fenster ÅberprÅft die
Auswahl-Liste und den Parameter pass, um zu entscheiden, ob visuell
die Annahmebereitschaft signalisiert werden soll.

 pass[0]  enthÑlt die Objektnummer des annehmenden (Fenster-)Objektes

 pass[1]  soll der Wert FALSE gewiesen werden wenn die Annahme
          abgelehnt wird. Der vorbelegte Wert ist TRUE.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_CHECKDRAGGED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Annahmebereitschaft beim Draggen auf geschlossenes
                    Fenster signalisieren?

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *ok;

 (!B)Pascal (in_out):(!b)   ok: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es wurden Objekte auf eine annehmende Fensterikone gezogen, die ein
geschlossenes Fenster reprÑsentiert. Dem zugehîrigen Fenster wird
diese Nachricht zugesandt. Das Fenster ÅberprÅft die Auswahl-Liste, um
zu entscheiden, ob visuell die Annahmebereitschaft signalisiert werden
soll. In ok soll der Wert FALSE gespeichert werden, wenn die Annahme
abgelehnt wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_CEWS_BASE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!I)ACSpro(!i)-CEWS-interne Nachricht...

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten
!end_blist

Genauere Infos bitte in der Dokumentation bzw. im Source zu CEWS
nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_CEWS_ACSSAVE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!I)ACSpro(!i)-CEWS-interne Nachricht...

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten
!end_blist

Genauere Infos bitte in der Dokumentation bzw. im Source zu CEWS
nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_CONFIGDRAG

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Konfiguration des Draggens

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 pass[14];

 (!B)Pascal (in_out):(!b)   pass: ^Array [0..13] of Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es sollen Objekte des Fensters gezogen werden. Dem zugehîrigen Fenster
wird diese Nachricht zugesandt. Es soll die Åbergeben Konfiguration
geeignet modifizieren.

Die Komponenten enthalten hierbei folgende Daten (in Klammern die
Default-Werte, die modifiziert werden kînnen)

!begin_xlist [pass[6-13]]
 pass[0]    X RastersprÅnge (1)

 pass[1]    Y RastersprÅnge (1)

 pass[2]    X-Position des erlaubten Ziehrechtecks (voller Desktop)

 pass[3]    Y-Position des erlaubten Ziehrechtecks (voller Desktop)

 pass[4]    Breite (W) des erlaubten Ziehrechtecks (voller Desktop)

 pass[5]    Hîhe (H) des erlaubten Ziehrechtecks (voller Desktop)

 pass[6-13] Hier stehen die Mausform-Indizes. Default ist Form 3, die
            schiebende Hand. Es wird je nach Tastenzustand der
            Sondertasten der folgende Index aus dem Feld pass geholt:

!begin_xlist [pass[13]]
             !item [pass[6]] <keine Sondertasten gedrÅckt>

             !item [pass[7]] SHIFT

             !item [pass[8]] CONTROL

             !item [pass[9]] SHIFT + CONTROL

             !item [pass[10]] ALT

             !item [pass[11]] SHIFT + ALT

             !item [pass[12]] CONTROL + ALT

             !item [pass[13]] SHIFT + CONTROL + ALT
!end_xlist
!end_xlist

(!B)Querverweise:(!b)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_DELETE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen von Objekten der Auswahl-Liste

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es sind Objekte des Fensters in der Auswahlliste. Das Fenster wird
angewiesen diese zu lîschen. Beim Desktop werden eigene angewÑhlte
Objekte gelîscht, welche in der Auswahlliste Aselect aufgefÅhrt sind.
Der Papierkorb und das NEU-Symbol beim generischen Desktop DESKTOP
kînnen nicht gelîscht werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_DOARCHIVE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (Bitte in der Dokumentation der LAZy-Shell
                    nachschlagen)

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Genauere Infos bitte in der Dokumentation zur LAZy-Shell nachschlagen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_DRAGABORTED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ziehen von Objekten auf fremde Fenster

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *wi_nr;

 (!B)Pascal (in_out):(!b)   wi_nr: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Ziehoperation wurde auf fremden Fenster beendet. Es wird die
Fensternummer des fremden Fensters Åbergeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_DRAGGED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ziehen von Objekten auf Icon des geschlossenen
                    Fensters

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es wurden entweder Objekte auf das ikonifizierte Fenster gezogen oder
von einem externen Kommunikationspartner an das Fenster gesandt. Im
zweiten Falle konnte kein Empfangsobjekt lokalisiert werden, so daû
Åber diese Nachricht das Fenster informiert wird. Das Fenster kann nun
geeignet darauf reagieren.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_EDITCHG

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  LÑngenÑnderung eines Textfeldes durch Text-Eingabe

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bei einer Texteingabe in einem GEM-Objekt wird dem aktiven Fenster
diese Nachricht Åbermittelt - genauer, wenn sich die FeldlÑnge
aufgrund der Eingabe Ñndert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_FOCUSCHG

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eingabefokus wird auf neues Feld gesetzt

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *tofield;

 (!B)Pascal (in_out):(!b)   tofield: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Der Eingabefokus soll auf ein anderes Feld gesetzt werden. Die Nummer
des neuen Eingabeobjektes wird Åbergeben. Das Fenster kann nun die
Konsistenz der Eingabe prÅfen. Das aktuelle Editfeld steht in
Awindow->ob_edit.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_HELP

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Hilfe-Fenster soll Hilfe anzeigen

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *mess;

 (!B)Pascal (in_out):(!b)   mess: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Ein zuvor per AS_ASKHELP ermitteltes Fenster soll nun eine Hilfe
ausgeben. Im (!I)ACSpro(!i)-(!I)GUI-Editor(!i) selbst ist ein solches Fenster nicht
vorhanden, es kann jedoch als Modul nachgereicht werden! Es gibt ein
bestimmtes Format, um einfach und doch leistungsfÑhig die Hilfe zu
Åbermitteln.

In 'mess' steht ein fertiger Hilfe-Text-Pfad oder ein IMG-Pfad. Diese
Dateien werden in dem Hilfe-Fenster angezeigt. Einzelne 'Kapitel' als
dem Hilfe-Text werden ausgewÑhlt, indem nach dem Pfad - durch 'TAB'
getrennt - die öberschrift folgt; der Text wird dann nach '#' gefolgt
von der öberschrift am Zeilenanfang durchsucht. Ist die öberschrift
vorhanden, wird sie bis zum nÑchsten '#' oder dem Dateiende angezeigt.

Es kann auch direkt der anzuzeigende Text Åbergeben werden, dafÅr darf
dann keine Datei angegeben werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_GEM_MESS

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Unbekannte GEM-Nachricht empfangen

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *messbuff;

 (!B)Pascal (in_out):(!b)   Var messbuff: Array [0..7] of Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Wird eine unbekannte GEM-Nachricht empfangen, bekommt das Root-Fenster
diese Nachricht mit einem Zeiger auf die Nachricht zugeschickt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_GETBUBBLE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  BubbleGEM-Hilfe wird erfragt

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        AGetObjText *info;

 (!B)Pascal (in_out):(!b)   Var info: AGetObjTextPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es soll eine BubbleGEM-Hilfe zu einem Objekt aus dem Workobjekt oder
der Toolbar des Fensters angezeigt werden. Das Fenster soll fÅr das in
info angegebene Objekt den BubbleGEM-Text zur VerfÅgung stellen.

(!B)Hinweis:(!b) Diese Nachricht wird nur versandt, wenn es sich um ein
Standard-GEM-Objekt handelt oder das USERDEF die Nachricht
(!link [AUO_GETBUBBLE] [AUO_GETBUBBLE]) nicht kennt. Wie (!I)ACSpro(!i) bei der BubbleGEM-Hilfe vorgeht,
ist beim BubbleGEM-Protokoll erlÑutert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
   !item AGetObjText
!end_enumerate

!end_node


!begin_node AS_ICONIZED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Fenster wurde geschlossen und vom Root-Fenster
                    als Icon abgelegt

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das Fenster wurde automatisch ikonifiziert und kann nun geeignet
darauf reagieren.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_INFO

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Fenster soll Åber sich oder die Objekte der
                    Auswahl-Liste informieren

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das Fenster soll Åber sich informieren. Gehîrt die Auswahl-Liste
Aselect dem Fenster, kann auch Åber angewÑhlte Objekte berichtet
werden. Je nach Zustand der Auswahlliste informiert z.B. der
generische Desktop DESKTOP Åber sich selbst, NEU, Papierkorb oder
leitet angewÑhlten Fenstern die Nachricht weiter.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_LOADFILE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Programm soll eine Datei in den Editor laden

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Um zu vermeiden, daû jedes Modul die Routinen des Editor-Fensters
enthÑlt und damit ÅberflÅssigerweise Speicher auf Festplatte und im
Speicher benîtigt, kann in einem Programm (keinem Modul!) die
Nachricht AS_LOADFILE versandt werden. Das Programm lÑdt daraufhin die
in 'f' angegebene Datei in den integrierten (!link [Editor] [Userdef-Editor]).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_LOOKSTRING

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  In den internen Daten nach Eintrag suchen

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *txt;

 (!B)Pascal (in_out):(!b)   txt: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das Fenster soll in seinen internen Datenstrukturen nach einem Eintrag
suchen, der mit dem Text in 'txt' Åbereinstimmt - dies ist vor allem
bei Fenstern wichtig, die viele Daten zur VerfÅgung stellen, da
hiermit ein Fenster-Åbergreifendes Suchen ermîglicht wird. Ein
gefundener Eintrag sollte dann irgendwie kenntlich gemacht werden -
aber nicht durch einen modalen Dialog!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_MOUSE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Maus wurde Åber dem Fenster bewegt

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Maus wurde Åber dem Fenster bewegt. Die Koordinaten sind in den
globalen Variablen ev_mmox und ev_mmoy verfÅgbar.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_OPEN

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objekte der AUswahl-Liste sollen geîffnet werden

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Es sind Objekte des Fensters in der Auswahl-Liste. Das Fenster wird
aufgefordert diese zu îffnen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_PC_VERSION

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  BestÑtigung einer Hilfe-Aktion ist eingetroffen

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *help_version;

 (!B)Pascal (in_out):(!b)   help_version: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Eine BestÑtigung einer von (!I)ACSpro(!i) ausgelîsten PureC-Hilfe-Aktion ist
eingegangen, oder es wurde nach dem Versenden der Nachricht ein Fehler
entdeckt (Time-Out, Start einer zweiten (!link [PureC-Hilfe-Aktion] [PureC-Hilfe-Protokoll]) vor
Abschluû der ersten, etc.).

Diese Nachricht wird von (!I)ACSpro(!i) versandt, wenn dies beim Starten einer
PureC-Hilfe-Aktion angegeben wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_REALMENU_END

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abschluû der MenÅ-Bedienung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Zum Abschluû der MenÅ-Bedienung wird 'AS_REALMENU_END' an das Fenster
verschickt.

(!B)Achtung:(!b) Im Gegensatz zu der Echtzeitselektion muû der Programmierer
Sorge dafÅr tragen, daû sich das MenÅ und eine eventuelle Anzeige
aufgrund dieser Nachrichten nicht grafisch Åberlappen. Die einzige
Mîglichkeit besteht in der Auswertung der Ausmaûe des MenÅ-GEM-
Objektbaums!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALMENU_START, AS_REALMENU_UPDATE
!end_enumerate

!end_node


!begin_node AS_REALMENU_START

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Start der MenÅ-Bedienung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Startet der Anwender die MenÅfÅhrung eines Fensters, erhÑlt es zu
Beginn die Nachricht 'AS_REALMENU_START' mit einem int16-Zeiger auf
die Objektnummer, die das Popup ausgelîût hat.

(!B)Achtung:(!b) Im Gegensatz zu der Echtzeitselektion muû der Programmierer
Sorge dafÅr tragen, daû sich das MenÅ und eine eventuelle Anzeige
aufgrund dieser Nachrichten nicht grafisch Åberlappen. Die einzige
Mîglichkeit besteht in der Auswertung der Ausmaûe des MenÅ-GEM-
Objektbaums!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALMENU_UPDATE, AS_REALMENU_END
!end_enumerate

!end_node


!begin_node AS_REALMENU_UPDATE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  ObjektverÑnderung bei der MenÅ-Bedienung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bei einer ObjektverÑnderung bei der Bedienung wird
'AS_REALMENU_UPDATE' verschickt, das Fenster erhÑlt zusÑtzlich die
neue Popupobjektnummer Åbermittelt.

(!B)Achtung:(!b) Im Gegensatz zu der Echtzeitselektion muû der Programmierer
Sorge dafÅr tragen, daû sich das MenÅ und eine eventuelle Anzeige
aufgrund dieser Nachrichten nicht grafisch Åberlappen. Die einzige
Mîglichkeit besteht in der Auswertung der Ausmaûe des MenÅ-GEM-
Objektbaums!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALMENU_START, AS_REALMENU_END
!end_enumerate

!end_node


!begin_node AS_REALPOP_END

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abschluû der Popup-Steuerung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Zum Abschluû der Popup-Steuerung wird die Nachricht 'AS_REALPOP_END'
an das Fenster verschickt.

(!B)Achtung:(!b) Im Gegensatz zu der Echtzeitselektion muû der Programmierer
Sorge dafÅr tragen, daû sich das Popup und eine eventuelle Anzeige
aufgrund dieser Nachrichten nicht grafisch Åberlappen (z.B. durch
PrÅfen der absoluten Koordinaten des Popups) - denn weder Verlagern in
ein anderes Fenster, noch Verschieben nach links/oben/unten des Popups
garantieren, daû sich die Bereiche nicht einmal Åberlagern. Die
einzige Mîglichkeit besteht in der Auswertung der Ausmaûe des Popup-
GEM-Objektbaums!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALPOP_START, AS_REALPOP_UPDATE
!end_enumerate

!end_node


!begin_node AS_REALPOP_START

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beginn der Popup-Steuerung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Wird ein Popup vom Anwender bedient, erhÑlt das Ursprungsfenster zu
Beginn die Nachricht 'AS_REALPOP_START' mit einem int16-Zeiger auf die
Objektnummer, die das Popup ausgelîût hat.

(!B)Achtung:(!b) Im Gegensatz zu der Echtzeitselektion muû der Programmierer
Sorge dafÅr tragen, daû sich das Popup und eine eventuelle Anzeige
aufgrund dieser Nachrichten nicht grafisch Åberlappen (z.B. durch
PrÅfen der absoluten Koordinaten des Popups) - denn weder Verlagern in
ein anderes Fenster, noch Verschieben nach links/oben/unten des Popups
garantieren, daû sich die Bereiche nicht einmal Åberlagern. Die
einzige Mîglichkeit besteht in der Auswertung der Ausmaûe des Popup-
GEM-Objektbaums!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALPOP_UPDATE, AS_REALPOP_END
!end_enumerate

!end_node


!begin_node AS_REALPOP_UPDATE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  ObjektverÑnderung bei der Popup-Steuerung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Bei einer ObjektverÑnderung bei der Bedienung wird 'AS_REALPOP_UPDATE'
verschickt, das Fenster erhÑlt zusÑtzlich die neue Popupobjektnummer
(kann auch -1 sein) Åbermittelt.

(!B)Achtung:(!b) Im Gegensatz zu der Echtzeitselektion muû der Programmierer
Sorge dafÅr tragen, daû sich das Popup und eine eventuelle Anzeige
aufgrund dieser Nachrichten nicht grafisch Åberlappen (z.B. durch
PrÅfen der absoluten Koordinaten des Popups) - denn weder Verlagern in
ein anderes Fenster, noch Verschieben nach links/oben/unten des Popups
garantieren, daû sich die Bereiche nicht einmal Åberlagern. Die
einzige Mîglichkeit besteht in der Auswertung der Ausmaûe des Popup-
GEM-Objektbaums!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALPOP_START, AS_REALPOP_END
!end_enumerate

!end_node


!begin_node AS_REALSEL_END

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abschluû der Echtzeit-Selektion

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Wenn der Anwender die Auswahl beendet hat, bekommt das Fenster die
Nachricht 'AS_REALSEL_END' zugeschickt. Es steht jederzeit die
Auswahlliste Aselect zur VerfÅgung, die ausgewertet werden kann.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALSEL_START, AS_REALSEL_UPDATE
!end_enumerate

!end_node


!begin_node AS_REALSEL_START

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beginn der Echtzeit-Selektion

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Mit 'AS_REALSEL_START' wird dem eigenen Fenster mitgeteilt, daû der
Anwender eine neue Selektion gestartet hat. Es steht jederzeit die
Auswahlliste Aselect zur VerfÅgung, die ausgewertet werden kann.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALSEL_UPDATE, AS_REALSEL_END
!end_enumerate

!end_node


!begin_node AS_REALSEL_UPDATE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  VerÑnderung bei der Echtzeit-Selektion

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Nachricht 'AS_REALSEL_UPDATE' wird dem Fenster zugeschickt, wenn
sich die Auswahl geÑndert hat. Es steht jederzeit die Auswahlliste
Aselect zur VerfÅgung, die ausgewertet werden kann.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_REALSEL_START, AS_REALSEL_END
!end_enumerate

!end_node


!begin_node AS_REDRAWFILE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Dateibaum-Auffrischung wegen einer Pfad/Laufwerks-
                    énderung

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 !item [C (in_out):]        char *f;

 !item [Pascal (in_out):]   f: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Ein Fenster, das irgendwie einen aktuellen Dateibaum anzeigt und damit
auf AktualitÑt angewiesen ist, sollte aufgrund dieser Meldung seine
Darstellung auffrischen, denn ein Laufwerk/Pfad hat sich geÑndert. In
'f' kann(!) der Pfad, fÅr den das zutrifft drinstehen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_SAVEFILE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Aufforderung, die Daten zu sichern

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Wird in 'f' ein Dateiname Åbergeben, soll das Fenster diejenigen Daten
sichern, die unter diesem Dateinamen abgesichert werden, oder alle
seine Daten sichern, wenn NULL bzw. NIL Åbergeben wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_SCRAP_EXPORT

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten in das Klemmbrett exportieren

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *typ;

 (!B)Pascal (in_out):(!b)   typ: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Als Aufforderung, Daten ins Klemmbrett zu exportieren, sollte das
Fenster die Nachricht 'AS_SCRAP_EXPORT' interpretieren. Den
gewÅnschten Typ (!I)kann(!i) man in 'typ' Åbermittelt bekommen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_SCRAP_UPDATE, AS_SCRAP_IMPORT
!end_enumerate

!end_node


!begin_node AS_SCRAP_IMPORT

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten aus dem Klemmbrett importieren

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *typ;

 (!B)Pascal (in_out):(!b)   typ: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Als Aufforderung, Daten aus Klemmbrett zu importieren, sollte das
Fenster die Nachricht 'AS_SCRAP_IMPORT' interpretieren. Den Typ der
Datei (!I)kann(!i) man in 'typ' Åbermittelt bekommen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_SCRAP_UPDATE, AS_SCRAP_EXPORT
!end_enumerate

!end_node


!begin_node AS_SCRAP_UPDATE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Daten im Klemmbrett haben sich geÑndert

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Wenn sich der Inhalt des Klemmbretts Ñndert (z.B. durch Ascrp_put oder
per SC_CHANGED), wird dies den Fenstern durch die Mitteilung
'AS_SCRAP_UPDATE' angezeigt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_SCRAP_EXPORT, AS_SCRAP_IMPORT
!end_enumerate

!end_node


!begin_node AS_SELECTADD

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Auswahl-Liste wurde um ein Objekt erweitert

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *obnr;

 (!B)Pascal (in_out):(!b)   obnr: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Auswahl-Liste wurde um ein Objekt des Fensters ergÑnzt. Der Zeiger
referenziert die Nummer des Objektes.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_SELECTDEL

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Auswahl-Liste wurde um ein Objekt reduziert bzw.
                    komplett gelîscht

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        int16 *obnr;

 (!B)Pascal (in_out):(!b)   obnr: ^Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Auswahl-Liste wurde gelîscht bzw. um ein Objekt reduziert. Ist der
Zeiger NULL bzw. NIL, so wurde die Liste komplett gelîscht, sonst
zeigt er auf die Nummer des entfernten Objektes.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_SELECTFILE

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Datei-Fenster soll Datei mit selektieren oder
                    Selektion lîschen

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Ein Fenster, das einen Dateibaum oder -ausschnitt darstellt, sollte
aufgrund dieser Meldung die in 'f' Åbergebene Datei mit in die
Auswahlliste aufnehmen, oder alle selektierten Dateien aus der Auswahl
entfernen, wenn NULL/NIL Åbergeben wurde.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_SHADED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Fenster ist nun im Zustand "shaded"

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das System hat des Fenster "shaded", d.h. zugeklappt. Der (!link [Zustand] [Awindow.state])
(!link [AWS_SHADED] [AWS_SHADED]) wurde bereits gesetzt, das Fenster wird darÅber informiert,
daû es nun shaded ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_UNSHADED
!end_enumerate

!end_node


!begin_node AS_TERM

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Fenster soll gelîscht und freigegeben werden

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Dies ist der wichtigste Dienst und er (!B)muû(!b) von allen Fenstern bedient
werden. Der Dienst darf verweigert werden, wenn das Flag appexit auf
FALSE steht. Wenn das Flag appexit auf TRUE gesetzt ist, muû das
Fenster seine Datenstrukturen freigeben und anschlieûend das Fenster
lîschen. Ein Nachfragen, ob gewisse Daten gesichert werden sollen, ist
erlaubt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item appexit
!end_enumerate

!end_node


!begin_node AS_UNSHADED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Fenster ist nicht mehr im Zustand "shaded"

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das System hat des Fenster "unshaded", d.h. aufgeklappt. Der (!link [Zustand] [Awindow.state])
(!link [AWS_SHADED] [AWS_SHADED]) wurde bereits zurÅckgesetzt, das Fenster wird darÅber
informiert, daû es nun wieder voll zu sehen ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_SHADED
!end_enumerate

!end_node


!begin_node AS_UNTOPPED

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Applikation tritt in den Hintergrund

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

In einer Multitasking-Umgebung ist eine andere Applikation nach oben
gekommen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node AS_WIAUTOPOS

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Fenster wurde automatisch positioniert

 !item [Kategorie:]         Vordefinierte Fenster-Nachrichten

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Das Fenster wurde automatisch positioniert. Die x/y-Werte stehen in
wi->wi_act.x bzw. wi->wi_act.y). Sie dÅrfen geeignet korriert werden.
Das Standardverfahren berechnet aus der Fenster-ID wi->wi_id die
Werte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten
!end_enumerate

!end_node


!begin_node Ate_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TEDINFO-Struktur duplizieren

 !item [Kategorie:]         Tedinfo-Funktionen

 !item [C:]                 TEDINFO *Ate_create( const TEDINFO* tedi );

 !item [Pascal:]            Function Ate_create( tedi: TEDINFOPtr ) :
                    TEDINFOPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ate_create erzeugt eine exakte Kopie eienr Åbergebenen
TEDINFO-Struktur. FÅr das Erzeugen der Strings innerhalb der Struktur
wird Ast_create verwendet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Tedinfo-Funktionen

  !item Ate_delete

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Ate_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TEDINFO-Struktur freigeben

 !item [Kategorie:]         Tedinfo-Funktionen

 !item [C:]                 void Ate_delete( TEDINFO *tedi );

 !item [Pascal:]            Procedure Ate_delete( tedi : TEDINFOPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ate_delete gibt den Speicherplatz einer TEDINFO-Struktur
wieder frei.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Tedinfo-Funktionen

  !item Ate_create

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Auo_boxed

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine des Objektes Userdef-BoxEdit

 !item [Kategorie:]         (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte]), USerdef-(!link [BoxEdit] [BoxEdit])

 !item [C:]                 int16 Auo_boxed( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_boxed(
                                   entry: ACSOBJECTPtr;
                                   task: Integer
                                ) : Integer

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Service-Routine des Userdefs-
(!link [BoxEdit] [BoxEdit]) dar.

Nachrichten, die die Cursorposition oder Selektion betreffen, werden
nur dann bearbeitet, wenn dieses Objekt momentan auch den Cursor
besitzt. Operationen, die den Text verÑndern (einfÅgen, lîschen),
beachten als erstes immer eine Selektion! FÅr fast alle Operationen
muû dem Userdef seine IdentitÑt mittels (!link [AUO_SELF] [AUO_SELF]) mitgeteilt worden
sein, andernfalls wird die Nachricht nicht bearbeitet.

Folgende Nachrichten - mit ihren Datentypen fÅr den Zeiger in_out -
werden bearbeitet:

!begin_xlist [AUO_BESETSELECT]
 !item [AUO_CREATE]       Die internen Datenstrukturen werden angelegt und
                  initialisiert.

                       FÅr Pure-C: int16 *success;

                       FÅr Pure-Pascal: success: Integer;

 !item [AUO_SELF]         Setzt die IdentitÑt des Userdefs Åber den Parameter
                  in_out, der auf eine Awiob-Struktur verweist.

                       FÅr Pure-C: Awiob *ident;

                       FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_OWNER]        Holt die IdentitÑt des Userdefs und fÅllt die Åber
                  den Parameter Åbergebene Awiob-Struktur.

                       FÅr Pure-C: Awiob *ident;

                       FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_TERM]         Gibt die internen Strukturen wieder frei.

 !item [AUO_SETVAL]       Legt einen neuen Text fest.

                       FÅr Pure-C: char *text;

                       FÅr Pure-Pascal: text: Pointer;

 !item [AUO_GETVAL]       Ermittelt den Text, wobei eine Selektion beachtet
                  wird!

                       FÅr Pure-C: char **text;

                       FÅr Pure-Pascal: text: Pointer;

 !item [AUO_FULLUPDATE]   Zeichnet das Objekt komplett neu.

 !item [AUO_UPDATE]       Zeichnet die nîtigen Teile neu.

 !item [AUO_BEGIN]        Setzt den Cursor an den Anfang.

 !item [AUO_END]          Setzt den Cursor ans Textende.

 !item [AUO_POS]          Setzt die Position auf diesen Wert.

                       FÅr Pure-C: int16 *new_pos;

                       FÅr Pure-Pascal: new_pos: ^Integer;

!label AUO_BEINCPOS
 !item [AUO_BEINCPOS]     Setzt den Cursor eine Position weiter.

!label AUO_BEDECPOS
 !item [AUO_BEDECPOS]     Setzt den Cursor eine Position zurÅck.

!label AUO_BEINCWPOS
 !item [AUO_BEINCWPOS]    Setzt den Cursor ein Wort weiter.

!label AUO_BEDECWPOS
 !item [AUO_BEDECWPOS]    Setzt den Cursor ein Wort zurÅck.

!label AUO_BEINSCHAR
 !item [AUO_BEINSCHAR]    FÅgt einen an der aktuellen Position Buchstaben ein.

                       FÅr Pure-C: char *new_char;

                       FÅr Pure-Pascal: new_char: Pointer;

!label AUO_BEINSTEXT
 AUO_BEINSTEXT    FÅgt Text in der aktuellen Position Buchstaben ein
                  und markiert diesen.

!label AUO_BESETSELECT
 !item [AUO_BESETSELECT]  Setzt die Selektion auf Start (sel[0]) und Ende
                  (sel[1]). Dabei wird immer sel[1] in den sichtbaren
                  Bereich geschoben.

                       FÅr Pure-C: int16 *sel;

                       FÅr Pure-Pascal: sel: ^Integer;

!label AUO_BEGETSELECT
 !item [AUO_BEGETSELECT]  Ermittelt die Selektion analog zu oben.

!label AUO_BEBS
 !item [AUO_BEBS]         Lîscht den Buchstaben links vom Cursor.

!label AUO_BEBSW
 !item [AUO_BEBSW]        Lîscht das Wort links vom Cursor.

!label AUO_BEBSLINE
 !item [AUO_BEBSLINE]     Lîscht ab der aktuellen Position bis zum Anfang.

!label AUO_BEDEL
 !item [AUO_BEDEL]        Lîscht den Buchstaben rechts vom Cursor.

!label AUO_BEDELW
 !item [AUO_BEDELW]       Lîscht das Wort rechts vom Cursor.

!label AUO_BEDELLINE
 !item [AUO_BEDELLINE]    Lîscht ab der aktuellen Position bis zum Ende.

!label AUO_BEDELALL
 !item [AUO_BEDELALL]     Lîscht alles.

!label AUO_BEMASK
 !item [AUO_BEMASK]       Neben den internen Maskenindex kann auch eine frei
                  wÑhlbare Maske angegeben werden. Wird mit dieser
                  Nachricht nicht NULL/NIL Åbergeben, wird dieser Text
                  als Maske benutzt. NULL/NIL setzt wieder auf den
                  internen Maskenindex zurÅck.

                       FÅr Pure-C: char *mask;

                       FÅr Pure-Pascal: mask: Pointer;

!label AUO_BECHARLIST
 !item [AUO_BECHARLIST]   LÑût fÅr das aktuelle Objekt ein Popup erscheinen,
                  aus dem heraus aus allen erlaubten Zeichen eines
                  ausgewÑhlt werden kann.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item BoxEdit (A_boxed/Aus_boxed)

  !item (!link [Benutzerdefinierte Objekte] [Benutzerdefinierte Objekte])
!end_enumerate

!end_node


!begin_node Auo_cycle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine des Userdef-Cycle

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Cycle

 !item [C:]                 int16 Auo_cycle( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_cycle(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die Service-Routine des Userdefs-Cycle dar.

Folgende Nachrichten - mit ihren Datentypen fÅr den Zeiger in_out -
werden bearbeitet:

!begin_xlist [AUO_CYCGETINDEX]
 !item [AUO_CREATE]      Die internen Datenstrukturen werden angelegt und
                 initialisiert.

                      FÅr Pure-C: int16 *success;

                      FÅr Pure-Pascal: success: Integer;

 !item [AUO_SELF]        Setzt die IdentitÑt des Userdefs Åber den Parameter
                 in_out, der auf eine Awiob-Struktur verweist.

                      FÅr Pure-C: Awiob *ident;

                      FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_TERM]        Gibt die internen Strukturen wieder frei

 !item [AUO_SETVAL]      Setzt Wert im Displayfeld

                      FÅr Pure-C: char *DispString;

                      FÅr Pure-Pascal: DispString: Pointer;

 !item [AUO_GETVAL]      Gibt Zeiger auf aktuellen Displaywert zurÅck

                      FÅr Pure-C: char *DispString;

                      FÅr Pure-Pascal: DispString: Pointer;

 !item [AUO_FULLUPDATE]  Erzwingt ein Fullupdate und setzt den Deltamode
                 zurÅck

 !item [AUO_UPDATE]      Frischt nur das Notwendigste auf. Im Deltamode wird
                 nur der Displaytext neu gezeichnet.

!label [AUO_CYCINDEX]
 !item [AUO_CYCINDEX]    Springt auf den N-ten Eintrag.

                      FÅr Pure-C: int16 *EntryNr;

                      FÅr Pure-Pascal: EntryNr: ^Integer;

!label [AUO_CYCGETINDEX]
 !item [AUO_CYCGETINDEX] Gibt den aktuellen Index zurÅck

                      FÅr Pure-C: int16 *EntryNr;

                      FÅr Pure-Pascal: EntryNr: ^Integer;

!label [AUO_CYCPOPUP]
 !item [AUO_CYCPOPUP]    Setzt einen neuen Popupstring

                      FÅr Pure-C: char *PopString;

                      FÅr Pure-Pascal: PopString: Pointer;
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Cycle (A_cycle/Aus_cycle)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Auo_editor

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine des Userdef-Editor

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Editor

 !item [C:]                 int16 Auo_editor( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_editor(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Service-Routine des Userdefs-
Editor dar.

Der Editor bearbeitet Zeilen, die von 0 ab gezÑhlt werden. Vom
Speicherplatz abgesehen kînnen unbegrenzt viele Zeile eingetragen
werden. Folgende Nachrichten - mit ihren Datentypen fÅr den Zeiger
in_out - werden bearbeitet:

!begin_xlist [AUO_EDSELECTWORD]
 !item [AUO_CREATE]        Die internen Datenstrukturen werden angelegt und
                   initialisiert.

                        FÅr Pure-C: int16 *success;

                        FÅr Pure-Pascal: success: Integer;

 !item [AUO_TERM]          Gibt die internen Strukturen wieder frei.

 !item [AUO_SELF]          Setzt IdentitÑt fÅr eigene 'Aktionen'

                        FÅr Pure-C: Awiob *ident;

                        FÅr Pure-Pascal: ident: AwiobPtr;

                   (!B)Wichtig(!b): Diese Informationen mÅssen dem Userdef-
                   Editor bekannt sein, wenn selbstÑndige Aktionen
                   ausgefÅhrt werden mÅssen!

 !item [AUO_OWNER]         Holt IdentitÑt zurÅck.

                        FÅr Pure-C: Awiob *ident;

                        FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_FULLUPDATE]    Frischt das Objekt komplett auf. Der Deltamode wird
                   gelîscht.

 !item [AUO_UPDATE]        Frischt die notwendigen Teile des Editors sowie der
                   vom Editor angesteuerten Slider auf. Welche Teile
                   notwendig sind, hÑngt von den vorangegangenen
                   Operationen ab.

 !item [AUO_SETVAL]        Tauscht den Text der aktuellen Zeile gegen den
                   neuen aus.

                        FÅr Pure-C: char *Text;

                        FÅr Pure-Pascal: Text: Pointer;

 !item [AUO_GETVAL]        Gibt den Zeiger auf den Text der aktuellen Zeile
                   zurÅck.

 !item [AUO_NEXT]          Die nÑchste Zeile wird zur aktuellen.

 !item [AUO_PREV]          Die vorige Zeile wird zur aktuellen.

 !item [AUO_NEXTPAGE]      Die Zeile eine Seite weiter wird zur aktuellen.

 !item [AUO_PREVPAGE]      Die Zeile eine Seite zuvor wird zur aktuellen.

 !item [AUO_BEGIN]         Die erste Zeile wird zur aktuellen.

 !item [AUO_END]           Die letzte Zeile wird zur aktuellen.

 !item [AUO_POS]           Die Åbergebene Zeile wird zur aktuellen.

                        FÅr Pure-C: long *NewLineNr;

                        FÅr Pure-Pascal: NewLineNr: ^LongInt;

!label AUO_EDCURSOR
 !item [AUO_EDCURSOR]      Setzt die Cursorform. Hierbei bedeutet 0=Strich,
                   1=Unterstrich, 2=Block, 3=Rahmen

                        FÅr Pure-C: int16 *NewCursForm;

                        FÅr Pure-Pascal: NewCursForm: ^Integer;

!label AUO_EDSELECTWORD
 !item [AUO_EDSELECTWORD]  Selektiert das Wort unter dem Cursor. Ist die
                   Selektion eingeschaltet, wird der Selektionsbeginn
                   genommen.

!label AUO_EDGETNEED
 !item [AUO_EDGETNEED]     Ermittelt den Speicherbedarf, den der Text
                   benîtigt.

                        FÅr Pure-C: long *ByteNeeded;

                        FÅr Pure-Pascal: ByteNeeded: ^LongInt;

!label AUO_EDRESET
 !item [AUO_EDRESET]       Lîscht das Dirtyflag. Das Dirtyflag zeigt an, ob
                   énderungen vorgenommen wurden.

!label AUO_EDGETCHANGED
 !item [AUO_EDGETCHANGED]  Meldet den Zustand des Dirtyflags zurÅck.

                        FÅr Pure-C: int16 *dirty;

                        FÅr Pure-Pascal: dirty: ^Integer;

!label AUO_EDFIND
 !item [AUO_EDFIND]        Sucht den Åbergebenen String. Die Suche kann
                   konfiguriert werden. Bei Erfolg wird die nÑchste
                   Fundstelle selektiert.

                        FÅr Pure-C: char *SearchText;

                        FÅr Pure-Pascal: SearchText: Pointer;

!label AUO_EDWORD
 !item [AUO_EDWORD]        Es wird die wortweise Suche eingeschaltet.

!label AUO_EDNOWORD
 !item [AUO_EDNOWORD]      Es wird die wortweise Suche ausgeschaltet.

!label AUO_EDBACKWARD
 !item [AUO_EDBACKWARD]    Es wird rÅckwÑrts gesucht.

!label AUO_EDFORWARD
 !item [AUO_EDFORWARD]     Es wird vorwÑrts gesucht.

!label AUO_EDNOCASE
 !item [AUO_EDNOCASE]      Groû/Kleinschreibung wird nicht unterschieden.

!label AUO_EDCASE
 !item [AUO_EDCASE]        Groû/Kleinschreibung wird unterschieden.

!label AUO_EDBLOCKMODE
 !item [AUO_EDBLOCKMODE]   Es wird zurÅckgemeldet, ob der Blockmode (2-Dim)
                   eingeschaltet ist.

                        FÅr Pure-C: int16 *IsBlockMode;

                        FÅr Pure-Pascal: IsBlockMode: ^Integer;

!label AUO_EDRESIZE
 !item [AUO_EDRESIZE]      Das Objekt wird von den Ausmaûen an den aktuellen
                   Font und Hîhe angepaût.

!label AUO_EDCLEARUNDO
 !item [AUO_EDCLEARUNDO]   Lîscht den UNDO-Puffer.

!label AUO_EDUNDO
 !item [AUO_EDUNDO]        FÅhrt ein UNDO aus. Undo-fÑhig sind nur énderungen
                   mit AUO_EDSUB und AUO_EDUNDO selbst.

!label AUO_EDGETROW
 !item [AUO_EDGETROW]      Holt eine Zeile aus dem Text. Ist die Selektion
                   einschaltet wird nur der selektierte Bereich
                   Åbertragen. Wenn die Zeile nicht existiert, wird -
                   1 als ZeilenlÑnge zurÅckgegeben.

                   Die Struktur EDITGETS wird Åbergeben. Darin wird
                   die Zeilennummer angegeben und der Text und die
                   LÑnge zurÅckgegeben.

                        FÅr Pure-C: EDITGETS *GetRow;

                        FÅr Pure-Pascal: GetRow: EDITGETSPtr;

!label AUO_EDGETTABSIZE
 !item [AUO_EDGETTABSIZE]  Gibt aktuellen TAB-Sprung zurÅck

                        FÅr Pure-C: int16 *TabWidth;

                        FÅr Pure-Pascal: TabWidth: ^Integer;

!label AUO_EDTABSIZE
 !item [AUO_EDTABSIZE]     Setzt TAB-Sprung.

                        FÅr Pure-C: int16 *TabWidth;

                        FÅr Pure-Pascal: TabWidth: ^Integer;

!label AUO_EDSUB
 !item [AUO_EDSUB]         Ein Text, der in der Struktur EDITSUBS aufgebaut
                   wurde, wird Åbergeben - es kann ein Bereich ersetzt
                   oder neu eingefÅgt werden. Diese Operationen ist
                   UNDO-fÑhig.

                        FÅr Pure-C: EDITSUBS *TextDescr;

                        FÅr Pure-Pascal: TextDescr: EDITSUBSPtr;

!label AUO_EDGETROWS
 !item [AUO_EDGETROWS]     Gibt die Anzahl der Zeilen zurÅck.

                        FÅr Pure-C: long *LineNr;

                        FÅr Pure-Pascal: LineNr: ^LongInt;

!label AUO_EDGETLENGTH
 !item [AUO_EDGETLENGTH]   Gibt die LÑnge der aktuellen Zeile zurÅck.

                        FÅr Pure-C: long *LineLen;

                        FÅr Pure-Pascal: LineLen: ^LongInt;

!label AUO_EDGETCURPOS
 !item [AUO_EDGETCURPOS]   Gibt die aktuelle Cursorposition zurÅck.

                        FÅr Pure-C: long *GetCursRow;

                        FÅr Pure-Pascal: GetCursRow: ^LongInt;

!label AUO_EDUNSELECT
 !item [AUO_EDUNSELECT]    Schaltet Selektion aus.

!label AUO_EDGETSELECT
 !item [AUO_EDGETSELECT]   TrÑgt den Selektionbereich in ein Feld mit 4 Werten
                   ein. Die Belegung des Feldes ist

                    0  Startzeile

                    1  Startspalte

                    2  Endezeile

                    3  Endespalte

                   Ist keine Selektion eingeschaltet wird im ersten
                   (Index 0) Eintrag -1 eingetragen.

                   Ist die diskontinuierliche Selelktion
                   eingeschaltet, muû das Feld mit

                        {0L, 0L, -1L, -1L}

                   initialisiert werden, jeder Aufruf liefert
                   sukzessive den nÑchsten Bereich zurÅck.

                        FÅr Pure-C: long GetSel[4];

                        FÅr Pure-Pascal:
                        GetSel: ARRAY [0..3] OF LongInt;

!label AUO_EDSETSELECT
 !item [AUO_EDSETSELECT]   Setzt analog wie AUO_EDGETSELECT die Selektionen.
                   Es kann keine 2-dimensionale Selektion gesetzt
                   werden!

!label AUO_EDCALL
 !item [AUO_EDCALL]        Setzt die Live-Routine. Der erste Eintrag zeigt auf
                   die Routine. Der Zweite auf einen Parameter, der
                   dieser mitgegeben wird.

                        FÅr Pure-C: EDITLIVE *LiveFkt;

                        FÅr Pure-Pascal: LiveFkt: EDITLIVEPtr;

                   Die Live-Routine muû folgenden Typ haben, wobei
                   'text' der Text der aktuellen Zeile ist, falls der
                   Selektionsmode AUO_ED1SELECT oder AUO_ED01SELECT
                   eingeschaltet ist, und einen Leerstring
                   andernfalls:

                        FÅr Pure-C:
                        void live( void *obj, char *text );

                        FÅr Pure-Pascal:
                        PROCEDURE live(obj: Pointer; text:
                        Pointer);

!label AUO_EDLIVE
 !item [AUO_EDLIVE]        Ruft die Live-Routine auf.

!label AUO_ED1SELECT
 !item [AUO_ED1SELECT]     Genau eine Zeile kann selektiert werden.

!label AUO_ED01SELECT
 !item [AUO_ED01SELECT]    Eine oder keine Zeile kann selektiert werden.

!label AUO_EDNSELECT
 !item [AUO_EDNSELECT]     Es kann ein kontinuierlicher Bereich selektiert
                   werden.

!label AUO_EDNMSELECT
 !item [AUO_EDNMSELECT]    Es kann diskontinuierlich selektier werden.

!label AUO_EDCHARSELECT
 !item [AUO_EDCHARSELECT]  Es wird der Characterselektionsmodus eingeschaltet.

!label AUO_EDBLKSELECT
 !item [AUO_EDBLKSELECT]   Es wird der Blockmodus (2-dimensionale Selektion)
                   eingeschaltet.

!label AUO_EDVIEW
 !item [AUO_EDVIEW]        Die Cursorposition soll in den sichtbaren Bereich
                   gelangen.

!label AUO_EDCURON
 !item [AUO_EDCURON]       Der Cursor wird eingeschaltet.

!label AUO_EDCUROFF
 !item [AUO_EDCUROFF]      Der Cursor wird ausgeschaltet.

!label AUO_EDCURHIDE
 !item [AUO_EDCURHIDE]     Der Cursor wird versteckt.

!label AUO_EDCURSHOW
 !item [AUO_EDCURSHOW]     Der Cursor wird wieder sichtbar.

!label AUO_EDCURPOS
 !item [AUO_EDCURPOS]      Setzt die Spaltenposition des Cursors.

                        FÅr Pure-C: long *NewCursColumn;

                        FÅr Pure-Pascal: NewCursColumn: ^LongInt;

!label AUO_EDGETPOS
 !item [AUO_EDGETPOS]      Holt die Nummer der aktuellen Zeile.

                        FÅr Pure-C: long *GetAktRow;

                        FÅr Pure-Pascal: GetAktRow: ^LongInt;

!label AUO_EDFONT
 !item [AUO_EDFONT]        Setzt eine neue Font-Id.

                        FÅr Pure-C: int16 *FontID;

                        FÅr Pure-Pascal: FontID: ^Integer;

!label AUO_EDHEIGHT
 !item [AUO_EDHEIGHT]      Setzt eine neue Pixelhîhe.

                        FÅr Pure-C: int16 *NewHeight;

                        FÅr Pure-Pascal: NewHeight: ^Integer;

!label AUO_EDCOLOR
 !item [AUO_EDCOLOR]       Setzt eine neue Textfarbe.

                        FÅr Pure-C: int16 *NewTextColor;

                        FÅr Pure-Pascal: NewTextColor: ^Integer;

!label AUO_EDCFULL
 !item [AUO_EDCFULL]       Setzt die maximale Anzahl von sichtbaren Spalten.

                        FÅr Pure-C: long *MaxVColumns;

                        FÅr Pure-Pascal: MaxVColumns: ^LongInt;

                   Das Maximum ist derzeit 512.

!label AUO_EDAPPLINE
 !item [AUO_EDAPPLINE]     Der Text wird an die aktuelle Zeile angehÑngt.

                        FÅr Pure-C: char *Text;

                        FÅr Pure-Pascal: Text: Pointer;

!label AUO_EDWRAP
 !item [AUO_EDWRAP]        Nach wievielen Zeilen sollen die ersten Zeilen
                   verloren werden? Bei Editoren sollte die Zahl
                   einfach sehr groû sein (z.B. 999 999 999).

                        FÅr Pure-C: long *WrapLines;

                        FÅr Pure-Pascal: WrapLines: ^LongInt;

                   (!B)Wichtig(!b): Der WRAP-Wert muû realistisch sein, da
                   alle Zeilen einmalig angefordert werden.

!label AUO_EDDELETE
 !item [AUO_EDDELETE]      Der ganze Textinhalt wird gelîscht.

!label AUO_EDUPDATE
 !item [AUO_EDUPDATE]      Der Editor wird ohne die Slider aufgefrischt.

!label AUO_EDHCOL
 !item [AUO_EDHCOL]        Setzt die Spalte, die links sichtbar wird.

                        FÅr Pure-C: long *LeftColumn;

                        FÅr Pure-Pascal: LeftColumn: ^LongInt;

!label AUO_EDHROW
 !item [AUO_EDHROW]        Setzt die Zeile, die oben sichtbar wird.

                        FÅr Pure-C: long *TopRow;

                        FÅr Pure-Pascal: TopRow: ^LongInt;

!label AUO_EDNEWLINE
 !item [AUO_EDNEWLINE]     FÅgt eine neue Zeile ans Ende an. Diese wird zur
                   aktuellen Zeile.

                   (!B)Wichtig(!b): Der WRAP-Wert muû realistisch sein, da
                   alle Zeilen einmalig angefordert werden.

!label AUO_EDVERSLIDER
 !item [AUO_EDVERSLIDER]   öbergibt die IdentitÑt des vertikalen Sliders.

!label AUO_EDHORSLIDER
 !item [AUO_EDHORSLIDER]   öbergibt die IdentitÑt des horizontalen Sliders.

!label AUO_EDSLIDERS
 !item [AUO_EDSLIDERS]     Nur die Slider werden aufgefrischt.

!label AUO_EDGETVCURPOS
 !item [AUO_EDGETVCURPOS]  Gibt die visuelle Cursorposition zurÅck. Wegen der
                   Tabs kann diese von der logischen Position
                   abweichen.

!label AUO_EDGETHCOL
 !item [AUO_EDGETHCOL]     Gibt die Nummer der linken sichtbaren Spalte
                   zurÅck.

!label AUO_EDGETHROW
 !item [AUO_EDGETHROW]     Gibt die Nummer der obersten sichtbaren Zeile
                   zurÅck.

!label AUO_EDGETERROR
 !item [AUO_EDGETERROR]    Holt den Fehlerstatus ab. Speichermangel setzt das
                   Bit 0. Damit kann man selber auf Fehler reagieren.

                        FÅr Pure-C: int16 *ErrStatus;

                        FÅr Pure-Pascal: ErrStatus: ^Integer;

!label AUO_EDRESETERROR
 !item [AUO_EDRESETERROR]  Setz das Fehler-Flag zurÅck.

!label AUO_EDPUTINFO
 !item [AUO_EDPUTINFO]     (wird nicht mehr unterstÅtzt)
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Editor (A_editor/Aus_editor)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Auo_ftext

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine des Userdef-FText

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-FText

 !item [C:]                 int16 Auo_ftext( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_ftext(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die Service-Routine des Userdefs-FText dar.

Diese Serviceroutine bearbeitet die folgenden Nachrichten - mit ihren
Datentypen fÅr den Zeiger in_out -, alle anderen Nachrichten werden an
die Funktion Auo_string weitergereicht:

!begin_xlist [AUO_FTEFFECTS]
!label AUO_FTFONT
 !item [AUO_FTFONT]       Setzt eine neue Fontid

                       FÅr Pure-C: int16 *fontID;

                       FÅr Pure-Pascal: fontID: ^Integer;

!label AUO_FTHEIGHT
 !item [AUO_FTHEIGHT]     Setzt die Hîhe von 0..255

                       FÅr Pure-C: int16 *fontHeight;

                       FÅr Pure-Pascal: fontHeight: ^Integer;

                  AUO_FTCOLOR

 !item [AUO_FTCOLOR]      Setzt neue Farbe des Textes 0..15

                       FÅr Pure-C: int16 *textColor;

                       FÅr Pure-Pascal: textColor: ^Integer;

                  AUO_FTEFFECTS

 !item [AUO_FTEFFECTS]    Setzt einen Effekt.

                   Bit 0  Fett

                   Bit 1  Hell

                   Bit 2  Kursiv

                   Bit 3  Unterstrichen

                   Bit 4  Hohl (Outlined)

                   Bit 5  Schattiert (ist sodokumentiert, funktioniert
                          bloû nicht :-(

                       FÅr Pure-C: int16 *effekt;

                       FÅr Pure-Pascal: effekt: ^Integer;

!label AUO_FTLEFT
 !item [AUO_FTLEFT]       Setzt linksbÅndig

!label AUO_FTRIGHT
 !item [AUO_FTRIGHT]      Setzt rechtsbÅndig

!label AUO_FTCENTER
 !item [AUO_FTCENTER]     Setzt zentriert

!label AUO_FTBLOCK
 !item [AUO_FTBLOCK]      Setzt Blocksatz
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item FText (A_ftext)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Auo_picture

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine des Userdef-Picture

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Picture

 !item [C:]                 int16 Auo_picture( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_picture(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Service-Routine des Userdef-
Picture dar.

Folgende Nachrichten - mit ihren Datentypen fÅr den Zeiger in_out -
werden bearbeitet:

!begin_xlist [AUO_FULLUPDATE]
 !item [AUO_CREATE]      Die internen Datenstrukturen werden angelegt und
                 initialisiert.

                      FÅr Pure-C: int16 *success;

                      FÅr Pure-Pascal: success: ^Integer;

 !item [AUO_TERM]        Gibt die internen Strukturen wieder frei.

!label AUO_PICMFDB
 !item [AUO_PICMFDB]     öbernimmt den neuen MFDB als Bild. Da Bilder recht
                 viel Speicherplatz brauchen, wird der MFDB nicht
                 kopiert. Das heiût aber, daû der MFDB so lange
                 existieren muû, bis ein neuer Åbergeben oder das
                 Userdef terminiert wird. Der MFDB muû im
                 Standardformat vorliegen!

 !item [AUO_SELF]        Setzt die IdentitÑt

                      FÅr Pure-C: Awiob *ident;

                      FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_FULLUPDATE]  Zeichnet das Objekt komplett neu.

 !item [AUO_UPDATE]      Zeichnet das Objekt komplett neu.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Picture (A_picture)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Auo_slider

!label Auo_wislider
!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine des Userdef-Slider

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Slider

 !item [C:]                 int16 Auo_slider( OBJECT *entry, int16 task,
                             void *in_out);
                    int16 Auo_wislider( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_slider(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer; Function Auo_wislider(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Service-Routine des Userdef-
Slider bzw. des Userdefs "Window-Slider" dar.

Folgende Nachrichten - mit ihren Datentypen fÅr den Zeiger in_out -
werden bearbeitet:

!begin_xlist [AUO_FULLUPDATE]
 !item [AUO_CREATE]      Die internen Datenstrukturen werden angelegt und
                 initialisiert.

                      FÅr Pure-C: int16 *success;

                      FÅr Pure-Pascal: success: Integer;

 !item [AUO_TERM]        Gibt die internen Strukturen wieder frei.

 !item [AUO_SELF]        Gibt dem Userdef die eigene IdentitÑt bekannt.

                      FÅr Pure-C: Awiob *ident;

                      FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_OWNER]       Die IdentitÑt des Userdefs wird ausgelesen. Hierzu
                 wird in in_out ein Zeiger auf die Awiob-Struktur
                 Åbergeben:

                      FÅr Pure-C: Awiob *ident;

                      FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_FULLUPDATE]  Frischt das Objekt komplett auf. Der Deltamode wird
                 gelîscht

 !item [AUO_UPDATE]      Frischt die notwendigen Teile des Slider auf. Welche
                 Teile notwendig sind. HÑngt von den vorangegangen
                 Operationen ab.

 !item [AUO_SETVAL]      (!I)nicht beim Fenster-Slider:(!i) Setzt den Text im Slider
                 neu (maximal 11 Zeichen).

                      FÅr Pure-C: char *text;

                      FÅr Pure-Pascal: text: Pointer;

 !item [AUO_GETVAL]      (!I)nicht beim Fenster-Slider:(!i) Gibt den Zeiger auf den
                 Slidertext zurÅck.

                      FÅr Pure-C: char *text;

                      FÅr Pure-Pascal: text: Pointer;

 !item [AUO_NEXT]        Geht einen Schritt weiter

 !item [AUO_PREV]        Geht einen Schritt zurÅck

 !item [AUO_NEXTPAGE]    Geht eine Seite vor

 !item [AUO_PREVPAGE]    Geht eine Seite zurÅck

 !item [AUO_BEGIN]       Springt an den Anfang

 !item [AUO_END]         Springt an das Ende

!label AUO_SLCALL
 !item [AUO_SLCALL]      Setzt die Liveroutine. öbergeben werden zwei Zeiger.
                 Der erste zeigt auf die Live-Routine. Der zweite
                 (obj) wird der Live-Routine beim Aufruf mitgegeben.

                      FÅr Pure-C: SLLIVE *LiveFkt;

                      FÅr Pure-Pascal: LiveFkt: SLLIVEPtr;

                 Die Live-Routine muû folgenden Typ haben (pos ist
                 hierbei die aktuelle Position):

                      FÅr Pure-C:
                      char *sl_live( void *obj, long pos );

                      FÅr Pure-Pascal:
                      FUNCTION live( obj: Pointer; pos: LongInt)
                      : Pointer;

                 Der RÅckgabewert wird als Slidertext verwendet.

!label AUO_SLFULL
 !item [AUO_SLFULL]      Setzt den vollen Bereich

                      FÅr Pure-C: long *set_full;

                      FÅr Pure-Pascal: set_full: ^LongInt

!label AUO_SLSIZE
 !item [AUO_SLSIZE]      Setzt die Slidergrîûe. Gleichzeitig ist dies die
                 Schrittweite bei Seitenoperationen.

                      FÅr Pure-C: long *set_size;

                      FÅr Pure-Pascal: set_size: ^LongInt

!label AUO_SLLEN
 !item [AUO_SLLEN]       (!I)nicht beim Fenster-Slider:(!i) Setzt die LÑnge des
                 Slidertextes.

                      FÅr Pure-C: long *set_len;

                      FÅr Pure-Pascal: set_len: ^LongInt

!label AUO_SLSTEP
 !item [AUO_SLSTEP]      Setzt die Schrittweite bei einzelnen Schritten.

                      FÅr Pure-C: long *set_step;

                      FÅr Pure-Pascal: set_step: ^LongInt

!label AUO_SLWIPOS
 !item [AUO_SLWIPOS]     (!I)nur beim Fenster-Slider:(!i) Setzt die Position direkt im
                 WF_HSLID/WF_WSLID-Format.

                      FÅr Pure-C: long *set_pos;

                      FÅr Pure-Pascal: set_pos: ^LongInt

 !item [AUO_POS]         Setzt die Position direkt.

                      FÅr Pure-C: long *set_pos;

                      FÅr Pure-Pascal: set_pos: ^LongInt

!label AUO_SLLIVE
 !item [AUO_SLLIVE]      Ruft die Live-Routine auf

!label AUO_SLGETPOS
 !item [AUO_SLGETPOS]    Ermittelt die aktuelle Position

                      FÅr Pure-C: long *get_pos;

                      FÅr Pure-Pascal: get_pos: ^LongInt
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Slider (A_slider/Aus_slider)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Auo_string

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Service-Routine der String Ñhnlichen Userdefs

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Checkbox,
                    Radio-Button, Userdef-3D-Button, Userdef-
                    Innerframe

 !item [C:]                 int16 Auo_string( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_string(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Service-Routine der Userdefs
Checkbox, Radiobutton, 3D-Button und Innerframe dar.

Folgende Nachrichten - mit ihren Datentypen fÅr den Zeiger in_out -
werden bearbeitet:

!begin_xlist [AUO_FULLUPDATE]
 !item [AUO_CREATE]      Der String der Vorlage (ub_ptr1) wird alloziert und
                 ub_ptr1 zugewiesen. Fehler werden durch zuweisen von
                 FAIL an die Åbergebene Variable *in_out bekannt
                 gegeben.

                      FÅr Pure-C: int16 *success;

                      FÅr Pure-Pascal: success: ^Integer;

 !item [AUO_SELF]        Setzt die IdentitÑt des Userdefs Åber den Parameter
                 in_out, der auf eine Awiob-Struktur verweist. Das
                 Fenster wird ub_ptr2 zugewiesen, die Objektnummer
                 wird in ub_ptr3 eingetragen.

                      FÅr Pure-C: Awiob *ident;

                      FÅr Pure-Pascal: ident: AwiobPtr;

 !item [AUO_TERM]        Der String wird freigegeben

 !item [AUO_SETVAL]      Ein neuer String wird eingetragen.

                      FÅr Pure-C: char *text;

                      FÅr Pure-Pascal: text: Pointer;

 !item [AUO_FULLUPDATE]
 !item [AUO_UPDATE]      In beiden FÑllen wird das Userdef neu gezeichnet,
                 sofern mit AUO_SELF ein Fenster eingetragen wurde
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Checkbox, Radiobutton (A_checkbox)

  !item 3D-Button (A_3Dbutton)

  !item Innerframe (A_innerframe)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Aus_boxed

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Klick-Routine des Objektes BoxEdit
                    (A_boxed/Aus_boxed)

 !item [Kategorie:]         Benutzerdefinierte Objekte, BoxEdit

 !item [C:]                 void Aus_boxed( void );

 !item [Pascal:]            Procedure Aus_boxed( void );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Mausselektion des Userdefs-
BoxEdit dar.

Ein einfacher Click positioniert den Cursor neu. Ein Doppelklick
selektiert das Wort, das durch separator getrennt wird - dabei sind
aufeinander folgende Trenner auch als Wort anzusehen.

Wird bei gedrÅckter Maustaste aus dem Onjekt herausgefahren, versucht
die Routine, den Text in zwei Geschwindigkeiten weiterzuscrollen und
die Selektion dementsprechend zu erweitern - beim Doppelklick
wortweise.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item BoxEdit (A_boxed/Auo_boxed)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Aus_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen eines Userdefs

 !item [Kategorie:]         Userdef-Funktionen

 !item [C:]                 AUSERBLK *Aus_create( const AUSERBLK *user );

 !item [Pascal:]            Function Aus_create(
                                   user: AUSERBLKPtr
                                ) : AUSERBLKPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aus_create erzeugt ein exaktes Duplikat in 'user'
Åbergebenen Userdefs. Das Userdef wird (!B)nicht(!b) mit AUO_CREATE
initialisiert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Userdef-Funktionen

  !item Aus_delete
!end_enumerate

!end_node


!begin_node Aus_cycle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Klick-Routine des Userdef-Cycle

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Cycle

 !item [C:]                 void Aus_cycle( void );

 !item [Pascal:]            Procedure Aus_cycle( void );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die komfortable Mausselektion des Userdefs-Cycle
dar.

Ein Klick auf den Pfeil nach unten (genauer auf die linken 3
Charpositionen) schaltet auf den nÑchsten Wert um.

Ein Klick auf das Displayfeld lÑût ein Popup erscheinen, wobei der
aktuelle Wert mit CHECKED gekennzeichnet ist. Nach Auswahl wird der
neue Wert in das Displayfeld Åbernommen.

Liveupdates kînnen dadurch realisiert werden, daû eine eigene click-
Routine zunÑchst Aus_cycle aufruft und anschlieûend den Wert
entsprechend umsetzt

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Cycle (A_cycle/Auo_cycle)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Aus_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Freigeben eines Userdefs

 !item [Kategorie:]         Userdef-Funktionen

 !item [C:]                 void Aus_delete( AUSERBLK *user );

 !item [Pascal:]            Procedure Aus_delete( user : AUSERBLKPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Aus_delete gibt den Speicherplatz der Åbergebenen
AUSERBLK-Struktur wieder frei. Das Userdef wird (!B)nicht(!b) mit AUO_TERM
beendet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Userdef-Funktionen

  !item Aus_create
!end_enumerate

!end_node


!begin_node Aus_editor

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Klick-Routine des Userdef-Editor

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Editor

 !item [C:]                 void Aus_editor( void );

 !item [Pascal:]            Procedure Aus_editor( void );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die Klick-Routine des Userdefs-Slider dar.

Diese click-Routine reagiert je nach Selektionmode wie folgt:

!begin_xlist [BLOCK]
 !item [CHAR]   Text-Selektion

         Aufziehen            Bereich wird selektiert

         Aufziehen + Shift    Bereich wird erweitert

         Doppelklick          Word bzw. Klammerbereich wird selektiert

         Doppelklick + Shift  ganze Zeile wird selektiert

 !item [BLOCK]  Text-Selektion

         Aufziehen          Bereich wird selektiert

         Aufziehen + Shift  Bereich wird erweitert

 !item [1]      Die aktuelle Zeile wird selektiert, die Live-Routine wird
        aufgerufen

 !item [01]     Die aktuelle Zeile wird selektiert bzw. deselektiert, die
        Live-Routine wird aufgerufen.

 !item [N]      Kontinuierliche Selektion

         Aufziehen          Bereich wird selektiert

         Aufziehen + Shift  Bereich wird erweitert

        Die Live-Routine wird aufgerufen.

 !item [NM]     Diskontinuierliche Selektion

         Aufziehen  ein weiterer Bereich wird selektiert

        Die Live-Routine wird aufgerufen.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Editor (A_editor/Auo_editor)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Aus_help

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Klick-Routine fÅr beliebige Objekte

 !item [Kategorie:]         Userdef-Funktionen

 !item [C:]                 void Aus_help( void );

 !item [Pascal:]            Procedure Aus_help( void );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine kann als Klick-Routine fÅr jedes beliebige Objekt
eingetragen werden. Sie verzweigt einfach in Awi_help fÅr das aktuelle
Fenster aus ACSblk->ev_window.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Aev_STGuideHelp, Awi_help
!end_enumerate

!end_node


!begin_node Aus_slider

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Klick-Routine des Userdef-Slider

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Slider

 !item [C:]                 void Aus_slider( void );

 !item [Pascal:]            Procedure Aus_slider( void );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Routine stellt die Klick-Routine des Userdefs-Slider dar.

Diese click-Routine reagiert bei einem Klick auf

!begin_xlist [Seitenbalken]
 !item [Pfeil]         Je nachdem, ob es sich um einen Einfach-Klick oder um
               einen Doppel-Klick handelt, reagiert die Routine wie
               folgt

                Klick         VerÑndern um einen Schritt.

                Doppelklick   Sprung an den Anfang bzw. das Ende.

 !item [Seitenbalken]  Sprung um eine Seite.

 !item [Slider]        Ziehen auf die Position. Bitte beachten Sie mit Ziehen
               nicht jede Position erreichbar ist.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Slider (A_slider/Auo_slider)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node Avdi_getRGB

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  RGB-Farbwerte der NVDI-Farben

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 const RGBColor * const Avdi_getRGB( int16 index );

 !item [Pascal:]            Function Avdi_getRGB( index: Integer ) :
                    RGBColorPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Avdi_getRGB liefert die RGB-Werte der NVDI-Farbpalette
(ab NVDI 5.x) zurÅck. Damit kînnen Objekte, die auf die Farbpalette
abgestimmt sind, auch unter Hicolor- oder Truecolor-Auflîsungen
korrekt gezeichnet werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen
!end_enumerate

!end_node


!begin_node Awindow

Die Struktur Awindow ist die fundamentale Struktur, welche die
Fensterdaten und Fenster-Funktionen enthÑlt.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   void *user;
   int16 (*service)( Awindow *window, int16 task,
      void *in_out );
   Awindow *(*create)( void *a );
   int16 (*open)( Awindow *window );
   int16 (*init)( Awindow *window );
   OBJECT *work;
   OBJECT *toolbar;
   int16 ob_edit, ob_col;
   int16 wi_id;
   int16 wi_kind;
   Axywh wi_act;
   Axywh wi_normal;
   Axywh wi_work;
   Axywh wi_slider;
   int16 wi_nx, wi_ny;
   int16 snap_mask;
   char *name;
   char *info;
   int16 ob_len;
   int16 kind;
   int16 state;
   int16 icon;
   CICONBLK *iconblk;
   OBJECT *menu;
   int16 (*keys)( Awindow *window, int16 kstate,
      int16 key );
   void (*obchange)( Awindow *window,
      int16 obnr, int16 new_state );
   void (*redraw)( Awindow *window, Axywh *rect );
   void (*topped)( Awindow *window );
   void (*closed)( Awindow *window );
   void (*fulled)( Awindow *window );
   void (*arrowed)( Awindow *window, int16 which );
   void (*hslid)( Awindow *window, int16 pos );
   void (*vslid)( Awindow *window, int16 pos );
   void (*sized)( Awindow *window, Axywh *rect );
   void (*moved)( Awindow *window, Axywh *rect );
} Awindow;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!label AwindowPtr
!begin_sourcecode
AwindowPtr = ^Awindow;

Awindow = RECORD
      user:       Pointer;
      service:    Function( w: AwindowPtr; task: Integer;
         in_out: Pointer ) : Boolean;
      create:     Function( a: Pointer ) : AwindowPtr;
      open:       Function( w: AwindowPtr ) : Integer;
      init:       Function( w: AwindowPtr ) : Integer;
      work:       ACSTreePtr;
      toolbar:    ACSTreePtr;
      ob_edit, ob_col:  Integer;
      wi_id:      Integer;
      wi_kind:    Integer;
      wi_act:     Axywh;
      wi_normal:  Axywh;
      wi_work:    Axywh;
      wi_slider:  Axywh;
      wi_nx, wi_ny: Integer;
      snap_mask:  Word;
      name:       Pointer;
      info:       Pointer;
      ob_len:     Integer;
      kind:       Integer;
      state:      Integer;
      icon:       Integer;
      iconblk:    CICONBLKPtr;
      menu:       ACSTreePtr;
      keys:       Function( w: AwindowPtr; kstate: Integer;
                     key: Integer ) : Integer;
      obchange:   Procedure( w: AwindowPtr; obnr: Integer;
                     new_state: Integer );
      redraw:     Procedure( w: AwindowPtr );
      topped:     Procedure( w: AwindowPtr );
      closed:     Procedure( w: AwindowPtr );
      fulled:     Procedure( w: AwindowPtr );
      arrowed:    Procedure( w: AwindowPtr );
      hslid:      Procedure( w: AwindowPtr );
      vslid:      Procedure( w: AwindowPtr );
      sized:      Procedure( w: AwindowPtr );
      moved:      Procedure( w: AwindowPtr );
   END;
!end_sourcecode

Die Komponenten der Struktur bedeuten hierbei:

!begin_xlist [wi_slider]
 !item [user]       Zeiger auf die (!link [User-Daten] [Awindow.user]) des Fensters

 !item [service]    Die (!link [Service-Routine] [Awindow.service]) stellt die FunktionalitÑt des Fensters
            nach auûen zur verfÅgung.

 !item [create]     Die (!link [Create-Routine] [Awindow.create]) wird zum Erzeugen des Fensters
            aufgerufen

 !item [open]       Die (!link [Open-Routine] [Awindow.open]) des Fensters

 !item [init]       Die (!link [Init-Routine] [Awindow.init]) des Fensters

 !item [work]       Das (!link [Work-Objekt] [Awindow.work]) des Fensters

 !item [toolbar]    Die (!link [Toolbar] [Awindow.toolbar]) des Fensters

 !item [ob_edit]    Das aktuelle (!link [Edit-Feld] [Awindow.ob_edit]).

 !item [ob_col]     Die aktuelle (!link [Cursor-Position] [Awindow.ob_col]).

 !item [wi_id]      Die GEM-Fenster-ID wird hier notiert.

!label Awindow.wi_kind
 !item [wi_kind]    Die Bitliste der GEM-Fensterattribute ist hier
            eingetragen. Der Wert wird GEM nur beim ôffnen des GEM-
            Fensters mitgeteilt.

 !item [wi_act]     Die (!link [Ñuûeren Koordinaten] [Awindow.wi_act]) des GEM-Fensters werden in dieser
            Struktur abgelegt.

 !item [wi_normal]  DIe geretteten (!link [Normal-Werte] [Awindow.wi_normal]) vor dem FULLED-Zustand.

 !item [wi_work]    Dieses Rechteck umschreibt den inneren (!link [Arbeitsbereich] [Awindow.wi_work]) ohne
            die MenÅleiste und ohne die Toolbar.

 !item [wi_slider]  Die hier abgelegten Werte steuern das Auffrischen der
            (!link [Fenster-Slider] [Awindow.wi_slider]).

 !item [wi_nx]      (!link [Versatz] [Awindow.wi_nx]) des Arbeitsobjektes

 !item [wi_ny]      (!link [Versatz] [Awindow.wi_ny]) des Arbeitsobjektes

 !item [snap_mask]  Das verwendete (!link [Raster] [Awindow.snap_mask]) des Fensters

 !item [name]       Der (!link [Name (Titelzeile)] [Awindow.name]) des Fensters

 !item [info]       Die (!link [Infozeile] [Awindow.info]) des Fensters

 !item [ob_len]     Die (!link [LÑnge] [Awindow.ob_len]) eines selektierten Bereichs eines Eingabefeldes

!label Awindow.kind
 !item [kind]       Durch kind wird die Fensterart wird beschrieben. Die
            definierten Fenster-Flags stehen als Konstanten zur
            VerfÅgung.

!label Awindow.state
 !item [state]      Der Zustand des Fensters wird in dieser Komponente
            abgelegt. Die definierten Fenster-Status-Flags stehen als
            Konstanten zur VerfÅgung.

 !item [icon]       Die (!link [Objektnummer] [Awindow.icon]) des ikonifizierten Fensters im Fenster,
            welches das Icon verwaltet (i.a. PUR_DESK bzw. DESKTOP).

 !item [menu]       Die (!link [MenÅ-Leiste] [Awindow.menu]) des Fensters

 !item [keys]       Diese Routine reagiert auf (!link [Tastatur-Eingaben] [Awindow.keys]).

!label Awindow.obchange
 !item [obchange]   Dieser Zeiger verweist auf die Routine, die schnell
            StatusÑnderungen an Objekten zeichnen kann. Die
            Defaultroutine heiût Awi_obchange und wird in der Regel
            nicht ersetzt.

!label Awindow.redraw
 !item [redraw]     Der angegebene Ausschnitt des Fensters wird neu
            gezeichnet. Die Defaultroutine heiût Awi_redraw und wird
            in der Regel nicht ersetzt.

 !item [topped]     Das Fenster wird durch diese (!link [Routine] [Awindow.topped]) nach vorne gebracht.

 !item [closed]     Die (!link [Routine] [Awindow.closed]), auf die dieser Zeiger verweist, schlieût das
            Fenster.

 !item [fulled]     Die hier notierte (!link [Routine] [Awindow.fulled]) reagiert auf das AuswÑhlen der
            FULL-Box des Fensters.

!label Awindow.arrowed
 !item [arrowed]    Diese Routine bedient die Pfeile und das seitenweise
            Scrollen. Die Defaultroutine heiût Awi_arrowed.

!label Awindow.hslid
 !item [hslid]      Der horizontale Schieber wird bedient. Die Defaultroutine
            heiût Awi_hslid.

!label Awindow.vslide
 !item [vslid]      Der vertikale Schieber wird bedient. Die Defaultroutine
            heiût Awi_vslid.

 !item [sized]      Diese Routine bearbeitet (!link [Grîûen-énderungen] [Awindow.sized]) des Fensters.

!label Awindow.moved
 !item [moved]      Diese Routine verwaltet der VerÑnderungen der Position.
            Die Defaultroutine heiût Awi_moved.
!end_xlist

!end_node


!begin_node Awindow.user

Dieser Zeiger referenziert die Benutzerdaten des Fensters. Damit ist
es mîglich, lokal an eine Fensterstruktur Daten zu binden, die dann
beliebig oft erzeugt werden kînnen.

Beispiel:

!begin_sourcecode
/* Irgendwo im Programm, wo ein Fenster gemÑû der */
/* Klasse F_ADR erzeugt werden soll ...           */
new_win = F_ADR.create(NULL);

/* Die in der Variablen F_ADR  */
/* eingetragene create-Routine */
static Awindow *adr_create( void *para );
{
   ADR_BLOCK *adr;
   Awindow   *new_wi;

   /* Neues Fenster anlegen */
   new_wi=Awi_create(&F_ADR);
   if( new_wi==NULL )
      return NULL;

   /* Die Daten fÅr das Fenster anlegen */
   adr = Ax_malloc(sizeof(ADR_BLOCK));
   if( adr==NULL )
   {
      /* Speicher konnte nicht alloziert werden */
      Awi_delete(new_wi);
      return NULL;
   }

   /* Initialisierung des Speichers */
   memset(adr, 0, sizeof(ADR_BLOCK));

   /* Die angelegten Daten in der Fenster-Struktur vermerken */
   new_wi->user = adr;

   return new_wi;
}
!end_sourcecode

!end_node


!begin_node Awindow.service

Hier wird der Zeiger auf die Routine eingetragen, die die Nachrichten
fÅr das Fenster bearbeitet. Die Standardroutine heiût Awi_service. Sie
wird in der Regel durch eine Benutzereigene ersetzt, was dann wichtig
wird, wenn man z.B. auf das (!link [Terminieren des Fensters] [AS_TERM]) selber reagieren
mîchte. Dies ist u.a. dann nîtig, wenn in der (!link [create-Routine] [Awindow.create]) Speicher
alloziert und im User-Zeiger eingetragen wurde, der beim Terminieren
des Fensters freigegeben werden muû. Oder man kann hier eine
Sicherheitsabfrage einbauen, ob das Fenster wirklich gelîscht werden
soll.

(!I)Wichtig ist, daû man alle nicht konsumierten Nachrichten an
Awi_service weiterleiten sollte. Zwar wird ab Version 2.4 das Iconify
nicht mehr durch Awi_service, sondern durch Awi_iconify etc. erledigt,
aber auf diese Art kînnen Fenster von spÑteren Erweiterungen der
Routine Awi_service profitieren!(!i)

Auf einen korrekten RÅckgabewert sollte geachtet werden. Wenn auf eine
Nachricht der RÅckgabewert FALSE geliefert wird, so kennt das Fenster
entweder diese Nachricht nicht, oder bei der Bearbeitung der Nachricht
ist ein Fehler aufgetreten. Damit signalisiert der RÅckgabewert TRUE
stets, daû die Nachricht erfolgreich bearbeitet wurde. FÅr alle
Abfragen von Werten o.Ñ. steht der Zeiger in_out zur VerfÅgung, der je
nach Nachricht geeignet definiert ist bzw. bei selbst definierten
Nachrichten geeignet Åbergeben werden kann.

Beispiel:

!begin_sourcecode
static int16 service_adr( Awindow *this, int16 task, void *para )
{
   ADR_BLOCK *adr;
   char *frage="[2][Wirklich beenden?][OK|Abbruch]";

   switch(task)
   {
      case AS_TERM:
         if( !appexit && Awi_alert(1, frage)==2 )
            return TRUE;

         adr = wi->user;
         Ax_free(adr);
         Awi_delete(this);
#ifdef __ACS_MODULE__
         ACSmoduleterm ();
#endif
         break;

      default:
         return Awi_service(this, task, para);
   }

   return TRUE;
}
!end_sourcecode

!end_node


!begin_node Awindow.create

Hier wird der Zeiger auf die create-Routine eingetragen. Die create-
Routine trifft alle Maûnahmen zur Erzeugung des Fensters. Das kann die
Anlage benutzerdefinierter Strukturen sein, das kann das Erfragen
eines Dateinamens sein. FÅr create gibt es die Standardroutine
Awi_selfcreate.

Ein Beispiel finden Sie unter (!link [user] [Awindow.user]).

!end_node


!begin_node Awindow.open

Der Zeiger auf die open-Routine wird hier eingetragen. Der
RÅckgabewert informiert Åber den Erfolg des ôffnens. Mîgliche Werte
sind OK oder FAIL.

Eine Alternative bietet sich fÅr Fenster an, deren Icons auf dem
Desktop nur als 'Start' fÅr weitere Aktionen herhÑlt. Dann kann
beispielsweise ein Datei per A_fileselect ermittelt und damit ein
Fenster geîffnet werden - wie es beim IMG-EDIT- oder IMG-VIEW-Modul
passiert. Es kann auch ein Popup erscheinen, das detalliertere
Funktionen zulÑût.

Beispiel:

!begin_sourcecode
static int16 open_adr( Awindow *this )
{
   /* weitere Aktionen durch Popup */
   Ame_popup(wi, &P_ADR, ev_mmox, ev_mmoy);
   return OK;
}
!end_sourcecode

!end_node


!begin_node Awindow.init

Der Zweck dieser Routine ist das dynamische Anpassen des inneren
Objektes. Das Anpassen soll jedoch nur dann durchfÅhrt werden, wenn
dies notwendig wird, wodurch unnîtige Arbeit vermieden wird.

Die Standardroutine Awi_init macht schlichtweg gar nichts.

Diese Routine wird aufgerufen, wenn beim ôffnen des Fensters das Flag
AWS_MODIFIED vorgefunden wird. Dieses Flag wird beim Erzeugen gesetzt.

Wenn man AWS_LATEUPDATE setzt, wird diese Routine nach der Abarbeitung
aller anderen Ereignisse (insbesondere der Zeit-Ereignisse)
aufgerufen. Setzt man innerhalb der eigenen Routine wieder
AWS_LATEUPDATE, wird diese Routine danach und nach dem nÑchsten
Ereignis erneut aufgerufen. Damit kann man innerhalb von (!I)ACSpro(!i) ein
pseudo-kooperatives Multitasking zwischen den Fenstern erreichen. Dann
sollte man beachten, daû ev_mtcount 'ausgewogen' gesetzt ist.

Beispiel:

!begin_sourcecode
/* reale Zeitdifferenz */
static long timer200( void )
{
   return *((long *) 0x4BA);
}

/* Die in der Struktur eingetragene init-Routine */
static adr_init( Awindow *this )
{
   this->state |= AWS_LATEUPDATE;
   new_timer = Supexec(timer200);
   if( new_timer-old_timer>=200l )
   {
      old_timer = new_timer;

      /* jede neue Sekunde die Anzeige auffrischen */

      /* ... */
   }

   return OK;
}
!end_sourcecode

!end_node


!begin_node Awindow.work

Hier wird der Arbeitsobjektbaum (nicht-modaler Dialog, innerer
Objektbaum) eingetragen, der im Gegensatz zur Toolbar auch Felder mit
Texteingabe erlaubt. Ist kein Objektbaum vorhanden, ist hier NULL bzw.
NIL eingetragen.

Will man fÅr eine vorhandene Fensterklasse MenÅ-, Toolbar- oder Work-
Objektbaum kurzzeitig austauschen (z.B. um sonst alle Eigenschaften
der Klasse zu Åbernehmen), geht man am Besten wie im folgenden
Beispiel vor:

!begin_sourcecode
     old_menu = &PROTOCOL.menu;
     PROTOCOL.menu = &MY_MENU;
     new_proto = PROTOCOL.create(NULL);
     PROTOCOL.menu = old_menu;
!end_sourcecode

!end_node


!begin_node Awindow.toolbar

Hier wird der Toolbar-Objektbaum eingetragen. Ist keine Toolbar
vorhanden, ist hier NULL bzw. NIL eingetragen.

Der Toolbar-Objektbaum ist bis auf die fehlende Mîglichkeit eines
Texteingabefeldes dem MenÅ-oder Work-Objektbaum gleichgestellt,
allerdings wird er bei Scroll-Ereignissen nicht verschoben, sondern
bleibt am oberen Rand. Weiterhin wird die Breite des Toolobjektbaum-
Vaters immer an die innere Fensterbreite angepaût.

Ein Beispiel finden Sie unter (!link [work] [Awindow.work]).

!end_node


!begin_node Awindow.ob_edit

ob_edit referenziert das aktuelle Editfeld im work-Objektbaum. Gibt es
kein aktuelles Editfeld ist -1 eingetragen.

Awindow.ob_col gibt die aktuelle Cursorposition innerhalb des
Eingabefeldes an. Ist hier -1 eingetragen, wird bei der nÑchsten
Mîglichkeit der komplette Text markiert.

Beispiel:

!begin_sourcecode
     /* Eingabe beenden, Cursor verstecken, ... */
     Awi_diaend();

     /* ... den Cursor neu positionieren, ... */
     wi->ob_edit = D_ADRINPUT;

     /* ... den Cursor ans Ende des Feldes stellen, ... */
     wi->ob_col = -1;

     /* ... den Cursor sichtbar machen und die Eingabe starten */
     Awi_diastart();
!end_sourcecode

!end_node


!begin_node Awindow.ob_col

ob_col gibt die aktuelle Cursorposition innerhalb des Eingabefeldes
an. Ist hier -1 eingetragen, wird bei der nÑchsten Mîglichkeit der
komplette Text markiert.

Awindow.ob_edit referenziert das aktuelle Editfeld im work-Objektbaum.
Gibt es kein aktuelles Editfeld ist -1 eingetragen.

Ein Beispiel zu Awindow.ob_col ist bei Awindow.ob_edit zu finden.

!end_node


!begin_node Awindow.wi_id

Hier wird entweder die Fensterindentifikation des AES eingetragen,
oder -1 wenn das Fenster derzeit kein GEM-Fenster besitzt.

(!I)Dieser Wert sollte nicht durch den Benutzer verÑndert werden.(!i)

!end_node


!begin_node Awindow.wi_act

Die Ñuûeren Koordinaten des GEM-Fensters werden in dieser Struktur
abgelegt.


!image (!IMAGES)img00730.img

!end_node


!begin_node Awindow.wi_normal

Hierher werden die wi_act-Werte gerettet bevor das Fenster in den
Zustand FULLED Åbergeht. Nach RÅckkehr in den normalen Modus werden
diese Werte wieder zu wi_act.

Ist das Fenster im Zustand AWS_ICONIZED, werden hier die Ausmaûe des
ursprÅnglichen Awindow.wi_act-Rechtecks gesichert.

!end_node


!begin_node Awindow.wi_work

Dieses Rechteck umschreibt den inneren Arbeitsbereich ohne die
MenÅleiste und ohne die Toolbar. (!I)Diese Werte sollten nicht vom
Benutzer modifiziert werden.(!i)


!image (!IMAGES)img00729.img

!end_node


!begin_node Awindow.wi_slider

Diese Werte steuern das Auffrischen der Schieber. Nur wenn sich bei
entsprechenden Benutzeraktionen die Werte Ñndern, werden die Schieber
neu gesetzt.

!begin_xlist [wi_slider.x]
 !item [wi_slider.x]  enthÑlt die X-Position des horizontalen Schiebers in
              Promille (links = 1, rechts = 1000)

 !item [wi_slider.y]  enthÑlt die Y-Position des vertikalen Schiebers in
              Promille (oben = 1, unten = 1000)

 !item [wi_slider.w]  enthÑlt die Grîûe des horizontalen Schiebers in Promille
              (minimal = 1, maximal = 1000)

 !item [wi_slider.h]  enthÑlt die Grîûe des vertikalen Schiebers in Promille
              (minimal = 1, maximal = 1000)
!end_xlist

!end_node


!begin_node Awindow.wi_nx

Hier wird der Versatz des Arbeitsobjektes gespeichert, bevor das
Fenster in den AWS_FULL-Zustand Åbergeht. Bei RÅckkehr in den normalen
Modus werden diese Werte gebraucht, um den ursprÅnglichen Zustand
wieder herzustellen. (!I)Dies sind eher interne Werte, die vom Benutzer
nicht geÑndert werden sollten.(!i)

!end_node


!begin_node Awindow.wi_ny

Hier wird der Versatz des Arbeitsobjektes gespeichert, bevor das
Fenster in den AWS_FULL-Zustand Åbergeht. Bei RÅckkehr in den normalen
Modus werden diese Werte gebraucht, um den ursprÅnglichen Zustand
wieder herzustellen. (!I)Dies sind eher interne Werte, die vom Benutzer
nicht geÑndert werden sollten.(!i)

!end_node


!begin_node Awindow.snap_mask

Dieser Wert bestimmt das Raster auf dem Bildschirm, in welches das
Fenster und das Arbeitsobjekt gelegt und bewegt wird. Das Objekt wird
nur in diesem Raster angezeigt. Damit ist auch die Schrittweite bei
Scrolloperationen festgelegt. Da es sich um eine Maske handelt, kînnen
nur 2er-Potenzen gewÑhlt werden. Das High-Byte ist fÅr die Y-
Koordination, das Low-Byte fÅr die X-Koordinaten zustÑndig.

     (!B)Ab der Schrittweite 16 wird der Bildschirmaufbau erheblich
     schneller, da im VDI immer Wortgrenzen getroffen werden.(!b)

 Maske  Schritt

 0xff   1 Jede Position mîglich

 0xfe   2

 0xfc   4

 0xf8   8

 0xf0   16

 0xe0   32

 0xc0   64

!end_node


!begin_node Awindow.name

Der Zeiger auf den Fensternamen wird hier eingetragen.

Sollten Sie diese Anzeige Ñndern wollen, so empfiehlt sich das
Vorgehen im folgenden Beispiel:

!begin_sourcecode
     old_name = wi->name;
     wi->name = Ast_create("Neuer Name");

     if( wi->name==NULL )
        wi->name = old_name;
     else
     {
        Ast_delete(old_name);
        wind_set(wi->wi_id, WF_NAME, wi->name);
     }
!end_sourcecode

!end_node


!begin_node Awindow.info

Der Zeiger auf die Fensterinfozeile wird hier abgelegt.

Sollten Sie diese Anzeige Ñndern wollen, so empfiehlt sich das
Vorgehen im folgenden Beispiel:

!begin_sourcecode
     old_info = wi->info;
     wi->info = Ast_create("Mausposition: 10, 45"):

     if( wi->info==NULL )
        wi->info = old_info;
     else
     {
        Ast_delete(old_info);
        wind_set(wi->wi_id, WF_INFO, wi->info);
     }
!end_sourcecode

!end_node


!begin_node Awindow.ob_len

Ist in dem Eingabefeld, das durch Awindow.ob_edit beschrieben wird,
eine Selektion aktiv, wird hier deren LÑnge eingetragen. Ein Wert <=0
signalisiert, daû keine Selektion aktiv ist. Awindow.ob_col ist immer
die Cursorposition oder der Selektionsanfang.

!end_node


!begin_node Awindow.icon

Der Wert bezeichnet die Objektnummer des ikonifizierten Fensters im
Icon-verwaltenden Fenster (i.a. das mit Awi_root ermittelbare Root-
Fenster). Gibt es ein solches nicht, steht hier -1.

(!B)Wenn Sie z.B. das Rechteck des Icons ermitteln mîchten, mÅssen Sie
testen, ob das in Frage kommenden (Root-)Fenster Åberhaupt einen
Work-Bereich besitzt.(!b)

Dieser Wert darf nicht verÑndert werden.

!end_node


!begin_node Awindow.iconblk

Dem Fenster kann eine eigene Icon zugeordnet werden, die hier
eingetragen ist. Sonst steht hier NULL bzw. NIL.

Dieses Icon wird nicht nur fÅr die (!I)ACSpro(!i)-eigene Iconverwaltung
herangezogen, sondern auch beim System-Iconify.

!end_node


!begin_node Awindow.menu

Die optionale MenÅleiste wird hier eingetragen. Ist keine MenÅleiste
vorhanden, ist hier NULL bzw. NIL eingetragen.

Ein Beispiel finden Sie unter (!link [work] [Awindow.work]).

!end_node


!begin_node Awindow.keys

Hier wird auf die Routine verwiesen, die die Tastatureingaben bedient.
Die Defaultroutine heiût Awi_keys.

Ab (!I)ACSpro(!i)-Version 2.20 muû diese Routine einen int16-Wert
zurÅckliefern, anhand dessen ausgewertet wird, ob ein Tastendruck
verarbeitet wurde oder an einen eventuell vorhandenen AV-Server
weitergeleitet werden kann bw. soll. Der RÅckgabewert signalisiert
(!I)ACSpro(!i) Folgendes:

!begin_xlist [>=0]
 !item [>=0]  Die Taste wurde von dem Objekt mit dieser Nummer verarbeitet. In
      Awi_dialog gilt dies als Ausgangskriterium.

 !item [-1]   Diese Taste wurde nicht verarbeitet, soll jedoch nicht
      weitergereicht werden.

 !item [-2]   Diese Taste wurde nicht verarbeitet und soll an den AV-Server
      weitergereicht werden.
!end_xlist

Ist das Fenster in modaler Fensterdialog, dann bedeutet ein positiver
Wert, daû mit dieser Objektnummer der Dialog beendet werden soll.

Der Parameter kstate ist eigentlich ÅberflÅssig, da aufgrund der
NKCC-Codierung alle Informationen in key vorhanden sind - er wurde nur
aus GrÅnden der KompatibilitÑt zu alten Versionen Åbernommen.

Beispiel:

!begin_sourcecode
int16 adr_key( Awindow *this, int16 kstate, int16 key )
{
   if( key<0 )
   {
      /* eine Funktionstaste oder    */
      /* ein Shortcut wurde gedrÅckt */
   }

   /* keine Verarbeitung */
   if( wi->state & AWS_MODAL_WIN )
      return -1;
   else
      return 0;
}
!end_sourcecode

!end_node


!begin_node Awindow.topped

Das Fenster soll nach oben gebracht werden. Die Defaulroutine heiût
Awi_topped.

Bindet man hier eine eigene Routine ein, kann man z.B. das Toppen von
einer Bedingung abhÑngig machen, die testet, ob das Toppen erwÅnscht
ist.

Beispiel:

!begin_sourcecode
static void adr_topped( Awindow *this )
{
   /* Toppen nur, wenn die Maus inner- */
   /* halb ist, also nicht von auûen!  */
   if( Aob_within(&wi->wi_act, ev_mmox, ev_mmoy) )
   {
      Awi_topped(this);
   }
}
!end_sourcecode

!end_node


!begin_node Awindow.closed

Das Fenster soll geschlossen werden. Die Defaultroutine heiût
Awi_closed.

Wenn Sie beispielweise eine Dateiliste in dem Fenster darstellen und
das Fenster nur dann wirklich schlieûen mîchten, wenn Sie sich im
Hauptverzeichnis des Laufwerks befinden, kann man das Schlieûen
umgehen, wie das folgende Beispiel zeigt:

!begin_sourcecode
static void file_close( Awindow *this )
{
   FILE_BLOCK  *fb;

   fb = wi->user;
   if( fb==NULL
         || fb->aktuelle_ordner_tiefe==0
         || (wi->state & AWS_ICONIZED) )
      Awi_closed(this);
   else
   {
      /* springe einen Ordner hîher */
   }
}
!end_sourcecode

(!B)Achtung(!b)
(!I)Ist in der kind-Komponente des Fensters nicht AW_ICON gesetzt -
besitzt das Fenster also keinen (!i)(!I)ACSpro(!i)(!I)-Icon-Zustand -, wird direkt die
Service-Routine mit AS_TERM aufgerufen.(!i)

Oft mîchte man jedoch einige Fensterdialoge vorab erzeugen, ohne daû
diese jeweils ein Icon auf dem Desktop hinterlassen. In diesem Fall
sollten Sie in der Create-Routine zunÑchst das AW_ICON-Bit lîschen,
das Fenster erzeugen und in der Instanz wieder das AW_ICON-Bit setzen.
Daraufhin wird die Close-Routine aufgerufen, in der Sie einen Trick
benutzten sollten, um kein Icon erscheinen zu lassen:

!begin_sourcecode
static void adr_close( Awindow *this )
{
   this->state |= AWS_TERM;
   Awi_closed(this);
   this->state &= ~AWS_TERM;
}
!end_sourcecode

Diese Routine wird auch aufgerufen, wenn das System-Iconify fÅr diese
Fenster greift. In diesem Fall ist voher schon AWS_ICONIZED gesetzt
und es sollte wenn mîglich dann Awi_closed aufgerufen wrden. Ist das
System-Iconify nicht erwÅnscht fÅr dieses Fenster, sollte man dann
diesen Zustand lîschen und Awi_closed nicht aufrufen.

!end_node


!begin_node Awindow.fulled

Hier steht der Zeiger auf die Routine, die das AnwÑhlen der FULL-Box
bedient. Die Defaultroutine heiût Awi_fulled.

Eine eigene Routine ist immer dann zwingend nîtig, wenn sich die
Ausmaûe von bestimmten Objekten an die neue Grîûe anpassen muû, da
Awi_fulled nur zwischen den ursprÅnglichen und den maximalen Ausmaûen
des work-Vater-Objekts umschaltet.

Beachten Sie fÅr diesen Fall, daû (!I)ACSpro(!i) den Redraw optimiert und es
in einem solchen Fall nîtig sein kann, den kompletten Redraw mit
AWS_FORCEREDRAW zu erzwingen. Ebenso sollten sie betroffene Objekte
Åber eine Nachricht von der GrîûenverÑnderung infomieren (z.B.
Userdef- Editor mit AUO_EDRESIZE).

Beispiel:

!begin_sourcecode
static void adr_fulled( Awindow *this )
{
   if( this->state & AWS_FULL )
   {
      /* Vater-Objektes auf vorherige innere Maûe */
      wind_calc(WC_WORK, this->wi_kind,
                this->wi_normal.x, this->wi_normal.y,
                this->wi_normal.w, this->wi_normal.h,
                &dum, &dum,
                &this->work[0].ob_width,
                &this->work[0].ob_height);
      this->state &= ~AWS_FULL;
   }
   else
   {
      /* Work-Ausmaûe relativ zun den Desktopausmaûen */
      wind_calc(WC_WORK, this->wi_kind,
                desk.x, desk.y,
                desk.w, desk.h,
                &dum, &dum,
                &this->work[0].ob_width,
                &this->work[0].ob_height);
      this->state |= AWS_FULL;
   }

   /* Auûenausmaûe berechnen */
   wind_calc(WC_BORDER, this->wi_kind,
             this->wi_work.x, this->wi_work.y,
             this->wi_work.w, this->wi_work.h,
             &this->wi_act.x, &this->wi_act.y,
             &this->wi_act.w, &this->wi_act.h)

   /* Die eigene sized-Routine aufrufen */
   (wi->sized)(this, &this->wi_act);
   wind_set(this->wi_id, WF_CURRXYWH,
            this_act->x, this_act->y, this_act->w, this_act->h);
}
!end_sourcecode

!end_node


!begin_node Awindow.sized

Diese Routine verwaltet die VerÑnderungen der Grîûe. Die
Defaultroutine heiût Awi_sized.

Wie bei (!link [fulled] [Awindow.fulled]) gilt auch hier, daû (!I)ACSpro(!i) nicht weiû, ob bestimmte
Objekte sich dem Anwenderwunsch anpassen sollen. Eventuell mÅssen also
Objekte in ihrer Grîûe verÑndert werden. Ebenso optimiert (!I)ACSpro(!i) den
Redraw, wenn sich beispielsweise die realen Ausmaûe nicht Ñndern -
dann muû der Redraw mit dem Setzen von AWS_FORCEREDRAW erzwungen
werden. Auûerdem muû darauf geachtet werden, daû einige Objekte (z.B.
A_editor) mittels einer Nachricht (AUO_EDRESIZE) Åber diese verÑnderte
Grîûe fÅr interne Zwecke informiert werden mÅssen.

Beispiel:

!begin_sourcecode
static_void size_adr( Awindow *this, Axyh *rect )
{
   OBJECT  *entry, *menu, *toolbar;
   int16 x, y;

   entry = this->work;
   menu = this->menu;
   toolbar = this->toolbar;
   wind_calc(WC_WORK, this->wi_kind, 0, 0, area->w, area->h,
             &x, &y,
             &entry->ob_width, &entry->ob_height);

   if( menu!=NULL )
      entry->ob_height -= menu[menu->ob_head].ob_height;

   if( toolbar!=NULL )
      entry->ob_height -= toolbar->ob_height;

   Auo_editor(entry, AUO_EDRESIZE, NULL);
   Auo_editor(entry, AUO_EDSLIDERS, NULL);

   Awi_sized(this, area);
}
!end_sourcecode

!end_node


!begin_node Awiob

Diese Struktur wird zur Beschreibung der IdentitÑt bei Userdef's
verwandt. Sie enthÑlt das Fenster, den Zeiger auf das Userdef im
Objektbaum und die Objektnummer im Baum.

Umfangreichere Objekt sollten sich damit ihren 'Kontext' merken, so
daû bei der Bearbeitung von Nachrichten fÅr die AUSERBLK.service-
Routine alle benîtigten Grîûen ermittelt werden kînnen. Aus diesem
Grund (!B)muû(!b) beispielsweise einem (!link [Editor] [A_editor]) sein 'Kontext' Åbermittelt
werden.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   Awindow *window;
   OBJECT  *entry;
   int16 obnr;
} Awiob;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
Awiob = RECORD
      window:  AwindowPtr;
      entry:   ACSOBJECTPtr;
      obnr:    Integer;
END;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!begin_xlist [window]
 !item [window]  Zeiger auf das Fenster, in dem das Userdef dargestellt wird

 !item [entry]   Zeiger auf den Objektbaum, in dem das Userdef enthalten ist

 !item [obnr]    Nummer des Userdefs im Objektbaum
!end_xlist

!end_node


!begin_node Awi_alert

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Meldung wie form_alert darstellen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_alert( int16 but, char *mess );

 !item [Pascal:]            Function Awi_alert(
                                   but: Integer; mess: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_alert stellt vîllig analog zu form_alert eine
Meldung, die Åber 'but' und 'mess' konfiguriert wird, in einem Fenster
dar.

Dabei wird in AbhÑngigkeit von dem Icon ein passender Fenstertitel
oder, wenn vorhanden, alert_name eingesetzt. Falls keine GEM-Fenster-
Id mehr frei ist, wird sofort form_alert angesprungen, ebenso bei
Speichermangel. Die RÅckgabewerte sind identisch zu form_alert.

!begin_xlist [mess]
 !item [but]   gibt an, welcher der Buttons der Default-Button sein soll
       (0=keiner).

 !item [mess]  Der mess-Text ist folgendermaûen aufgebaut:

            "[I][ Textzeile1 | Textzeile2 ][ Button1 | Button2 ]"

       Hierbei ist I die Iconnummer ab 1 beginnend,


!image (!IMAGES)img00728.img

       Es gibt maximal 5 Textzeilen mit je maximal 30 Zeichen, die
       durch '|' getrennt werden. Letzteres trennt auch die maximal
       drei Buttons.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item alert_str, Awi_dialog, Awi_alert, Awi_modal
!end_enumerate

!end_node


!begin_node Awi_arrowed

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  DurchfÅhren der "Pfeil-Operationen"

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_arrowed( Awindow *window, int16 which );

 !item [Pascal:]            Procedure Awi_arrowed( window: AwindowPtr;
                                   which: Integer);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_arrowed fÅhrt die "Pfeil-Operationen" durch.

Dabei ist which wie fÅr die GEM-Nachricht WM_ARROWED definiert:

!begin_xlist [WA_UPPAGE]
!label WA_UPPAGE
 !item [WA_UPPAGE]  Seite hoch

!label WA_DNPAGE
 !item [WA_DNPAGE]  Seite runter

!label WA_UPLINE
 !item [WA_UPLINE]  Zeile hoch

!label WA_DNLINE
 !item [WA_DNLINE]  Zeile runter

!label WA_LTPAGE
 !item [WA_LTPAGE]  Seite links

!label WA_RTPAGE
 !item [WA_RTPAGE]  Seite rechts

!label WA_LTLINE
 !item [WA_LTLINE]  Spalte links

!label WA_RTLINE
 !item [WA_RTLINE]  Spalte rechts
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_bubblegem

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  BubbleGEM-Hilfe fÅr das Objekt an den Koordinaten
                    (mx, my) anzeigen

 !item [Kategorie:]         Fenster-Funktionen, BubbleGEM-Protokoll

 !item [C:]                 int16 Awi_bubblegem( Awindow *window,
                             int16 mx, int16 my )

 !item [Pascal:]            Function Awi_bubblegem(
                                   window: AwindowPtr; mx, my: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_bubblegem zeigt fÅr das Objekt (aus dem Work-Objekt
oder der Toolbar) unter den Koordinaten (mx, my) eine BubbleGEM-Hilfe
an - sofern verfÅgbar. Das Vorgehen der Funktion ist beim
BubbleGEM-Protokoll beschrieben.

(!B)Hinweis:(!b) Die Funktion wird bereits bei einem kurzen Rechtsklick mit
der Maus von (!I)ACSpro(!i) aufgerufen, sie wird also im Normalfall nicht
benîtigt werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen, BubbleGEM-Protokoll

  !item AS_ALLOWBUBBLE, AUO_GETBUBBLE, AS_GETBUBBLE

  !item Awi_context
!end_enumerate

!end_node


!begin_node Awi_closed

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Schlieûen eines Fensters

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_closed( Awindow *window );

 !item [Pascal:]            Procedure Awi_closed( window: AwindowPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_closed schlieût das Fenster window. Es ist nach wie
vor existent. Es wird das zugehîrige GEM-Fenster geschlossen.

(!B)WICHTIG:(!b) Wenn AWS_TERM gesetzt ist, wird das Fenster gelîscht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_open
!end_enumerate

!end_node


!begin_node Awi_create

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen eines Fensters

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_create( const Awindow *parent );

 !item [Pascal:]            Function Awi_create(
                                   parent: AwindowPtr
                                ) : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_create erzeugt eine neue Fensterstruktur.

Der Parameter parent dient dabei als Vorlage. Das Fenster ist noch
nicht sichtbar. Es werden Kopien der Substrukturen work, iconblk,
menu, name und info angelegt, sofern diese definiert sind. ObjektbÑume
und Positionswerte werden von Zeichen- in Pixelkoordinaten
umgewandelt. Falls die Fenster-Struktur nicht erzeugt werden konnte,
wird NULL bzw. NIL zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_selfcreate

  !item Awi_delete
!end_enumerate

!end_node


!begin_node Awi_delete

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Lîschen eines Fensters

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_delete( Awindow *window );

 !item [Pascal:]            Procedure Awi_delete( window: AwindowPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_delete lîscht das Fenters. Alle Referenzen auf dieses
Fenster sind ungÅltig. Dabei werden die Substrukturen work, iconblk,
menu, name und info freigegeben. Die close-Routine des Fenster wird
solange aufgerufen bis die GEM-FensterID ((!link [wi_id] [Awindow.wi_id])) freigegeben ist. Sehr
standhafte Fenster werden nach 100 Versuchen direkt mit Awi_closed
entfernt.

Das Lîschen des root-Fenster beendet das Programm.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_create

  !item Awi_closed
!end_enumerate

!end_node


!begin_node Awi_diaabort

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Beenden eines modalen Fensterdialoges

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_diaabort( void );

 !item [Pascal:]            Procedure Awi_diaabort;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_diaabort dient als Click-Funktion zum Setzen des
Flags dia_abort. Hierdurch kînnen einfach modale Fenster-Dialoge wie
etwa die "öber-Mich-Dialog" verlassen werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_diaend

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eingabe in offenem Fensterdialog beenden

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_diaend( void );

 !item [Pascal:]            Procedure Awi_diaend;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_diaend beendet die Eingabe in einem eventuell offenen
Dialog, der Eingabecursor wird entfernt.

Der Prototyp fÅr Pure-C lautet:
!begin_sourcecode
     void Awi_diaend( void );
!end_sourcecode

Die Deklaration fÅr Pure-Pascal lautet:
!begin_sourcecode
     Procedure Awi_diaend;
!end_sourcecode

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_diastart
!end_enumerate

!end_node


!begin_node Awi_dialog

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Modalen Fensterdialog durchfÅhren

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_dialog( Awindow *window );

 !item [Pascal:]            Function Awi_dialog(
                                   window: AwindowPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_dialog fÅhrt analog zu A_dialog einen Dialog in einem
Fenster durch.

Ein eventuelles Icon dazu wird gelîscht. Das Fenster wird bei Klick
immer oben und an der Mausposition gehalten. Routinen hinter Objekten
werden wie Åblich behandelt auch kann per dia_abort das Fenster
beendet werden. Die Fensterstruktur wird danach nicht direkt gelîscht
- zum Auswerten des Objektbaums. Ein Fensterdialog wird beendet, wenn
das selektierte Objekt EXIT und SELECTABLE gesetzt ist oder irgendwie
programmatisch geschlossen wird. Wird aus A_dialog heraus Awi_dialog
(also auch Awi_alert) aufgerufen, erscheint der Dialog sofort als
A_dialog (nur der Work-Bereich)! Damit dann nicht eventuelle nur-
TOUCHEXIT Objekte zum Beenden fÅhren, wird A_dialog nicht beendet,
wenn das Objekt nur TOUCHEXIT gesetzt hat.

RÅckgabewerte:

!begin_xlist [>=0]
 !item [>=0] gÅltige RÅckgabe-Objektnummer

 !item [-1] geîffneter Fensterdialog wurde extern geschlossen

 !item [-2] interne ZwÑnge (Speicher, keine ID, etc.) lassen den Dialog gar
   nicht erst erscheinen

 !item [-3] Aufruf unlogisch (kein Work-Objekt oder Dialog ist bereits ein
   Fensterdialog)
!end_xlist

(!B)Hinweis:(!b) Die Funktion A_dialog bzw. A_dialog2 sollte durch Awi_dialog
ersetzt werden. In einem Multitasking-System werden es die Anwender
danken.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item A_dialog, Awi_doform, Awi_modal, Awi_alert
!end_enumerate

!end_node


!begin_node Awi_diastart

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eingabe in offenem Fensterdialog starten

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_diastart( void );

 !item [Pascal:]            Procedure Awi_diastart;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_diastart startet den Texteingabedialog wieder. Der
Eingabecursor wird fÅr das Objekt aus der Fensterstruktur
Awindow.ob_edit aktiviert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_diaend
!end_enumerate

!end_node


!begin_node Awi_doform

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Modalen Fensterdialog komplett durchfÅhren

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_doform( Awindow *mod_dia, void *para );

 !item [Pascal:]            Function Awi_doform(
                                   window: AwindowPtr; para: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_doform fÅhrt Åber Awi_dialog einen Dialog in einem
Fenster durch.

Es werden jedoch nur die nîtigen Fensterelemente zum Vergrîûern und
Scrollen dargestellt. Falls der Aufruf von Awi_dialog nicht
erfolgreich war, wird automatisch auf A_dialog zurÅckgegriffen.

(!B)Hinweis:(!b) Das benîtigte Fenster wird selbst erzeugt. Es wird also
direkt die von (!I)ACSpro(!i) erzeugte Vorlage Åbergeben, Awi_doform ruft
selbsttÑtig Awi_create mit dem Parameter para auf und lîscht das
Fenster am Ende auch wieder!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item A_dialog, A_dialog2, Awi_modal, Awi_alert
!end_enumerate

!end_node


!begin_node Awi_down

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Voriges, eigene, offene Fenster nach vorne bringen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_down( void );

 !item [Pascal:]            Procedure Awi_down;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_down bringt das vorige, eigene und offene GEM-Fenster
nach oben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_up
!end_enumerate

!end_node


!begin_node Awi_fulled

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Offenes Fenster auf maximale Grîûe bringen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_fulled( Awindow *window );

 !item [Pascal:]            Procedure Awi_fulled( window: AwindowPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_fulled bringt das offene Fenster auf seine maximale
Grîûe in den Zustand AWS_FULL. Falls das Fenster bereits im Zustand
AWS_FULL ist, nimmt das Fenster seine vorige Position und Grîûe ein.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_gemscript

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  GEMScript-Kommandos an das Fenster verarbeiten

 !item [Kategorie:]         Fenster-Funktionen, GEMScript-Protokoll

 !item [C:]                 int16 Awi_gemscript( Awindow *wi,
                             int16 anz, char **cmd,
                             A_GSAntwort *antwort );

 !item [Pascal:]            Function Awi_gemscript(
                                   window: AwindowPtr;
                                   anz: Integer; cmd: Pointer;
                                   antwort: A_GSAntwortPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_gemscript bearbeitet einige standardmÑûig in (!I)ACSpro(!i)
implementierte, fensterspezifische GEMScript-Kommandos. Diese sind

!begin_xlist [GetAllCommands]
 !item [CheckCommand]    PrÅft, ob das angegebene Kommando verstanden wird

 !item [GetAllCommands]  Liefert eine alphabetisch sorierte Liste der vom
                 Fenster verstandenen GEMScript-Kommandos zurÅck

 !item [GetFront]        Gibt den Namen des obersten Fensters zurÅck

 !item [KeyPress]        Simuliert eien Tastendruck

 !item [ToFront]         Bringt das angegebene oberste Fenster nach vorne
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen, GEMScript-Protokoll
!end_enumerate

!end_node


!begin_node Awi_help

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Aufruf der ST-Guide-Hilfe fÅr das Åbergebene
                    Fenster

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_help( Awindow *window );

 !item [Pascal:]            Function Awi_help( window: AwindowPtr ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_help liest aus der Fensterstruktur die Hilfe-Daten
aus und sendet der Service-Routine die Nachricht AS_ASK_STGUIDE. Die
Service-Routine hat dabei Gelegenheit, den Titel der Hilfeseite zu
verÑndern, um eine andere Hilfe anzuzeigen (das Editor-Fenster macht
es so) oder diese komplett auszuschalten.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Aev_STGuideHelp, Aus_help
!end_enumerate

!end_node


!begin_node Awi_hslid

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Inhalt des Fensters horizontal positionieren

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_hslid( Awindow *window, int16 pos );

 !item [Pascal:]            Procedure Awi_hslid( window: AwindowPtr;
                                 pos: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_hslid positioniert den Inhalt des offenen Fensters
auf die horizontale Position pos (links = 1, rechts = 1000).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_vslid
!end_enumerate

!end_node


!begin_node Awi_init

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Init-Routine des Fensters (Dummy-Funktion)

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_init( Awindow *window );

 !item [Pascal:]            Function Awi_init( window: AwindowPtr ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_init tut nichts und gibt einfach OK zurÅck. Sie ist
also eine reine Dummyroutine.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_keys

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TastendrÅcke fÅr ein Fenster verarbeiten

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_keys( Awindow *window, int16 kstate,
                             int16 key );

 !item [Pascal:]            Function Awi_keys(
                                   window: AwindowPtr;
                                   kstate, key: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_keys bedient Tasten in einem Fenster. Als
Alternativen stehen Awi_keysend, Awi_sendkey und Awi_nokey zur
VerfÅgung.

Die Funktion ruft intern Awi_keysend auf, unterdrÅckt aber den
RÅckgabewert -2. Damit werden nicht verarbeitete TastendrÅcke nicht
mehr an den AV-Server weitergeleitet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_keysend, Awi_nokey, Awi_sendkey
!end_enumerate

!end_node


!begin_node Awi_keysend

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TastendrÅcke fÅr ein Fenster verarbeiten

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_keysend( Awindow *window, int16 kstate,
                             int16 key );

 !item [Pascal:]            Function Awi_keysend(
                                   window: AwindowPtr;
                                   kstate, key: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_keysend bedient Tasten in einem Fenster. Als
Alternativen stehen Awi_keys, Awi_sendkey und Awi_nokey zur VerfÅgung.

Es werden zwei Modi unterschieden, die sich gegenseitig ausschlieûen:
Fenster mit und ohne Objektliste - nur in letzteren dÅrfen sich
Eingabefelder befinden.

!begin_xlist [Fenster-Dialog]
 !item [Objektliste]
                  !begin_xlist [Enter, Return]
                  !item [Cursortaste]    Bewegt die Auswahl ein Objekt weiter.
                                 Ist keine Auswahl vorhanden, wird ein
                                 Objekt ausgewÑhlt.

                  !item [Clr]            Setzt die Auswahl auf das erste
                                 Objekt.

                  !item [Home]           Setzt die Auswahl auf das letzte
                                 Objekt.

                  !item [UNDO]           Hebt die Auswahl auf.

                  !item [Enter, Return]  Existiert zu dem Objekt eine Click-
                                 Routine, wird diese angesprungen
                                 -praktisch ein Doppelklick.

                  !item [HELP]           Die ST-Guide-Seite fÅr das Fenster
                                 wird aufgerufen

                  !item [Zeichen:]       Es wird das Objekt gesucht, dessen
                                 per Aob_gettext ermittelter Name mit
                                 dem eingegebenen Zeichen beginnt.
                                 Dabei werden die ersten korrekten
                                 Buchstaben und Zahlen betrachtet.
                  !end_xlist

 !item [Fenster-Dialog]
                  !begin_xlist [Enter, Return]
                  !item [Enter, Return]    Die Click-Routine des Default-
                                   Objektes wird ausgefÅhrt.

                  !item [HELP]             Die ST-Guide-Seite fÅr das Fenster
                                   wird aufgerufen

                  !item [Control-Tab]      Das nÑchste per AO_DEFABLE
                                   markierte Objekte wird zum
                                   Default-Objekt.

                  !item [Shift-Cursor]     Plaziert den Cursor jeweils ans
                                   Ende oder Anfang einer Textzeile
                                   oder des gesamten Dialoges.

                  !item [Control-Cursor]   Springt in einer Zeile wortweise.

                  !item [sonstige Tasten]  Das Zeichen wird soweit mîglich
                                   eingetragen.
                  !end_xlist
!end_xlist

Der RÅckgabewert ist nicht nur fÅr Awi_dialog wichtig, sondern
signalisiert (!I)ACSpro(!i) auch, ob eine Taste weiter gereicht werden soll:

!begin_xlist [>=0]
 !item [>=0]  Die Taste wurde von dem Objekt mit dieser Nummer konsumiert. In
      Awi_dialog gilt dies als Ausgangskriterium.

 !item [-1]   Diese Taste wurde nicht verarbeitet, soll jedoch nicht
      weitergereicht werden.

 !item [-2]   Diese Taste wurde nicht vrarbeitet und soll an den AV-Server
      weitergereicht werden.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_keys, Awi_nokey, Awi_sendkey
!end_enumerate

!end_node


!begin_node Awi_layout

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  3D-Darstellung und moderne MenÅs ein-/ausschalten

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_layout( const int16 flag3D,
                            const int16 flagModernMenu,
                            const int16 redraw );

 !item [Pascal:]            Procedure Awi_layout( flag3D, flagModernMenu,
                                 redraw: int16 );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_layout schaltet zwischen 3D-Darstellung und 2D-
Darstellung um. Ferner werden die modernen MenÅs ein- und
ausgeschaltet. Die Umschaltung der MenÅs erfolgt nach Röckfrage beim
zugehîrigen Fenster mittels der Nachricht AS_CHANGE_LAYOUT. Verbietet
das Fenster die Umstellung, so wird das MenÅ nicht angetastet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_list

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die nÑchste Fensterstruktur ermitteln (zyklisch)

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_list( void );

 !item [Pascal:]            Function Awi_list : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_list gibt die nÑchste existente Fensterstruktur
zurÅck. Der Vorgang erfolgt zyklisch.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_modal

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Obersten modalen Fensterdialog ermitteln

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_modal( void );

 !item [Pascal:]            Function Awi_modal : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_modal ermittelt den obersten modalen Fensterdialoge
ist. Der RÅckgabewert NULL bzw. NIL signalisiert, daû es gibt es
keinen offenen Fensterdialog gibt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_alert, Awi_dialog,Awi_doform
!end_enumerate

!end_node


!begin_node Awi_moved

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Fenster verschieben

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_moved( Awindow *window, Axywh *new );

 !item [Pascal:]            Procedure Awi_moved( window: AwindowPtr;
                                 new: AxywhPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_moved ist fÅr das Verschieben von Fenstern auf dem
Bildschirm zustÑndig. Sie ist bis auf die Ausnahme, daû Listenfenster
nicht neu berechnet werden mÅssen, identisch mit Awi_sized.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_sized
!end_enumerate

!end_node


!begin_node Awi_name

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Fenster anhand des Fenster-Titels ermitteln

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]

 !item [Pascal:]            Function Awi_name(
                                   title: Pointer; sensitiv: Integer
                                ) : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_name versucht, anhand des Fenstertitels die
Fensterstruktur ausfindig zu machen (wird bei GEMScript verwendet).
Der Vergleich findet ohne fÅhrende und ohne abschlieûende Leerzeichen
statt. Das Åbergebene Flag steuert, ob der Vergleich casesensitiv
(TRUE) oder caseinsensitiv (FALSE) durchgefÅhrt wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_nokey

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TastendrÅcke fÅr ein Fenster verarbeiten

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_nokey( Awindow *window, int16 kstate,
                             int16 key );

 !item [Pascal:]            Function Awi_nokey(
                                   window: AwindowPtr;
                                   kstate, key: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_nokey ist eine Tastaturroutine, die eigentlich nichts
macht. Sie ist eine Alternative zu Awi_keys, wenn keine editierbaren
Felder bearbeitet werden. Da sie den RÅckgabewert -1 zurÅckgibt,
werden TastendrÅcke ignoriert und (!I)nicht(!i) an den AV-Server
weitergeleitet

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_keys, Awi_keysend, Awi_sendkey
!end_enumerate

!end_node


!begin_node Awi_obchange

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Schnelle Zeichenroutine fÅr ZustandsÑnderungen
                    eines Objektes

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_obchange( Awindow *window,
                             int16 obnr, int16 new_state );

 !item [Pascal:]            Procedure Awi_obchange( window: AwindowPtr;
                                   obnr, new_state: Integer);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_obchange ist eine schnelle Zeichenroutine, die fÅr
énderungen des Zustandes optimiert wurde.

Sind alter und neuer Zustand gleich, werden die Objekte ab obnr neu
gezeichnet. Diese Routine lehnt sich an den AES-Aufruf objc_change an.

Falls verÑnderte, in der LÑnge variable Texte damit aufzufrischen
sind, sollte der OBJECT- Type G_BOXTEXT verwendet werden, der Rahmen
kann abgeschaltet werden.

Problematisch wird es, wenn z.B. die Rahmendicke verkleinert wurde.
Der ehemals grîûere Rahmen wird nicht weggenommen. FÅr diesen Fall
gibt es Awi_obredraw, der diese FunktionalitÑt bietet.

Wird als 'new_state' -1 Åbergeben, bleibt der 'ob_state' erhalten. Da
dieser Fall recht hÑufig auftritt, spart man damit Code und
Schreibarbeit.

Um Objekte im Toolbar anzusprechen muû 'obnr' mit A_TOOLBAR per Oder
verknÅpft werden. Z.B. wird in Pure-C mit

!begin_sourcecode
     Awi_obchange (wi, A_TOOLBAR | 0, -1);
!end_sourcecode

die ganze Toolbar neu gezeichnet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_obredraw
!end_enumerate

!end_node


!begin_node Awi_obredraw

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenroutine fÅr das Neuzeichnen eines Objektes
                    per Awi_redraw

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_obredraw( Awindow *window, int16 obnr );

 !item [Pascal:]            Procedure Awi_obredraw( window: AwindowPtr;
                                   obnr: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_obredraw zeichnet alles unter dem Objekt obnr neu.
Dazu wird der Aufruf Awi_redraw verwendet. Der Aufruf ist langsamer
als Awi_obchange, aber sehr zuverlÑssig im Auffrischen der Anzeige.

Es kînnen auch verkleinerte Rahmen korrekt aufgefrischt werden.
Insbesondere fÅr versteckte Objekte kommt dieser Aufruf zu Einsatz.
Wurde das Objekt obnr versteckt, kann Awi_obchange nichts zeichnen.
Awi_obredraw frischt den Bereich auf, wo sich zuvor dieses Objekt
befand.

Um Objekte im Toolbar anzusprechen muû 'obnr' mit A_TOOLBAR per OR
verknÅpft werden. Z.B. wird in Pure-C mit

!begin_sourcecode
     Awi_obredraw(wind, A_TOOLBAR | 0);
!end_sourcecode

die ganze Toolbar neu gezeichnet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_obchange
!end_enumerate

!end_node


!begin_node Awi_observice

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Nachricht an ein Objekt im Fenster senden

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Awi_observice( Awindow *window, int16 obnr,
                             int16 task, void *in_out );

 !item [Pascal:]            Function Aob_service(
                                   window: AwindowPtr; obnr, task:
                    int16;
                                   in_out: Pointer
                                ) : MFDBPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_observice leitet die Åbergebene Nachricht an das
durch obnr angegebene Objekt weiter. Die Funktion benutzt die Funktion
Aob_service, Objekte der Toolbar werden wie Åblich durch die OR-
VerknÅpfung mit A_TOOLBAR dargestellt.

(!B)Hinweis:(!b) Falls das Flag AB_LAZYEVAL in (!link [ACSblk->description->flags] [Adescr])
gelîscht ist, wird geprÅft, daû das Fenster existiert, bei gesetztem
Flag findet keinerlei PrÅfung statt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Aob_service
!end_enumerate

!end_node


!begin_node Awi_obview

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das innere Objekt verschieben oder das Fenster
                    vergrîûern, um einen Ausschnitt sichtbar zu machen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_obview( Awindow *window, Axywh *xywh );

 !item [Pascal:]            Procedure Awi_obview( window: AwindowPtr;
                                 xywh: AxywhPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_obview verschiebt das innere Objekt des offenen
Fensters oder vergrîûert das Fenster, das durch xywh beschriebene
Rechteck sichtbar wird.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_obvisible

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eltern-Objekt eines gegebenen Objektes ermitteln

 !item [Kategorie:]         Object-Funktionen

 !item [C:]                 int16 Awi_obvisible( Awindow *window, int16 obnr);

 !item [Pascal:]            Function Awi_obvisible(
                                   window: AwindowPtr; obnr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_obvisible prÅft, ob das durch 'obnr' bezeichnete
Objekt im Fenster sichtbar sein kînnte. Wie Åblich werden Objekte der
Toolbar per Or mit A_TOOLBAR verknÅpft.

Die Funktion prÅft, daû das Fenster geîffnet, nicht ikonifiziert und
nicht im Zustand AWS_SHADED ist, da dann kein Objekt des Fensters
sichtbar sein kann. FÅr die PrÅfung der Sichtbarkeit innerhalb der
Toolbar bzw. des Work-Objektes wird Aob_visible verwendet. Der
RÅckgabewert TRUE signalisiert, daû das Objekt - bei passendem
Fenster-Ausschnitt - sichtbar ist, ein Wert FALSE gibt an, daû das
Objekt nicht sichtbar sein kann.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Aob_visible
!end_enumerate

!end_node


!begin_node Awi_ontop

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das oberste Fenster der Applikation ermitteln

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_ontop();

 !item [Pascal:]            Function Awi_ontop : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_ontop liefert das oberste Fenster der Anwendung
zurÅck. Falls kein Fenster geîffnet ist, so wird Awi_root()
zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_open

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein Fenster îffnen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_open( Awindow *window );

 !item [Pascal:]            Function Awi_open( window: AwindowPtr ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_open îffnet das Åbergebene Fenster. Es erscheint auf
dem Desktop. Konnte keine GEM-Fenster-ID freigemacht werden, wird dies
in einer Alarmbox mitgeteilt und FAIL oder bei Erfolg OK
zurÅckgegeben.

Die Slider werden auf die Werte, die in (!link [wi->wi_slider] [Awindow.wi_slider]) enthalten sind
gesetzt!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_closed
!end_enumerate

!end_node


!begin_node Awi_redraw

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein Rechteck des Fensters neu zeichnen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_redraw( Awindow *window, Axywh *limit );

 !item [Pascal:]            Procedure Awi_redraw( window: AwindowPtr; limit:
                    AxywhPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_redraw zeichnet im Bereich des Rechteckes limit das
Fenster window neu.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_root

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Root-Fenster (Desktop) ermitteln

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_root( void );

 !item [Pascal:]            Function Awi_root : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_root gibt den Zeiger auf die Struktur des
Rootfensters (Desktop) zurÅck.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_saved

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  OLGA-Manager und andere OLGA-Fenster vom Sichern
                    eines Dokumentes benachrichtigen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_saved( Awindow *window,
                            const char *datei );

 !item [Pascal:]            Procedure Awi_saved( window: AwindowPtr;
                                 datei: Pointer )

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_saved schickt allen Fenstern, die eine OLGA-
Verbindung mit der angegebenen Datei haben, die Nachricht
AS_OLGA_UPDATE zu. Der OLGA-Manager wird per OLGA_UPDATE vom Speichern
benachrichtigt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_scroll

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Den Inhalt des Fensters scrollen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_scroll( Awindow *wi, int16 x, int16 y);

 !item [Pascal:]            Procedure Awi_scroll( wi: AwindowPtr; x, y:
                    Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_scroll verschiebt den Inhalt des Fensters, indem nach
Mîglichkeit ein Rastercopy verwendet wird. Der Objektbaum wi->work muû
vor Aufruf an die neue Position gebracht werden (ob_x, ob_y).
Anschlieûend wird Awi_scroll mit den ALTEN Positionswerten aufgerufen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_create

  !item Awi_closed
!end_enumerate

!end_node


!begin_node Awi_selfcreate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Erzeugen eines "einfachen" Fensters

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_selfcreate( void *wi );

 !item [Pascal:]            Function Awi_selfcreate( wi: Pointer ) :
                    AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Mit der Funktion Awi_selfcreate steht eine (!link [Create-Routine] [Awindow.create]) zur
VerfÅgung, die fÅr Fenster ohne eigene Daten und ohne sonstige
Initialisierungen geeignet ist. Dies ist die Routine, die als
'Standard' im ACS-Builder eingetragen wird/werden kann.

FÅr viele Fenster, die keine initialisierten Daten benîtigen, genÅgt
die Angabe dieser Routine als 'create'-Routine in der eigenen
Awindow-Struktur. Als Parameter an die Funktion wird die Adresse auf
die Fensterstruktur Åbergeben, also z.B.

in Pure-C:

     wi = WI_ALERT.create(&WI_ALERT);

in Pure-Pascal:

     wi := WI_ALERT.create(@WI_ALERT);

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_create
!end_enumerate

!end_node


!begin_node Awi_sendall

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Allen Fenstern eine Nachricht senden

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_sendall( int16 task, void *in_out );

 !item [Pascal:]            Procedure Awi_sendall( task: Integer; in_out:
                    Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_sendall sendet allen Fenstern die selbe Nachricht zu.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_sendkey

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TastendrÅcke fÅr ein Fenster verarbeiten

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_sendkey( Awindow *window, int16 kstate,
                    int16 key );

 !item [Pascal:]            Function Awi_sendkey(
                                   window: AwindowPtr; kstate, key:
                    Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_sendkey ist eine Tastaturroutine, die nichts macht.
Da sie als RÅckgabewert stets -2 zurÅckgibt, werden normalerweise alle
TastendrÅcke an den AV-Server weitergeleitet. Sie ist eine Alternative
zu Awi_keys, wenn keine editierbaren Felder bearbeitet werden,
TastendrÅcke aber an den AV-Server gemeldet werden sollen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_keys, Awi_keysend, Awi_nokey
!end_enumerate

!end_node


!begin_node Awi_service

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  RudimentÑre (!link [Service-Routine] [Awindow.service])

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 int16 Awi_service( Awindow *window,
                             int16 task, void *in_out );

 !item [Pascal:]            Function Awi_service(
                                   window: AwindowPtr; task: Integer;
                                   in_out: Pointer
                                ) : Boolean;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Mit der Funktion Awi_service steht eine eher rudimentÑre Service-
Routine zur VerfÅgung. Sie bearbeitet die Nachricht AS_TERM, bei der
die Routine Awi_delete aufgerufen wird, und in AnsÑtzen die Nachricht
AS_GEM_MESS. Der RÅckgabewert (TRUE oder FALSE) zeigt an, ob der
angeforderte Service angeboten wurde und auch erfolgreich bearbeitet
werden konnte..

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_sized

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein Fenster vergrîûern oder verkleinern

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_sized( Awindow *window, Axywh *new );

 !item [Pascal:]            Procedure Awi_sized( window: AwindowPtr; new:
                    AxywhPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_sized setzt das offene Fenster window an das, in der
Struktur new, beschriebene Rechteck. Das Fenster verliert den Zustand
AWS_FULL. Listenfenster werden neu berechnet.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_moved
!end_enumerate

!end_node


!begin_node Awi_show

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein Fenster anzeigen bzw. nach oben bringen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_show( Awindow *window );

 !item [Pascal:]            Procedure Awi_show( window: AwindowPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_show îffnet das Fenster, oder bringt das Fenster nach
oben, falls es schon offen ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_topped

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ein geîffnetes Fenster nach oben bringen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_topped( Awindow *window );

 !item [Pascal:]            Procedure Awi_topped( window: AwindowPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_topped bringt ein offene Fenster nach oben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_uoself

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Alle Userdefs des Toolbar- und/oder Work-Objektes
                    mit der Nachricht AUO_SELF versorgen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_uoself( void *wind );

 !item [Pascal:]            Procedure Awi_uoself( wi: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_uoself versorgt alle Userdef-Objekte, die sich im
Toolbar- oder im Work-Objektbaum befinden, mit den nîtigen AUO_SELF-
Nachrichten. Awi_create ruft diese Routine selber auf.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_up

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NÑchstes, eigene, offene Fenster nach vorne
                    bringen

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_up( void );

 !item [Pascal:]            Procedure Awi_up;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_up bringt das nÑchste, eigene und offene GEM-Fenster
nach oben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_down
!end_enumerate

!end_node


!begin_node Awi_update

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Protokollierende Funkton fÅr wind_update

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_update( int16 mode );

 !item [Pascal:]            Procedure Awi_update( mode: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_update muû statt der AES-Funktion wind_update
verwendet werden, damit (!I)ACSpro(!i) diese Aufrufe mitprotokollieren kann.

Der mode-Wert ist analog zu wind_update belegt:

!begin_xlist [RESTART_UPDATE]
 !item [BEGIN_UPDATE]    Startet den ausschlieûlichen Bildschirmzugriff.

 !item [END_UPDATE]      Beendet den ausschlieûlichen Bildschirmzugriff.

 !item [BEGIN_MCTR]      Startet die ausschlieûliche Mauskontrolle.

 !item [END_MCTR]        Beendet die ausschlieûliche Mauskontrolle.

 !item [RESET_UPDATE]    Schaltet eine eventuelle Kontrolle aus.

 !item [RESTART_UPDATE]  Stellt den Zustand vor RESET_UPDATE wieder her.
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Awi_vslid

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Inhalt des Fensters vertikal positionieren

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 void Awi_vslid( Awindow *window, int16 pos );

 !item [Pascal:]            Procedure Awi_vslid( window: AwindowPtr; pos:
                    Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_vslid positioniert den Inhalt des offenen Fensters
auf die vertikale Position pos (oben = 1, unten = 1000).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen

  !item Awi_hslid
!end_enumerate

!end_node


!begin_node Awi_wid

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zu einer GEM-Fenster-ID das Fensters ermitteln

 !item [Kategorie:]         Fenster-Funktionen

 !item [C:]                 Awindow *Awi_wid( const int16 wid );

 !item [Pascal:]            Function Awi_wid( wid: Integer ) : AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Awi_wid gibt den Zeiger auf die Fensterstruktur, die
diese GEM-ID benutzt, zurÅck. Wenn diese GEM-Fenster-ID nicht durch
(!I)ACSpro(!i) belegt ist, wird NULL bzw. NIL zurÅckgegeben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Fenster-Funktionen
!end_enumerate

!end_node


!begin_node Ax_free

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Speicherblock freigeben

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 void Ax_free( void *memory );

 !item [Pascal:]            Procedure Ax_free( memory: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_free kennzeichnet den Åbergebenen Speicherblock als
frei. Der Speicherblock wird jedoch erst nach RÅckkehr zur
Hauptschleife freigegeben. Daher kann auch nach der Freigabe das
Objekt ohne Fehler bis zur RÅckkehr zur Hauptschleife referenziert
werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung

  !item Ax_ifree, Ax_malloc
!end_enumerate

!end_node


!begin_node Ax_ifree

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Speicherblock sofort freigeben (also ungepuffert)

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 void Ax_ifree( void *memory );

 !item [Pascal:]            Procedure Ax_ifree( memory: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_ifree gibt den Åbergebenen Speicherblock (!I)sofort(!i) frei.
Der Speicherblock darf nach diesem Funktionsaufruf nicht mehr benutzt
werden.

(!B)Hinweis:(!b) Diese Routine sollte nur mit Ñuûerster Vorsicht benutzt
werden. (!I)Auf keinen Fall darf man sie fÅr Fensterstrukturen,
ObjektbÑume oder Userblk-Strukturen verwenden.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung

  !item Ax_free, Ax_malloc
!end_enumerate

!end_node


!begin_node Ax_getRecycleStat

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Verwaltung der freien Listen konfigurieren

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 MemFreeBlockStat *Ax_getRecycleStat(
                                         int16 *anzahl );

 !item [Pascal:]            Function Ax_getRecycleStat(
                                   Var anzahl: int16
                                 ) : MemFreeBlockStatPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_getRecycleStat liefert die zum aktuellen Zeitpunkt
gÅltige Statistik der Listen freier Blîcke zurÅck. Die Anzahl der
Listen wird im Åbergebenen Zeiger eingetragen, eine Liste mit den
Daten wird als Funktionsergebnis geliefert.

(!B)Hinweis:(!b) Eine genauere ErklÑrung zur Funktionsweise der "Listen freier
Blîcke" finden Sie bei der Speicherverwaltung.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung

  !item Ax_free, Ax_ifree, Ax_malloc, Ax_recycle

  !item Ax_setRecycleSize
!end_enumerate

!end_node


!begin_node Ax_malloc

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Speicherblock allozieren

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 void *Ax_malloc( long size );

 !item [Pascal:]            Function Ax_malloc( size: LongInt ) : Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_malloc alloziert einen Speicherblock und stellt ihn
zur Benutzung zur VerfÅgung. (!I)ACSpro(!i) macht intern (!I)alle(!i)
Speicheranforderungen Åber diese Routine. Die FUnktion versucht, bei
bestimmten Blockgrîûen die per Ax_recycle "freigegebenen" und
gepufferten Blîcke wieder zu verwenden.

Die Routine ist Accessory-fest, d.h. mit Ax_malloc angeforderter
Speicher Åberlebt das rabiate GEM-Verhalten!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung

  !item Ax_free, Ax_ifree, Ax_recycle
!end_enumerate

!end_node


!begin_node Ax_memCheck

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Speicherblock auf Lese- und Schreibzugriff prÅfen

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 int16 Ax_memCheck( const char *buffer,
                             INT32 len, int16 write);

 !item [Pascal:]            Function Ax_memCheck(
                                   buffer: Pointer; len: INT32;
                                   write: int16
                                ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_memCheck prÅft, ob der in buffer Åbergebenen
Speicherblock gelesen und ggf. (fÅr write=TRUE) beschrieben werden
kann.

Unter Systemen mit Speicherschutz (im Moment nur unter MiNT) muû
(!I)globaler(!i) Speicher fÅr einen Informations-Austausch mit anderen
Anwendungen beschafft werden. Leider gibt es einige Programme, die
sich nicht daran halten. Als Folge davon wurde (!I)ACSpro(!i) bislang mit
einer "Schutzverletzung" gekillt - obwohl es doch eigentlich
unschuldig ist - sobald ein Informationsaustausch mit solchen
"Rabauken" ;-) im Gange war...

Der Parameter len hat hierbei folgende Bedeutung:

!begin_xlist [other]
 !item [<-2]    Es wird wird nichts geprÅft.

 !item [-2]     Der Speicherblock ist ein ASCIIZZ-String, wie er fÅr GEMScript
        benîtigt wird (siehe auch Ast_mergeASCIIZZ). Es wird
        einschlieûlich bis zum ersten Null-Doppel-Byte geprÅft

 !item [-1]     Der Speicherblock wird als String geprÅft, d.h. bis
        einschlieûlich zum ersten Null-Byte

 !item [sonst]  Der Speicherblock wird bis zur LÑnge von len Byte (incl.)
        geprÅft
!end_xlist

(!I)ACSpro(!i) prÅft intern mit dieser Funktion, ob Åber die diversen
Protokolle Åbergebene Adressen auch gelesen und ggf. beschrieben
werden kînnen. Im Fehlerfalle wird Åber die normale RÅckmeldung eine
Fehlermeldung an den "Bîsewicht" gesendet. Der Aufruf von Ax_memCheck
sollte also normalerweise nicht benîtigt werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung
!end_enumerate

!end_node


!begin_node Ax_recycle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Einen Speicherblock freigeben, aber ggf. puffern

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 void Ax_recycle( void *memory, INT32 size );

 !item [Pascal:]            Procedure Ax_recycle( memory: Pointer;
                                 size: INT32 );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_recycle versucht, vor der Freigabe des Speichers, den
Block in eine Liste der freien Blîcke zu Åbernehmen.

(!B)Hinweis:(!b) Eine genauere ErklÑrung zur Funktionsweise der "Listen freier
Blîcke" finden Sie bei der Speicherverwaltung.

(!B)Beispiel:(!b) Die Funktion Awi_delete ruft intern die Funktion Ax_recycle
folgendermaûen auf: Ax_recycle(wind, sizeof(*wind)).

(!B)Tip:(!b) Wenn am Ende der (!I)ACSpro(!i)-Anwendung die Statistik per
Ax_getRecycleStat ermittelt und in eine Datei geschrieben wird, so
kann die Verwaltung der freien Blîcke in der Routine ACSinit0 mittels
Ax_setRecycleSize auf jede Anwendung und den entsprechenden Einsatz-
Zweck optimiert werden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung

  !item Ax_free, Ax_ifree, Ax_malloc

  !item Ax_getRecycleStat, Ax_setRecycleSize
!end_enumerate

!end_node


!begin_node Ax_setRecycleSize

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Verwaltung der freien Listen konfigurieren

 !item [Kategorie:]         Speicherverwaltung

 !item [C:]                 int16 Ax_setRecycleSize( INT32 size, int16 amount,
                             char *beschreibung );

 !item [Pascal:]            Function Ax_setRecycleSize(
                                   size: INT32; amount: int16;
                                   beschreibung: Pointer
                                 ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion Ax_setRecycleSize konfiguriert die Listen der freien
Blîcke der (!I)ACSpro(!i)-Speicherverwaltung.

(!B)Hinweis:(!b) Eine genauere ErklÑrung zur Funktionsweise der "Listen freier
Blîcke" finden Sie bei der Speicherverwaltung.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Speicherverwaltung

  !item Ax_free, Ax_ifree, Ax_malloc, Ax_recycle

  !item Ax_getRecycleStat
!end_enumerate

!end_node


!begin_node A_3Dbutton

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenroutine des Userdef-Arrows

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Arrows

 !item [C:]                 int16 CDECL A_3Dbutton( PARMBLK *pb );

 !item [Pascal:]            Function A_3Dbutton(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_3Dbutton ist die Zeichen-Routine fÅr das Userdef-3D-Button.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item 3D-Button (Auo_string)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_arrows

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenroutine des Userdef-Arrows

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Arrows

 !item [C:]                 int16 CDECL A_arrows( PARMBLK* pb );

 !item [Pascal:]            Function A_arrows(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_arrows ist die Zeichen-Routine fÅr das Userdef-Arrows.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Arrows

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_boxed

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenroutine des Userdef-BoxEdit

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-BoxEdit

 !item [C:]                 int16 CDECL A_boxed( PARMBLK* pb );

 !item [Pascal:]            Function A_boxed(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_boxed ist die Zeichen-Routine fÅr das Userdef-BoxEdit.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item BoxEdit (Auo_boxed/Aus_boxed)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_checkbox

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenroutine des Userdef-Checkbox bzw. Userdef-
                    Radiobutton

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Checkbox,
                    Userdef-Radiobutton

 !item [C:]                 int16 CDECL A_checkbox( PARMBLK* pb );

 !item [Pascal:]            Function A_checkbox(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_checkbox ist die Zeichen-Routine fÅr das Userdef-Checkbox und das
Userdef-Radiobutton. Es wird eine Checkbox/Radiobutton mit Text
gezeichnet.

Es wird eine Box/Ellipse gezeichnet, die in allen Richtungen um 3
Pixel nach innen versetzt ist, aber mindestens 6 Pixel groû ist. Ist
das Objekt selektiert, dann wird ein Kreuz bzw. eine ausgefÅllte
Ellipse gezeichnet. Optinal kann ein String angegeben werden. Ist ein
String vorhanden, wird der Button als Quadrat/Ellipse in der Hîhe des
Systemzeichensatz dargestellt. Der String wird wird rechtsbÅndig
angelegt. Ohne String wird eine Box/Ellipse gezeichnet, je nach
Geometriedaten.

Da VDI recht hÑûliche (kleine) Boxen/Ellipsen zeichnet, wird fÅr den
typischen Fall 16 mal 16 Pixel (2 mal 1 Zeichen in der monochromen
Auflîsung) ein Bild (Image) verwendet.

Wenn DISABLED gesetzt ist, wird eine graue-gemusterte Box/Kreis
gezeichnet, die sich als Grundlage fÅr Tri-State-Buttons eignet.

Tastenkodes werden im Text durch String Codes kenntlich gemacht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Checkbox] [Userdef-Checkbox])

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_cycle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Cycle

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Cycle

 !item [C:]                 int16 CDECL A_cycle( PARMBLK* pb );

 !item [Pascal:]            Function A_cycle(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_picture ist die Zeichen-Routine fÅr das Userdef-Cycle.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Cycle (Aus_cycle/Auo_cycle)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_dd

!label A_ddPtr
Diese Struktur wird bei Ash_nextdd benutzt und gibt Informationen Åber
die externen D&D-Partner aus.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   int16 id;
   long type;
   unsigned int16 xacc_val;
   const char *xacc_name;
   unsigned int16 va_val[3];
   const char *va_name;
} A_dd;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
A_dd = RECORD
      id:        Integer;
      dd_type:   Longint;
      xacc_val:  Word;
      xacc_name: Pointer;
      va_val:    packed array[1..3] of Word;
      va_name:   Pointer;
   END;

A_ddPtr = ^A_dd;
!end_sourcecode

(!I)(!B)Achtung:(!b) Es darf nur lesend auf diese Daten zugegriffen werden! (!i)

Die Komponenten der Struktur bedeuten

!begin_xlist [xacc_name]
 !item [id]         AES-Identifikation des Partners.

 !item [type]       Angabe, um was fÅr einen Partner es sich handelt. Der Wert
            ist als Bitvektor aufzufassen und hat bisher folgende
            Belegung:

             Bit 1:  reserviert.

             Bit 2:  XACC-Partner (siehe Konstante DD_XACC)

             Bit 3:  VA-Partner (sihe Konstante DD_VA)

 !item [xacc_val]   Wenn DD_XACC gesetzt ist, ist dies die unterstÅtzte
            Message-Group des Partners.

 !item [va_val]     Beinhaltet die drei Werte, die bei VA_PROTOSTATUS vom AV-
            Protokoll-Server geliefert werden.

 !item [xacc_name]
 !item [va_name]    Dies ist der Namen des Partners, jeweils fÅr XACC- und
            VA-Protokoll.
!end_xlist

!end_node


!begin_node A_dialog

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  System-modalen Dialog durchfÅhren

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 A_dialog( OBJECT *dia );

 !item [Pascal:]            Function A_dialog( dia: ACSTreePtr ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion A_dialog zeichnet den Dialog dia je nach Zustand des
Flags AB_CENTERDIALOG, zentriert in der Mitte des Desktops oder in der
NÑhe des Mauszeigers.

     (!B)Wenn mîglich, sollte diese Funktion ab Version 2.2 nicht
     mehr benutzt werden. Stattdessen stehen die Funktionen
     Awi_doform und Awi_dialog zur VerfÅgung.(!b)

ZurÅckgegeben wird die Nummer des angewÑhlten Objektes. Das
Doppelklickflag wird entfernt. Objekte mit dem Flags AO_DRAGABLE und
(!I)TOUCHEXIT(!i) erlauben den Dialog zu verschieben (fliegender Dialog). Bei
Objekten, denen eine click-Routine hinterlegt ist, wird diese
aufgerufen, ohne den Dialog zu beenden. Die Variable dia_abort erlaubt
den Dialog nach Aufruf durch eine click-Routine zu beenden. Dazu ist
diese Variable auf TRUE zu setzen. Ein Doppelklick auûerhalb des
Dialoges beendet ihn. Dann wird der Wert 0 zurÅckgegeben! Der modale
Dialog verhÑlt sich weitgehend wie ein nichtmodales Fenster. Der
Dialog wird dem Fenster ev_window zugeordnet. Zeitweilig werden die
Routinen obchange und redraw ausgetauscht, und das Fensterflag
AWS_MODAL gesetzt. Tastencodes werden ebenfalls unterstÅtzt.

Ab Version 2.2 genÅgt TOUCHEXIT nicht mehr, um den Dialog zu
verlassen, siehe auch Awi_dialog.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item Awi_dialog, A_dialog2, Awi_doform
!end_enumerate

!end_node


!begin_node A_dialog2

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Systemmodalen Dialog mit eigener Positionierung
                    durchfÅhren

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 A_dialog2( OBJECT *dia );

 !item [Pascal:]            Function A_dialog2( dia: ACSTreePtr ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion A_dialog2 zeichnet den Dialog an der in 'dia->ob_x' und
'dia->ob_y' bezeichneten Stelle. Damit erhÑlt der Programmierer die
Mîglichkeit selbst Åber die Position zu bestimmen

     (!B)Wenn mîglich, sollte diese Funktion ab Version 2.2 nicht
     mehr benutzt werden. Stattdessen stehen die Funktionen
     Awi_doform und Awi_dialog zur VerfÅgung.(!b)

ZurÅckgegeben wird die Nummer des angewÑhlten Objektes. Das
Doppelklickflag wird entfernt. Objekte mit dem Flags AO_DRAGABLE und
(!I)TOUCHEXIT(!i) erlauben den Dialog zu verschieben (fliegender Dialog). Bei
Objekten, denen eine click-Routine hinterlegt ist, wird diese
aufgerufen, ohne den Dialog zu beenden. Die Variable dia_abort erlaubt
den Dialog nach Aufruf durch eine click-Routine zu beenden. Dazu ist
diese Variable auf TRUE zu setzen. Ein Doppelklick auûerhalb des
Dialoges beendet ihn. Dann wird der Wert 0 zurÅckgegeben! Der modale
Dialog verhÑlt sich weitgehend wie ein nichtmodales Fenster. Der
Dialog wird dem Fenster ev_window zugeordnet. Zeitweilig werden die
Routinen obchange und redraw ausgetauscht, und das Fensterflag
AWS_MODAL gesetzt. Tastencodes werden ebenfalls unterstÅtzt.

Ab Version 2.2 genÅgt TOUCHEXIT nicht mehr, um den Dialog zu
verlassen, siehe auch Awi_dialog.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item Awi_dialog, A_dialog
!end_enumerate

!end_node


!begin_node A_editor

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Editor

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Editor

 !item [C:]                 int16 CDECL A_editor( PARMBLK* pb );

 !item [Pascal:]            Function A_editor(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_editor ist die Zeichen-Routine fÅr das Userdef-Editor.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Editor (Auo_editor/Aus_editor)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_ftext

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-FText

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-FText

 !item [C:]                 int16 CDECL A_ftext( PARMBLK* pb );

 !item [Pascal:]            Function A_ftext(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_ftext ist die Zeichen-Routine fÅr das Userdef-FText.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item FText (Auo_ftext)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_FileList

!label A_FileListPtr
In dieser Struktur werden die Dateien, die Af_readdir ermittelt,
abgelegt. Als verkettete Liste organisiert wird damit der Inhalt eines
Verzeichnisses beschrieben.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct afilelist
{
   char *file;
   struct afilelist *next;
   XATTR attribs;
} A_FileList;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
A_FileList = RECORD
      file    : Pointer;
      next    : A_FileListPtr;
      attribs : XATTR;
End;

A_FileListPtr = ^A_FileList;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!begin_xlist [attribs]
 !item [file]     Datei- oder Ordner-Name

 !item [attribs]  XATTR-Struktur, die die wichtgen und interessanten
          Informationen der Datei enthÑlt, soweit sie ermittelt werden
          konnten. Es wird hierzu Dxreaddir bzw. Fxattr benutzt.
          Stehen diese Funktionen nicht zur VerfÅgung (z.B. unter TOS
          ;-), so werden die zur VerfÅgung stehenden Informationen der
          DTA nach Fsfirst/Fsnext hier hineinkopiert.

 !item [next]     Zeiger auf die nÑchste A_FileList-Struktur oder NULL bzw.
          NIL, falls keine weitere Struktur existiert.
!end_xlist

!end_node


!begin_node A_innerframe

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Innerframe

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Innerframe

 !item [C:]                 int16 CDECL A_innerframe( PARMBLK* pb );

 !item [Pascal:]            Function A_innerframe(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_innerframe ist die Zeichen-Routine fÅr das Userdef-Innerframe.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Innerframe] [Userdef-Innerframe])

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_OlgaCreate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Eine registrierte OLGA-Verbindung erstellen

 !item [Kategorie:]         OLGA-Protokoll, OLGA-Server und OLGA-Client

 !item [C:]                 OLGA_Infos *A_OlgaCreate( const Awindow *window,
                                   const char *datei,
                                   const char *info_datei,


 !item [Pascal:]            Function A_OlgaCreate(
                                   window: AwindowPtr; datei: Pointer;
                                   info_datei: Pointer; flags: Integer
                                ) : OLGA_InfoPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion A_OlgaCreate erstellt eine registrierte OLGA-Verbindung.
Die Verbindung wird nur bei (!I)ACSpro(!i) registriert und noch nicht
hergestellt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item OLGA-Protokoll, OLGA-Server, OLGA-Client

  !item OLGA_Info

  !item A_OlgaDelete
!end_enumerate

!end_node


!begin_node A_pattern

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Pattern

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Pattern

 !item [C:]                 int16 CDECL A_pattern( PARMBLK* pb );

 !item [Pascal:]            Function A_pattern(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_pattern ist die Zeichen-Routine fÅr das Userdef-Pattern und erlaubt
es, verschiedene VDI-Muster zu wÑhlen (siehe auch VDI: v_bar).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Pattern] [Userdef-Pattern])

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_picture

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Picture

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Picture

 !item [C:]                 int16 CDECL A_picture( PARMBLK* pb );

 !item [Pascal:]            Function A_picture(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_picture ist die Zeichen-Routine fÅr das Userdef-Picture.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Picture (Auo_picture)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_title

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Title

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Title

 !item [C:]                 int16 CDECL A_title( PARMBLK* pb );

 !item [Pascal:]            Function A_title(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_title ist die Zeichen-Routine fÅr das Userdef-Title.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Title] [Userdef-Title])

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_select

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Select

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Select

 !item [C:]                 int16 CDECL A_select( PARMBLK *pb );

 !item [Pascal:]            Function A_select(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_select ist die Zeichen-Routine fÅr das Userdef-Select.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item (!link [Select] [Userdef-Select])

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node A_slider

!label A_wislider
!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichen-Routine des Userdef-Slider

 !item [Kategorie:]         Benutzerdefinierte Objekte, Userdef-Slider

 !item [C:]                 int16 CDECL A_slider( PARMBLK *pb );
                    int16 CDECL A_wislider( PARMBLK *pb );

 !item [Pascal:]            Function A_slider(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer; Function A_wislider(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

A_slider bzw. A_wislider ist die Zeichen-Routine fÅr das Userdef-
Slider.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Slider (Auo_slider/Aus_slider)

  !item Benutzerdefinierte Objekte
!end_enumerate

!end_node


!begin_node basename

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Name der Applikation

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char basename[20];

 !item [Pascal:]            basename: packed array [1..20] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable basename enthÑlt den Namen der Appikation ohne eine
Endung wie z.B. PRG. Die ersten zwei Zeichen sind mit Blanks belegt.

Wenn dieser Text in ACSinit0 geÑndert wird, erhÑlt die Applikation
diesen neuen Namen.

(!I)Die Variable ist nur gÅltig, wenn das Programm als Applikation lÑuft.(!i)

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, appfrom, appname, apppara, apppath,
!end_enumerate
     cfg_path, scrp_path, dd_name, alert_name

!end_node


!begin_node cfg_path

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Pfad der Konfigurationsdateien (HOME)

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char cfg_path[128];

 !item [Pascal:]            cfg_path: packed array [1..128] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable cfg_path enthÑlt den Pfad, wo die Konfigurationsdateien
gesucht werden. Die Vorgabe ist das HOME-Verzeichnis aus dem
Environment oder der Applikationspfad, falls die Environmentvariable
HOME nicht oder ungÅltig gesetzt ist.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, Ash_getenv
!end_enumerate

!end_node


!begin_node dd_name

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  D&D-Name der Applikation

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char *dd_name;

 !item [Pascal:]            dd_name: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable dd_name enthÑlt den D&D-Namen der Anwendung.

FÅr das D&D muû ein (!I)ACSpro(!i)-Programm einen Namen besitzen, dieser wird
aus basename abgeleitet unter hier eingetragen - das AV-Protokoll
benîtigt diesen Namen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Pfad-Variablen

  !item Ablk, AblkPtr, ACSblk, Ash_nextdd, Ash_sendall
!end_enumerate

!end_node


!begin_node DEBUG_MEM

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Routine fÅr Speicherfehler

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 void (*DEBUG_MEM)( void *defective );

 !item [Pascal:]            DEBUG_MEM: Procedure( defective: Pointer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable DEBUG_MEM enthÑlt die Adresse einer Routine, die (!I)ACSpro(!i)
anspringt, wenn Speicherfehler auftreten.

Die Alarmbox wird zuvor noch gezeigt. Die Routine selbst kann den
Speicher 'defective' prÅfen oder der Entwickler mit Hilfe des
Debuggers. Ein Speicherauszug kann wertvolle Hinweise liefern, warum
es zu diesem Fehler kam. Die Ausgabe des Stack gibt weitere Hinweise.

(!B)Hinweise:(!b) Einige typische Ursachen fÅr Speicherfehler sind:

!begin_enumerate !compressed
  !item mehrfaches freigeben

  !item Schreiben Åber den angeforderten Speicherbereich hinaus. Dann
     wird meist der Kopf eines anderen Speicherbereichs zerstîrt und
     (!I)ACSpro(!i) betrachtet ihn nicht mehr als gÅltig (z.B. beim Einsetzen
     eines zu langen Textes in ein OBJECT, siehe Aob_puttext).

  !item Zuweisen von Zeigern direkt in den Objektbaum z.B. bei Strings
     ohne Verwendung des AOS_CONST-Flags
!end_enumerate

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Funktions-Zeiger

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node desk

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Auûmaûe des Desktops ohne MenÅzeile

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 Axywh desk;

 !item [Pascal:]            desk: Axywh;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable desk beschreibt ein Rechteck, das den Ausmaûen des
Desktops ohne die MenÅleiste (graue FlÑche) entspricht.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node DESKTOP

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Root-Fenster DESKTOP

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 Awindow DESKTOP;

 !item [Pascal:]            In Pure-Pascal ist die Struktur DESKTOP
                    (!link [nicht direkt zugÑnglich] [ImpCVars]). Sie muû durch die
                    Funktion get_desktop erfragt werden.

!label get_desktop
                    Function get_desktop : Awindow;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable DESKTOP stellt die Fenster-Struktur des nur noch zur
KompatibilitÑt vorhandenen Desktop-Fensters dar.

Das Hintergrundobjekt des DESKTOP kann in der Routine ACSInit0
konfiguriert werden, wobei die Werte 'ob_type', 'ob_spec', 'ob_width'
und 'ob_height' Åbernommen werden:

!begin_xlist [Pascal:]
 !item [C:]       DESKTOP.service (NULL, AS_BACKOBJECT, &MYDESK);

 !item [Pascal:]  get_desktop^.service (NIL, AS_BACKOBJECT, @MYDESK);
!end_xlist

Die Icons des DESKTOPs kînnen inder Routine ACSinit0 ausgetauscht
werden:

!begin_xlist [Pascal:]
 !item [C:]       DESKTOP. service (NULL, AS_ICONNEW, &NEW_IC);
          DESKTOP. service (NULL, AS_ICONTRASH, &TRASH_IC);
          DESKTOP. service (NULL, AS_ICONWINDOW, &WINDOW_IC);

 !item [Pascal:]  get_desktop^.service (NIL, AS_ICONNEW, @NEW_IC);
          get_desktop^.service (NIL, AS_ICONTRASH, @TRASH_IC);
          get_desktop^.service (NIL, AS_ICONWINDOW, @WINDOW_IC);
!end_xlist

Auch die MenÅleiste des DESKTOPs kann ausgetauscht werden:

!begin_xlist [Pascal:]
 !item [C:]       DESKTOP. menu = &MY_MENU;

 !item [Pascal:]  get_desktop^. menu = @MY_MENU;
!end_xlist

Die im Original-MenÅbaum befindlichen Funktionen kînnen genutzt
werden. Diese sind

!begin_xlist [Aktion/Icons horizontal]
 !item [Datei/ôffnen]             Awd_open

 !item [Datei/Schlieûen]          Awd_close

 !item [Datei/Lîschen]            Awd_delete

 !item [Datei/Info]               Awd_info

 !item [Datei/Modul laden]        Awd_module

 !item [Datei/Beenden]            Awd_quit

 !item [Fenster/Wechseln]         Awi_up

 !item [Fenster/aus Liste]        Awd_list

 !item [Aktion/Icons horizontal]  Awd_hor

 !item [Aktion/Icons vertikal]    Awd_ver

 !item [Aktion/Verhalten]         Awd_behaviour

 !item [Aktion/...sichern]        Awd_save
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der generische Desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node dia_abort

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Abbruch-Flag eines modalen (Fenster-)Dialogs

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 dia_abort;

 !item [Pascal:]            dia_abort: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable dia_abort erlaubt den modalen (Fenster-)Dialog nach
Aufruf durch eine click-Routine zu beenden. Dazu ist in der click-
Routine die Variable auf TRUE zu setzen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node dither

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Definition des Dither-Modes

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 dither;

 !item [Pascal:]            dither: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Diese Variable enthÑlt die Definition des Dithermodes fÅr den
(!link [3D-Button] [Userdef-3D-Button]). Der Dithermode wird bei weniger als 4 Planes angewandt,
wenn das FÅllmuster voll (7) und die Farbe LWHITE (8) ist.

Die Bits der Variablen sind folgendermaûen belegt:

!begin_xlist [Bit 0-3]
 !item [Bit 0-3]  Farbe des FÅllmusters

 !item [Bit 4-6]  Patternindex des FÅllmusters

 !item [Bit 7]    Erzwinge deckenden Text (REPLACE)

 !item [Bit 8]    Erzwinge Groûschreibung

 !item [Bit 9]    Weiûer Rahmen (Farbe 0) wird gepunktet

 !item [Bit 10]   Grauer Rahmen (Farbe 9) wird gepunktet
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Ablk, AblkPtr, ACSblk, (!link [3D-Button] [Userdef-3D-Button])
!end_enumerate

!end_node


!begin_node dotted_xline

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Horizontale, punktierte Linie zeichnen

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 void dotted_xline( int16 x1, int16 x2,
                            int16 y );

 !item [Pascal:]            Procedure dotted_xline( x1, x2, y: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion dotted_xline zeichnet eine horizontale, punktierte Linie.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item dotted_yline
!end_enumerate

!end_node


!begin_node dotted_yline

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Vertikale, punktierte Linie zeichnen

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 void dotted_yline( int16 y1, int16 y2,
                            int16 x );

 !item [Pascal:]            Procedure dotted_yline( y1, y2, x: Integer );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion dotted_yline zeichnet eine vertikale, punktierte Linie.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item dotted_xline
!end_enumerate

!end_node


!begin_node EDITGETS

!label EDITGETSPtr
Das (!link [Editor] [Userdef-Editor])-Object wird aufgrund seiner KomplexitÑt ausschlieûlich mit
Nachrichten per (!link [Service] [Auo_editor])-Routine angesprochen. DafÅr werden
verschiedene Strukturen eingesetzt:

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   long row;
   long size;
   char *text;
} EDITGETS;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
EDITGETS = RECORD
      row:  LongInt;
      size: LongInt;
      text: Pointer;
END;

EDITGETSPtr = ^EDITGETS;
!end_sourcecode

In folgender Struktur gibt man vor dem Aufruf in 'row' die Zeile an,
die man auslesen mîchte, um im anschlieûenden Aufruf die eigentlichen
Daten in 'size' und 'text' zu erhalten.

Die Komponenten der Struktur bedeuten

!begin_xlist [size]
 !item [row]   Hier wird (!I)vor(!i) dem Versenden der Struktur an das Userdef
       A_editor die gewÅnschte Zeilennummer eingetragen.

 !item [size]  Hier ist (!I)nach(!i) dem Versenden der Struktur an das Userdef
       A_editor die LÑnge des Textes eingetragen.

 !item [text]  Hier ist (!I)nach(!i) dem Versenden der Struktur an das Userdef
       A_editor ein Zeiger auf den Text eingetragen. (!I)Der Text sollte
       nur gelesen werden.(!i)
!end_xlist

!end_node


!begin_node EDITLIVE

!label EDITLIVEPtr
Das (!link [Editor] [Userdef-Editor])-Objekt wird aufgrund seiner KomplexitÑt ausschlieûlich mit
Nachrichten per (!link [Service] [Auo_editor])-Routine angesprochen. DafÅr werden
verschiedene Strukturen eingesetzt.

Zur unmittelbaren Reaktion auf énderungen kann dem Editor eine Live-
Routine zugeordnet werden. Hierzu dient die Struktur EDITLIVE:

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   void (*call)( void *obj, char *text );
   void *obj;
} EDITLIVE;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
EDITLIVE = RECORD
      call  : PROCEDURE( obj: Pointer; text: Pointer );
      obj   : Pointer;
END;

EDITLIVEPtr = ^EDITLIVE;
!end_sourcecode

Die Komponenten der Struktur bedeuten

 call  Zeiger auf die Live-Routine

 obj   Zeiger auf Parameter, die der Live-ROutine beim Aufruf
       mitgegeben werden.

!end_node


!begin_node EDITSUBS

!label EDITSUBSPtr
Das (!link [Editor] [Userdef-Editor])-Object wird aufgrund seiner KomplexitÑt ausschlieûlich mit
Nachrichten per (!link [Service] [Auo_editor])-Routine angesprochen. DafÅr werden
verschiedene Strukturen eingesetzt.

Um zwischen zwei Positionen eine gewisse Anzahl von Textzeilen
einzufÅgen, ist folgende Struktur vorgesehen:

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   long row1;
   long col1;
   long row2;
   long col2;
   long nrow;
   char **newtext;
} EDITSUBS;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
EDITSUBS = RECORD
      row1:  LongInt;
      col1:  LongInt;
      row2:  LongInt;
      col2:  LongInt;
      nrow:  LongInt;
      newtext:  Pointer;
END;

EDITSUBSPtr = ^EDITSUBS;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!end_node


!begin_node env

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Environment der Applikation in Environment-Strings

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char **env;

 !item [Pascal:]            In Pure-Pascal hat diese Variable keine Bedeutung.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable env enthÑlt das Environment in Form der Environment-
Strings.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk, apppara, argc, argv
!end_enumerate

!end_node


!begin_node ev_bmask

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Bitvektor der zu beachtenden Maustasten

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_bmask;

 !item [Pascal:]            ev_bmask: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_bmask dient der Konfiguration der Event-Hauptschleife
und enthÑlt einen Bitvektor, der die zu betrachtenden Maustasten mit
einer 1 maskiert. Dabei entspricht Bit 0 der linken Maustaste, Bit 1
der rechten Maustaste.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife

  !item Ablk, AblkPtr, ACSblk, ev_bstate, ev_mbclicks, ev_mbreturn, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_bstate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Butvektor mit Status der zu betrachtenden
                    Maustasten

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_bstate;

 !item [Pascal:]            ev_bstate: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_bstate dient der Konfiguration der Event-Hauptschleife
und enthÑlt einen Bitvektor wie ev_bmask, der fÅr jede Maustaste den
Status festlegt, der ein Ereignis auslîst. Hierbei bedeutet 1 eine
gedrÅckte, 0 eine nicht gedrÅckte Maustaste, Bit 0 entspricht der
linken, Bit 1 der rechten Maustaste.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_mbclicks, ev_mbreturn, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mbclicks

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der Klicks, die beachtet werden sollen.

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mbclicks;

 !item [Pascal:]            ev_mbclicks: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mbclicks dient der Konfiguration der Event-
Hauptschleife und enthÑlt die Anzahl der nîtigen Clicks, um ein
Ereignis auszulîsen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife

  !item Ablk, AblkPtr, ACSblk, ev_bstate, ev_bmask, ev_mbreturn, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mbreturn

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der aufgetretenen Maus-Klicks

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mbreturn;

 !item [Pascal:]            ev_mbreturn: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mbreturn wird in der Event-Hauptschleife verwendet und
enthÑlt die Anzahl der aufgetretenen Mausklicks.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_bstate, ev_mbclicks, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mkdead

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Freischalten von Dead-Keys

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char ev_mkdead[10];

 !item [Pascal:]            ev_mkdead: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mkdead

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife, Dead-Key-Handling

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ev_mkreturn

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NKCC-Tastencode der gedrÅckten Taste

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mkreturn;

 !item [Pascal:]            ev_mkreturn: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mkreturn wird in der Event-Hauptschleife verwendet und
enthÑlt den NKCC-Tastencode der gedrÅckten Taste.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_bstate, ev_mbclicks, ev_mbreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mmobutton

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zustand der Maus-Tasten bem Auftreten eines
                    Ereignisses

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mmobutton;

 !item [Pascal:]            ev_mmobutton: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mmobutton wird in der Event-Hauptschleife verwendet
und enthÑlt den Zustand der Mausknîpfe beim Auftreten des Events.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Variablen der Event-Schleife

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_bstate, ev_mbclicks, ev_mbreturn, ev_mkreturn
!end_enumerate

!end_node


!begin_node ev_mmokstate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zustand der Sonder-Tasten bem Auftreten eines
                    Ereignisses

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mmokstate;

 !item [Pascal:]            ev_mmokstate: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mmokstate enthÑlt den aktuellen Tastaturstatus beim
AuswÑhlen des Objektes.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ev_mmox

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Aktuelle X-Koordinate der Maus bei einem Ereignis

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mmox;

 !item [Pascal:]            ev_mmox: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mmox enthÑlt die aktuelle X-Koordinaten der Maus zum
Zeitpunkt des AnwÑhlens beim Klicken bzw. des Loslassen beim Ziehen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk, ev_mmoy
!end_enumerate

!end_node


!begin_node ev_mmoy

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Aktuelle Y-Koordinate der Maus bei einem Ereignis

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_mmoy;

 !item [Pascal:]            ev_mmoy: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mmoy enthÑlt die aktuelle Y-Koordinaten der Maus zum
Zeitpunkt des AnwÑhlens beim Klicken bzw. des Loslassen beim Ziehen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk, ev_mmox
!end_enumerate

!end_node


!begin_node ev_mtcount

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Wartezeit der Hauptschleife

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 long ev_mtcount;

 !item [Pascal:]            ev_mtcount: LongInt;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_mtcount enthÑlt die Wartezeit der Hauptscheife in
Millisekunden. Die Zeit ist mit 500 ms vordefiniert.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ev_object

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeiger auf aktuellen Objektbaum

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 OBJECT *ev_object;

 !item [Pascal:]            ev_object: ACSTreePtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_object enthÑlt den Zeiger auf den aktuellen
Objektbaum. Das kann der Dialog, die MenÅleiste, die Toolbar oder ein
Popup-MenÅ sein.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk, ev_obnr, ev_window
!end_enumerate

!end_node


!begin_node ev_obnr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Objektnummer im Objektbaum ev_object

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ev_obnr;

 !item [Pascal:]            ev_obnr: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_obnr enthÑlt die aktuelle Objektnummer des Objektes im
durch ev_object angegebenen Objektbaum.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk, ev_object, ev_window
!end_enumerate

!end_node


!begin_node ev_window

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeiger auf aktuelles Fenster

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 Awindow *ev_window;

 !item [Pascal:]            ev_window: AwindowPtr;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ev_window enthÑlt den Zeiger auf das aktuelle Fenster.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, (!link [Click- & Drag-Variablen] [Variablen fÅr die Drag- & Click-Routinen])

  !item Ablk, AblkPtr, ACSblk, ev_object, ev_obnr
!end_enumerate

!end_node


!begin_node fheight

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Hîhe des normalen Zeichensatzes fÅr die (!I)ACSpro(!i)-
                    Userdefs

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 fheight;

 !item [Pascal:]            fheight: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

öber die Variable fheight kann die Hîhe des normalen Fonts der
(!I)ACSpro(!i)-eigenen Userdefs eingestellt werden. Das nachladbare Modul
'SYSFONT' kann diesen Wert nachtrÑglich modifizieren.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, fontid, fontsid, fsheight
!end_enumerate

!end_node


!begin_node fontid

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  ID des normalen Zeichensatzes fÅr die (!I)ACSpro(!i)-
                    Userdefs

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 fontid;

 !item [Pascal:]            fontid: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

öber die Variable fontid kann der (normale) Font der (!I)ACSpro(!i)-eigenen
Userdefs eingestellt werden. Das nachladbare Modul 'SYSFONT' kann
diesen Wert nachtrÑglich modifizieren.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, fheight, fontsid, fsheight
!end_enumerate

!end_node


!begin_node fonts

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der geladenen ZeichensÑtze

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 fonts;

 !item [Pascal:]            fonts: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable fonts gibt die Anzahl der mittels vst_load_fonts
geladenen Fonts an.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node fontsid

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  ID des kleinen Zeichensatzes fÅr die (!I)ACSpro(!i)-
                    Userdefs

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 fontsid;

 !item [Pascal:]            fontsid: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

öber die Variable fontsid kann der kleine Font der (!I)ACSpro(!i)-eigenen
Userdefs eingestellt werden. Das nachladbare Modul 'SYSFONT' kann
diesen Wert nachtrÑglich modifizieren.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, fheight, fontid, fsheight
!end_enumerate

!end_node


!begin_node fsheight

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Hîhe des kleinen Zeichensatzes fÅr die (!I)ACSpro(!i)-
                    Userdefs

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 fsheight;

 !item [Pascal:]            fsheight: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

öber die Variable fsheight kann die Hîhe des kleinen Fonts der
(!I)ACSpro(!i)-eigenen Userdefs eingestellt werden. Das nachladbare Modul
'SYSFONT' kann diesen Wert nachtrÑglich modifizieren.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, fheight, fontid, fontsid
!end_enumerate

!end_node


!begin_node gl_apid

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Die Applikations-ID fÅr die AES

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_apid;

 !item [Pascal:]            gl_apid: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

EnthÑlt die AES-Applikation-ID. FÅr Applikationen ist sie unter
SingleTOS gewîhnlich 1, fÅr Accessories oder unter Multitasking-
Systemen normalerweise grîûer 1.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node gl_hattr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zellenhîhe des grîûten Zeichens im
                    Systemzeichensatz

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_hattr;

 !item [Pascal:]            gl_hattr: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable gl_hattr enthÑlt die Zellenhîhe (in Pixeln) des grîûten
Zeichens im Systemzeichensatz.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, gl_wattr
!end_enumerate

!end_node


!begin_node gl_hbox

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zellenbrite des grîûten Zeichens im Normalen
                    Zeichensatz (fontid)

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_hbox;

 !item [Pascal:]            gl_hbox: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable gl_hbox enthÑlt die Zellenhîhe des grîûten Zeichens im
verwendeten Zeichensatzes (durch fontid angegeben).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, gl_wbox, gl_wchar, gl_hchar
!end_enumerate

!end_node


!begin_node gl_hchar

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenhîhe des grîûten Zeichens im normalen
                    Zeichensatz (fontid)

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_hchar;

 !item [Pascal:]            gl_hchar: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable gl_hchar enthÑlt die Zeichenhîhe des grîûten Zeichens im
verwendeten Zeichensatz (durch fontid angegeben).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, gl_wbox, gl_hbox, gl_wchar
!end_enumerate

!end_node


!begin_node gl_wattr

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zellenbreite des grîûten Zeichens im
                    Systemzeichensatz

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_wattr;

 !item [Pascal:]            gl_wattr: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable gl_wattr enthÑlt die Zellenbreite (in Pixeln) des grîûten
Zeichens im Systemzeichensatz.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, gl_hattr
!end_enumerate

!end_node


!begin_node gl_wbox

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zellenbreite des grîûten Zeichens im normalen
                    Zeichensatz (fontid)

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_wbox;

 !item [Pascal:]            gl_wbox: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable gl_wbox enthÑlt die Zellenbreite des grîûten Zeichens im
verwendeten Zeichensatzes (durch fontid angegeben).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, gl_hbox, gl_wchar, gl_hchar
!end_enumerate

!end_node


!begin_node gl_wchar

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Zeichenbreite des grîûten Zeichens im normalen
                    Zeichensatz (fontid)

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 gl_wchar;

 !item [Pascal:]            gl_wchar: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable gl_wchar enthÑlt die Zeichenbreite des grîûten Zeichens
im verwendeten Zeichensatz (durch fontid angegeben).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, gl_wbox, gl_hbox, gl_hchar
!end_enumerate

!end_node


!begin_node intersect

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Vertikale, punktierte Linie zeichnen

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 intersect( Axywh *xywh1, const Axywh *xywh2);

 !item [Pascal:]            Function intersect(
                                   xywh1, xywh2: AxywhPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion intersect ermittelt den gemeinsame Bereich zweier
Rechtecke. Das Ergebnis steht in xywh1. Wenn der Schnitt leer sein
sollte, so werden xywh1.w (!I)und(!i) xywh1.h auf 0 gesetzt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen
!end_enumerate

!end_node


!begin_node keyAltCtrlSwitch

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Environment der Applikation in Environment-Strings

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 keyAltCtrlSwitch;

 !item [Pascal:]            keyAltCtrlSwitch: int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

öber die Variable keyAltCtrlSwitch wird gesteuert, wie TastendrÅcke
bei Fenstern ohne Edit-Objekt verarbeitet werden.

Wenn kein editierbares Objekt gefunden wird, so kann bei TastendrÅcken
ohne Ctrl oder Alt versucht werden, ein TastenkÅrzel mit Ctrl oder Alt
zu verwenden. Folgende Varianten sind mîglich:

!begin_itemize !compressed
   !item Suche im Work-Objekt getrennt einschaltbar

   !item Suche in der Toolbar getrennt einschaltbar

   !item Suche nach Alt+Key getrennt einschaltbar

   !item Suche nach Ctrl+Key getrennt einschaltbar

   !item Suche nach Ctrl+Alt+Key getrennt einschaltbar

   !item Zuerst im Work-Objekt suchen, dann in der Toolbar

   !item Zuerst in der Toolbar suchen, dann im Work-Objekt
!end_itemize

HierfÅr sind einige Konstanten definiert:

!begin_xlist [KEY_AC_CTRL_FIRST_WORK]
 !item [KEY_AC_NONE]            bisheriges Verhalten (keine Variante
                        probieren)

 !item [KEY_AC_ALT_WORK]        Alt+Key im Work-Objekt versuchen (defaultmÑûig
                        aktiviert)

 !item [KEY_AC_CTRL_WORK]       Ctrl+Key im Work-Objekt versuchen
                        (defaultmÑûig nicht aktiviert)

 !item [KEY_AC_CTRL_FIRST_WORK] FÅr das Work-Objekt erst Ctrl+Key, dann
                        Alt+Key versuchen (Standard: erst Alt, dann
                        Ctrl)

                        KEY_AC_ALT_CTRL_WORK] Ctrl+Alt+Key im Work-
                        Objekt versuchen (defaultmÑûig nicht
                        aktiviert)

 !item [KEY_AC_ALT_TOOL]        Alt+Key in der Toolbar versuchen (defaultmÑûig
                        nicht aktiviert)

 !item [KEY_AC_CTRL_TOOL]       Ctrl+Key in der Toolbar versuchen
                        (defaultmÑûig nicht aktiviert)

 !item [KEY_AC_CTRL_FIRST_TOOL] FÅr die Toolbar erst Ctrl+Key, dann Alt+Key
                        versuchen (Standard: erst Alt, dann Ctrl)

                        KEY_AC_ALT_CTRL_TOOL] Ctrl+Alt+Key in der
                        Toolbar versuchen (defaultmÑûig nicht
                        aktiviert)

 !item [KEY_AC_TOOL_FIRST]      Zuerst in der Toolbar, dann im Work-Objekt
                        nachsehen (Standard: erst Work-Objekt, dann
                        Toolbar)
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node menu_id

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  MenÅindex als Accessory oder unter MultiTOS/N.AES

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 menu_id;

 !item [Pascal:]            menu_id: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable menu_id enthÑlt den MenÅindex im DESK-MenÅ.

Als Accessory oder einem geeigentem Multitasking-TOS wird ein Eintrag
im 'DESK`-MenÅ vorgenommen - dessen Nummer wird hier eingetragen und
steht z.B. im XACC-Protokoll den Partnern zur VerfÅgung. Eine -1
signalisiert keinen gÅltigen MenÅeintrag.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node mfsel_count

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Maximale Anzahl der Dateien bei der nÑchsten
                    Auswahl der Multi-Dati-Auswahl

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 mfsel_count;

 !item [Pascal:]            mfsel_count: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable mfsel_count enthÑlt die maximale Anzahl der Dateien fÅr
den nÑchsten A_first_fsel-Aufruf (MultiDateiAuswahl).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node multitask

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Flag, ob eine Multitaskingumgebung aktiv ist

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 multitask;

 !item [Pascal:]            multitask: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable multitask zeigt an, ob das Programm in einer
Multitaskingumgebung wie zum Beispiel MultiGEM, MagiC (incl. MaciCPC
und (!link [MagiCMac] [Mag!X])), MultiTOS oder N.AES lÑuft. Dazu wird geprÅft ob die AES
in dem Global-Array etwas anderes als einen Prozeû zulassen. Das
Rootfenster wird unter einer Multitaskingumgebung in ein GEM-Fenster
gelegt.

Wenn dies nicht gewÅnscht ist, kann das Flag in ACSinit0
zurÅckgenommen werden (und in ACSinit wieder restauriert werden).

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ncolors

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der Farben

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 ncolors;

 !item [Pascal:]            ncolors: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable ncolors enthÑlt die Anzahl der Farben.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, nplanes
!end_enumerate

!end_node


!begin_node nkc_cmp

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NKCC-Tastencodes vergleichen

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_cmp( int16 refkey, int16 kcode );

 !item [Pascal:]            Function nkc_cmp(
                                   refkey, kcode: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_cmp vergleicht zwei NKCC-Tastencodes miteinander. Sie
ist dem puren Vergleich dehalb vorzuziehen, da in dem Code
mîglicherweise redundante Bits gesetzt sind. Es werden bestimmte
Regeln verwendet, die der erhîhten FlexibilitÑt des Vergleichs dienen.
Die Routine erhÑlt einen Referenzcode 'refkey' und den zu prÅfenden
Code 'kcode'. Im Referenzcode werden folgende Bits besonders
behandelt:

!begin_xlist [NKF_IGNUM]
 !item [NKF_IGNUM]  Beim gesetzten Bit spielt das ALT_NUM-Flag im Code keine
            Rolle

 !item [NKF_CAPS]   Gesetzt bedeutet, daû eine Groû-/Klein-schreibung bei
            ASCII-Codes keine Rolle spielt

 !item [NKF_SHIFT]  Gesetzt bedeutet, daû die auslîsende SHIFT-Taste keine
            Rolle spielt.
!end_xlist

ZurÅckgeliefert wird TRUE, wenn der Code Åbereinstimmt, sonst FALSE.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_kstate

  !item nkc_n2tos, nkc_tos2n
!end_enumerate

!end_node


!begin_node nkc_gem2n

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  GEM-Tastencodes in NKCC-Tastencodes wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_gem2n( int16 gemkey );

 !item [Pascal:]            Function nkc_gem2n( gemkey: Integer ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_gem2n rechnet GEM-Tastencodes in NKCC-Tastencodes um.

(!B)Hinweis:(!b) Diese Routine ist aufgrund der EinschrÑnkungen des GEM-
Tastencodes nicht so mÑchtig wie nkc_tos2n und sollte daher mîglichst
nicht verwendet werden!

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n
     
  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_gemks2n

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  GEM-Tastencodes in NKCC-Tastencodes wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_gemks2n( int16 kstate, int16 gemkey );

 !item [Pascal:]            Function nkc_gemks2n( kstate, gemkey: Integer ) :
                    Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_gemks2n rechnet GEM-Tastencodes mit zugehîrigem
Sodnertastenstatus in NKCC-Tastencodes um.

(!B)Hinweis:(!b) Diese Routine berÅcksichtigt den Sondertastenstatus und ist
daher - im Gegensatz zu nkc_gem2n - Ñquivalent zur Routine nkc_tos2n.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_kstate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Status der SOndertasten ermitteln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_kstate( void );

 !item [Pascal:]            Function nkc_kstate : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_kstate ermittelt sehr schnell den aktuellen Status
der Sondertasten CONTROL, SHIFT, ALTERNATE, CAPSLOCK.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp
!end_enumerate

!end_node


!begin_node nkc_n2gem

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NKCC-Tastencode in GEM-Tastencode wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_n2gem( int16 nkcode );

 !item [Pascal:]            Function nkc_n2gem( nkcode: Integer ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_n2gem rechnet NKCC-Tastencodes in GEM-Tastencodes um,
falls letzterer einmal unbedingt benîtigt werden sollte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_n2gemks

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NKCC-Tastencode in GEM-Tastencode und Tastatur-
                    Status wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 void nkc_n2gemks( int16 norm, int16 *kstate,
                            int16 *gemkey )

 !item [Pascal:]            Procedure nkc_n2gemks( nkcode: int16;
                                 Var kstate, gemkey: int16 );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_n2gemks rechnet NKCC-Tastencodes in GEM-Tastencodes
und den Tastatur-Status um, falls diese Daten einmal unbedingt
benîtigt werden sollten.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_n2kstate

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NKCC-Tastencode in GEM-Tastencode und Tastatur-
                    Status wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_n2kstate( int16 nkcode );

 !item [Pascal:]            Function nkc_n2kstate( nkcode: int16 ) : int16;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_n2kstate bestimmt anhand des NKCC-Tastencodes den
Tastatur-Status, falls dieser doch einmal unbedingt benîtigt werden
sollte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_n2tos

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  NKCC-Tastencode in TOS-Tastencode wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 long nkc_n2tos( int16 nkcode );

 !item [Pascal:]            Function nkc_n2tos( nkcode: Integer ) : LongInt;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_n2tos rechnet NKCC-Tastencodes in TOS-Tastencodes um,
falls letzterer einmal unbedingt benîtigt werden sollte.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gemks, nkc_n2gem, nkc_n2kstate, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_tos2n

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  TOS-Tastencode in NKCC-Tastencode wandeln

 !item [Kategorie:]         NKCC-Funktionen, NKCC-Tastencodes

 !item [C:]                 int16 nkc_tos2n( long toskey );

 !item [Pascal:]            Function nkc_tos2n( toskey: LongInt ) : Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion nkc_tos2n rechnet TOS-Tastencodes in NKCC-Tastencodes um.
Da diese Konversion bereits in der Event-Schleife in (!I)ACSpro(!i)
stattfindet, dÅrfte diese Funktion recht selten verwendet werden.

Die Funktion kann in eigenen Programmen eingesetzt werden, wenn Sie
Standard-TOS-Tastencodes in (!I)ACSpro(!i) einspielen wollen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item NKCC-Funktionen

  !item NKCC-Tastencodes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gemks, nkc_n2gem, nkc_n2kstate, nkc_n2tos

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nplanes

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Anzahl der Farben

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 nplanes;

 !item [Pascal:]            nplanes: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable nplanes enthÑlt die Anzahl der Farbenebenen.

(!B)Hinweis:(!b) Bei mehr als 256 Farben werden keine Farbebenen mehr
verwendet. Hier hat nplanes trotzdem den Wert 8.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, ncolors
!end_enumerate

!end_node


!begin_node OLGA_Infos

!label OLGA_InfoPtr
Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   Awindow *window;
   int16 id;
   char *datei;
   int16 info_id;
   char *info_datei;
   int16 olga_flags;
} OLGA_Infos;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
OLGA_Infos  = RECORD
                 window: AwindowPtr;
                 id: Integer;
                 datei: Pointer;
                 info_id: Integer;
                 info_datei: Pointer;
                 olga_flags: Integer;
              END;

OLGA_InfosPtr = ^OLGA_Infos;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!end_node


!begin_node phys_handle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Physikalische VDI-Workstation der AES

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 phys_handle;

 !item [Pascal:]            phys_handle: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable phys_handle enthÑlt die Nummer der physikalische
Workstation, die die AES benutzen.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node PLOTTERDATA

!label PLOTTERDATAPtr
Wenn das PLOTTER-Fenster erzeugt wird, kann im freien Parameter ein
Zeiger auf folgende Struktur Åbergeben werden, die die initialen
Ausmaûe des Fensters enthÑlt.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   int16 x;
   int16 y;
   int16 w;
   int16 h;
} PLOTTERDATA;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
PLOTTERDATA = RECORD
      x: Integer;
      y: Integer;
      w: Integer;
      h: Integer;
END;

PLOTTERDATAPtr = ^PLOTTERDATA;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!end_node


!begin_node PROTOCOLDATA

!label PROTOCOLDATAPtr
Wenn das PROTOCOL-Fenster erzeugt wird, kann im freien Parameter ein
Zeiger auf folgende Struktur Åbergeben werden, mit das Fenster und die
Ausgaben vorkonfiguriert werden:

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   int16 fontid;
   int16 height;
   int16 col;
   int16 row;
   int16 tabsize;
   int16 wrap;
   int16 x;
   int16 y;
} PROTOCOLDATA;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
PROTOCOLDATA = RECORD
      fontid:  Integer;
      height:  Integer;
      col:     Integer;
      row:     Integer;
      tabsize: Integer;
      wrap:    Integer;
      x:       Integer;
      y:       Integer;
END;

PROTOCOLDATAPtr = ^PROTOCOLDATA;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!end_node


!begin_node PUR_DESK

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Das Root-Fenster PUR_DESK

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 Awindow PUR_DESK;

 !item [Pascal:]            In Pure-Pascal ist die Struktur PUR_DESK
                    (!link [nicht direkt zugÑnglich] [ImpCVars]). Sie muû durch die
                    Funktion get_pur_desk erfragt werden.

!label get_pur_desk
                    Function get_pur_desk : Awindow;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable PUR_DESK stellt die Fenster-Struktur des normalerweise
verwendeten Root-Fensters dar.

Die MenÅleiste des PUR_DESK kann in der Routine ACSInit0 ausgetauscht
werden:

!begin_xlist [Pascal:]
 !item [C:]       PUR_DESK.menu = &MyMenu;

 !item [Pascal:]  get_pur_desk^.menu := @MyMenu;
!end_xlist

Die im Original-MenÅbaum befindlichen Funktionen kînnen genutzt
werden. Diese sind

!begin_xlist [Datei/Information]
 !item [Datei/Neu]          Apd_new

 !item [Datei/ôffnen]       Apd_open

 !item [Datei/Information]  Apd_info

 !item [Datei/Module]       Apd_module

 !item [Datei/Beenden]      Apd_quit

 !item [Fenster/Schlieûen]  Apd_close

 !item [Fenster/Entfernen]  Apd_delete

 !item [Fenster/Wechseln]   Apd_list
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Der "pure" Desktop

  !item DESKTOP
!end_enumerate

!end_node


!begin_node SC_CHANGED

Damit der Datenaustausch Åber das Klemmbrett automatisch von allen
Applikationen erkannt wird, versenden neuere Applikationen diese
Nachricht.

Die Routinen Ascrp_put und Ascrp_clear versenden im Erfolgsfall an
andere Applikationen diese AES-Nachricht, damit diese von der énderung
informiert werden.

Andererseits wird beim Empfang von SC_CHANGED allen ACS-Fenstern die
vordefinierte Nachricht AS_SCRAP_UPDATE zugeschickt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
   !item Vordefinierte Fenster-Nachrichten

   !item AS_SCRAP_EXPORT, AS_SCRAP_IMPORT, AS_SCRAP_UPDATE
!end_enumerate

!end_node


!begin_node screenMFDB

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  MFDB fÅr den Bildschirm

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 MFDB screenMFDB;

 !item [Pascal:]            screenMFDB: MFDB;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Um Kopieroperation auf dem Bildschirm durchzufÅhren benîtigt man einen
speziellen MFDB (Memory Form Definition Block), eben die Variable
screenMFDB.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node scrp_path

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Pfad des Klemmbretts

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char *scrp_path

 !item [Pascal:]            scrp_path: Pointer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable scrp_path enthÑlt den Pfad, der fÅr das Klemmbrett
eingesetzt wird. Die (!link [Routinen fÅr das Klemmbrett] [Klemmbrett-Funktionen]) nutzen diesen Pfad
unmittelbar.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, AES-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk, Ascrp_clear, Ascrp_get, Ascrp_put
!end_enumerate

!end_node


!begin_node separator

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Worttrenner-Zeichen

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 char separator[256];

 !item [Pascal:]            separator: packed array [1..256] of char;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable separator enthÑlt alle Zeichen, die als Worttrenner
interpretiert werden.

Um Worte voneinander zu trennen, werden hier die Worttrenner
aufgezÑhlt. Wenn vom Betriebssystem schon eine Environmentvaraible mit
dem Namen FS oder IFS existiert, wird deren Inhalt herangezogen, um
dieses Feld zu fÅllen, sonst wird es mit folgendem gefÅllt:

!begin_preformatted
     =+-*/()!&|[]{}<>,.;:›$%?`'^#~@\"
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ sowie Tabulator und Leerzeichen
!end_preformatted

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, Sonstige Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node SH_WDRAW

Der installierten System-Shell wird diese Nachricht zugesand, wenn bei
einer Klemmbrettroutine der Inhalt eines Laufwerks verÑndert wurde.
Diese kann dann die Anzeige des Laufwerkes auffrischen.

!end_node


!begin_node SLLIVE

!label SLLIVEPtr
Dem (!link [Slider] [Userdef-Slider])-Objekt kann per (!link [Service] [Auo_slider])-Routine eine sog. Live-Routine
zugeordnet werden, die von (!I)ACSpro(!i) immer dann automatisch aufgerufen
wird, wenn sich die Position des Schiebers Ñndert. Der Programmierer
kann damit sofort auf die geschobene Position des Anwenders reagieren
und Bereiche, Werte oder sonstige Berechnungen durchfÅhren.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct
{
   char *(*call)(void* obj, long pos);
   void *obj;
} SLLIVE;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
SLLIVE  = RECORD
      call: Function( obj: Pointer; pos: LongInt ) : Pointer;
      obj: Pointer;
END;

SLLIVEPtr = ^SLLIVE;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!begin_xlist [call]
 !item [call]  Zeiger auf die Live-Routine

 !item [obj]   Parameter, der der Live-Routine mitgegeben
       wird (Sinnvollerweise wird hier ein Verweis auf das Objekt
       eingetragen, damit die Live-Routine darauf zugreifen kann.)
!end_xlist

!end_node


!begin_node start_acs

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  (!I)ACSpro(!i) unter Pure-Pascal starten

 !item [Kategorie:]         (!link [Variablen] [Die Variablen]), Funktions-Zeiger

 !item [C:]                 Diese Funktion ist fÅr C nicht nîtig und daher
                    auch nicht vorhanden.

 !item [Pascal:]            Procedure start_acs( ini: Aretint;
                                 descr: AdescrPtr );

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Routine wird fÅr Pure-Pascal benîtigt und startet (!I)ACSpro(!i). Es muss
die Initialisierungs-Routine 'ini' Åbergeben werden, die die Aufgaben
der Funktion ACSinit Åbernimmt. Auûerdem wird die Struktur ACSdescr
Åbergeben, die das globale Verhalten bestimmt.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen

  !item Funktions-Zeiger

  !item Ablk, ACSblk, ACSinit
!end_enumerate

!end_node


!begin_node ULinList

!label ULinListPtr
Die Struktur ULinList stellt eine leistungsfÑhige generisch
programmierte, unsortierte doppelt verkettete, lineare Liste als
Objekt zur VerfÅgung.

Die Definition fÅr Pure-C lautet:
!begin_sourcecode
typedef struct _ULinList
{
   void *ListData;
   void (*freeElem)( void *elem );
   void (*clear)( ULinList *liste );
   int16 (*append)( ULinList *liste, void *new_data );
   int16 (*insert)( ULinList *liste, void *new_data,
         int16 before_obj );
   void *(*delete)( ULinList *liste, int16 data_nr );
   long (*deleteFor)( ULinList *liste, void *para,
         int16 (*to_delete)(void *para, void *elem) );
   void *(*search)( ULinList *liste, long nr );
   void *(*searchFor)( ULinList *liste, void *para,
         int16 (*found)(void *para,void *elem) );
   void *(*first)( ULinList *liste );
   void *(*last)( ULinList *liste );
   void *(*akt)( ULinList *liste );
   long (*aktNr)( ULinList *liste );
   void *(*skip)( ULinList *liste, int16 vorwaerts,
         long amount );
   long (*count)( ULinList *liste);
   long (*countFor)( ULinList *liste, void *para,
         int16 (*count)(void *para, void *elem) );
   void (*doFor)( ULinList *liste, void *para,
         int16 (*to_work)(void *para, void *elem),
         void (*work)(void *para, void *elem) );
} ULinList;
!end_sourcecode

Die Definition fÅr Pure-Pascal lautet:
!begin_sourcecode
ULinList = RECORD
      ListData    : Pointer;
      freeElem    : Procedure( elem: Pointer );
      clear       : Procedure( liste: ULinListPtr );
      append      : Function( liste: ULinListPtr,
                        new_data: Pointer ) : Integer;
      insert      : Function( liste: ULinListPtr,
                        new_data: Pointer,
                        before_obj: LongInteger ) : Integer;
      delete      : Function( liste: ULinListPtr,
                        data_nr: Integer ) : Pointer;
      deleteFor   : Function( liste: ULinListPtr,
                        para : Pointer,
                        int16 (*to_delete)(void *para,
                           void *elem) ) : Integer;
      search      : Function( liste: ULinListPtr,
                        nr: LongInterger ) : Pointer;
      searchFor   : Function( ULinList *liste, void *para,
                        int16 (*found)(void *para,
                           void *elem) ) : Pointer;
      first       : Function( liste: ULinListPtr ) : Pointer;
      last        : Function( liste: ULinListPtr ) : Pointer;
      akt         : Function( liste: ULinListPtr ) : Pointer;
      aktNr       : Function( liste: ULinListPtr )
                        : LongInteger;
      skip        : Function( liste: ULinListPtr,
                        vorwaerts: Integer,
                        amount: LongInteger ) : Pointer;
      count       : Function( liste: ULinListPtr )
                        : LongInteger;
      countFor    : Function( liste: ULinListPtr, para: Pointer,
                        Function count(para: Pointer,
                           elem: Pointer) : Integer )
                           : LongInteger;
      doFor       : Procedure( liste: ULinList, para: Pointer,
                        Function to_work(para: Pointer,
                           elem: Pointer) : Integer,
                        Procedure work(para: Pointer,
                           elem: Pointer) );
   END;

ULinListPtr = ^ULinList;
!end_sourcecode

Die Komponenten der Struktur bedeuten

!begin_xlist [deleteFor]
!label ULinList.ListData
 !item [ListData]   Der Zeiger auf die lineare Liste (soll nur ACS-intern
            verwendet werden!)

!label ULinList.freeElem
 !item [freeElem]   Zeiger auf Freigabe-Funktion, die beim Lîschen der Liste
            oder von einzelnen Elementen aufgerufen wird

            Damit kînnen z.B. Objekt-BÑume verwaltet werden, die mit
            Aob_create angelegt wurden, wenn nach dem Erzeugen der
            Liste mittels Alu_create als Freigabe-Funktion Aob_delete
            eingetragen wird (Vorsicht mit Warnungen, das Interface
            sieht typenlose Daten- Zeiger vor, Aob_delete erhÑlt aber
            einen typisierten Zeiger! In Pure-C kînnen diese Warnungen
            mit dem cast-Operator umgangen werden).

!label ULinList.clear
 !item [clear]      Die lineare Liste leeren, alle Daten freigeben

!label ULinList.append
 !item [append]     AnhÑngen neuer Daten an die Liste

!label ULinList.insert
 !item [insert]     EinfÅgen neuer Daten in die Liste

!label ULinList.delete
 !item [delete]     Daten aus der Liste herausnehmen und den Zeiger darauf
            zurÅckgeben

!label ULinList.deleteFor
 !item [deleteFor]  Alle Daten aus der Liste lîschen (freeElem wird
            aufgerufen!), die eine bestimmte Bedingung erfÅllen. Der
            Parameter para wird an den gleichnamigen Parameter der in
            to_delete Åbergebenen Funktion weitergereicht (z.B.
            öbergabe der Vergleichskriterien)

!label ULinList.search
 !item [search]     Die Daten Nummer nr holen

!label ULinList.searchFor
 !item [searchFor]  Daten suchen, die eine Bedingung erfÅllen. Der Parameter
            para wird an den gleichnamigen Parameter der in found
            Åbergebenen Funktion weitergereicht (z.B. öbergabe der
            Vergleichskriterien)

!label ULinList.first
 !item [first]      Das erste Element der Liste

!label ULinList.last
 !item [last]       Das letzte Element der Liste

!label ULinList.akt
 !item [akt]        Das aktuelle Element der Liste

!label ULinList.aktNr
 !item [aktNr]      Die Nummer des aktuellen Elementes der Liste

!label ULinList.skip
 !item [skip]       Das aktuelle Element vorwÑrts/rÅckwÑrts bewegen

!label ULinList.count
 !item [count]      Die Anzahl der verwalteten Daten

!label ULinList.countFor
 !item [countFor]   Die Anzahl der Daten ermitteln, die eine Bedingung
            erfÅllen. Der Parameter para wird an den gleichnamigen
            Parameter der in found Åbergebenen Funktion weitergereicht
            (z.B. öbergabe der Vergleichskriterien)

!label ULinList.doFor
 !item [doFor]      FÅr alle Daten, die eine Bedingung erfÅllen, eine Aktion
            ausfÅhren. Der Parameter para wird an den gleichnamigen
            Parameter der in to_work und work Åbergebenen Funktion
            weitergereicht (z.B. öbergabe der Vergleichskriterien)
!end_xlist

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Alu_create
!end_enumerate

!end_node


!begin_node uputs

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  String-Ausgabe in ein USERDEF

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 uputs( char *text, OBJECT *entry );

 !item [Pascal:]            Diese Funktion steht in Pascal leider nicht zur
                    VerfÅgung.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Der C-String 'text' wird auf dem Userdef 'entry' (A_editor)
ausgegeben. ZurÅckgegeben wird OK oder FAIL.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item uvprintf

  !item uprintf
!end_enumerate

!end_node


!begin_node uprintf

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ausgabe analog printf in ein USERDEF

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 uprintf( OBJECT *entry,
                             const char *format, ... );

 !item [Pascal:]            Diese Funktion steht in Pascal leider nicht zur
                    VerfÅgung.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Ausgabe erfolgt auf dem Userdef 'entry' (A_editor) FÅr den
Ergebnisstring nach der Formatierung stehen 1024 Bytes zur VerfÅgung

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item uvprintf

  !item uputs
!end_enumerate

!end_node


!begin_node uvprintf

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Ausgabe analog vprintf in ein USERDEF

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 int16 uvprintf( OBJECT *entry,
                             const char *format,
                             va_list arg_list );

 !item [Pascal:]            Diese Funktion steht in Pascal leider nicht zur
                    VerfÅgung.

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Ausgabe analog vprintf erfolgt auf dem Userdef 'entry' (A_editor)
FÅr den Ergebnisstring nach der Formatierung stehen 1024 Bytes zur
VerfÅgung

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item uputs

  !item uprintf
!end_enumerate

!end_node


!begin_node vdi_handle

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Virtuelle VDI-Workstation von (!I)ACSpro(!i)

 !item [Kategorie:]         (!link [Variablen] [Die Variablen])

 !item [C:]                 int16 vdi_handle;

 !item [Pascal:]            vdi_handle: Integer;

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Variable vdi_handle enthÑlt die Nummer der virtuellen Workstation,
die (!I)ACSpro(!i) fÅr Kopieroperationen und benutzerdefinierte Objekte
benutzt. Die Applikation kann sie mitverwenden.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Die Variablen, VDI-orientierte Variablen

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node xywh2array

!begin_blist [Kurzbeschreibung:]
 !item [Kurzbeschreibung:]  Axywh-Struktur in Punkte-Paar umrechnen

 !item [Kategorie:]         Sonstige Funktionen

 !item [C:]                 void xywh2array( int16 *to, const Axywh *from );

 !item [Pascal:]            Procedure xywh2array( to: Pointer; from: AxywhPtr);

 !item [Definition:]        in ACS.H bzw. ACS.PAS
!end_blist

Die Funktion xywh2array rechnet eine Axywh-Struktur in ein int16-Feld
mit zwei diagonalen Eckpunkten um.

(!I)Querverweise:(!i)

!begin_enumerate !compressed
  !item Sonstige Funktionen

  !item array2xywh
!end_enumerate

!end_node


!end_node
