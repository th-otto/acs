!begin_node Alphabetical Reference Index

Here is the alphabetical list of all the variables, structures and
functions that (!I)ACSpro(!i) provides. Furthermore, all important constants,
especially the window and object messages, have been included here.

!subtoc [all] !depth 1


!begin_node Aaction

 !begin_blist [Definition:]
 !item [Summary:]           Data type for Click- & (!link [Drag Routine] [Click Routine & Drag Routine])

 !item [Category:]          (!link [Structures] [The Structures])

 !item [C:]                 typedef void (*Aaction)(void);

 !item [Pascal:]       Aaction = Procedure;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This data type is used for calls to the click and drag routine.

No parameters are passed and no result is returned from the routine.

!end_node


!begin_node Ablk

!label AblkPtr
 !begin_blist [Pascal]
 !item [Summary:]           All global (!I)ACSpro(!i) variables

 !item [Category:]          (!link [Structures] [The Structures])

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Structure Ablk contains all global (!I)ACSpro(!i) variables, the pointer
ACSblk points to this structure and thus makes all variables
available.

 !begin_blist [Pascal]
 !item [C:]
!begin_sourcecode
typedef struct
{
   int16    gl_apid;
   int16    phys_handle;
   int16    gl_wattr;
   int16    gl_hattr;
   Axywh    desk;
   int16    vdi_handle;
   int16    gl_wbox;
   int16    gl_hbox;
   int16    gl_wchar;
   int16    gl_hchar;
   int16    ncolors;
   int16    nplanes;
   char     appname[128];
   char     apppath[128];
   char     apppara[128];
   char     appfrom[128];
   char     basename[20];
   long     ev_mtcount;
   int16    application;
   int16    multitask;
   int16    appexit;
   Adescr   *description;
   Asel     Aselect;
   Awindow  *ev_window;
   OBJECT   *ev_object;
   int16    ev_obnr;
   int16    ev_mmox, ev_mmoy;
   int16    ev_mmokstate;
   int16    dia_abort;
   MFDB     screenMFDB;
   int16    apterm;
   int16    *AESglobal;
   int16    fonts;
   int16    argc;
   char     **argv;
   char     **env;
   int16    fontid;
   int16    fheight;
   int16    fontsid;
   int16    fsheight;
   void     (*ACSterm)( void );
   void     (*ACSaboutme)( void );
   void     (*ACSclose)( void );
   void     (*ACSmessage)( int16 *ev_mmgpbuf );
   void     (*ACSmproto)( int16 *ev_mmgpbuf );
   void     (*ACStimer)( void );
   int16    (*ACSinit0)( void );
   int16    dither;
   void     (*ACSkey)( int16 *kstate, int16 *key );
   void     (*ACSbutton)( int16 *button,
                  int16 *kreturn );
   void     (*ACSmouse)( void );
   void     (*ACSwikey)( int16 *kstate, int16 *key );
   int16    ev_bmask;
   int16    ev_bstate;
   int16    ev_mmobutton;
   int16    ev_mbreturn;
   int16    ev_mkreturn;
   int16    ev_mbclicks;
   void     (*DEBUG_MEM) (void* defective);
   char     cfg_path [128];
   char     scrp_path[128];
   void     (*ACSerror)( int16 mess, void *para );
   int16    menu_id;
   char     *dd_name;
   char     *alert_name;
   int16    mfsel_count;
   char     separator[256];
   char     *AppLongName;
   UConfig  *cfg;
   int16    (*GEMScript)( int16 anz, char **cmd,
                  A_GSAntwort *antwort );
} Ablk;
!end_sourcecode

 !item [Pascal:]
!begin_sourcecode
AblkPtr = ^Ablk;
Ablk = Record
   gl_apid:      Integer;
   phys_handle:  Integer;
   gl_wattr:     Integer;
   gl_hattr:     Integer;
   desk:         Axywh;
   vdi_handle:   Integer;
   gl_wbox:      Integer;
   gl_hbox:      Integer;
   gl_wchar:     Integer;
   gl_hchar:     Integer;
   ncolors:      Integer;
   nplanes:      Integer;
   appname:      packed array [1..128] of char;
   apppath:      packed array [1..128] of char;
   apppara:      packed array [1..128] of char;
   appfrom:      packed array [1..128] of char;
   basename:     packed array [1..20] of char;
   ev_mtcount:   LongInt;
   application:  Integer;
   multitask:    Integer;
   appexit:      Integer;
   description:  AdescrPtr;
   Aselect:      Asel;
   ev_window:    (!link [AwindowPtr] [Awindow]);
   ev_object:    ACSTreePtr;
   ev_obnr:      Integer;
   ev_mmox:      Integer;
   ev_mmoy:      Integer;
   ev_mmokstate: Integer;
   dia_abort:    Integer;
   screenMFDB:   MFDB;
   apterm:       Integer;
   AESglobal:    ^Integer;
   fonts:        Integer;
   argc:         Integer;
   argv:         Pointer;
   env:          Pointer;
   fontid:       Integer;
   fheight:      Integer;
   fontsid:      Integer;
   fsheight:     Integer;
   ACSterm:      Procedure;
   ACSaboutme:   Procedure;
   ACSclose:     Procedure;
   ACSmessage:   Procedure( Var ev_mgpbuff: ARRAY_8 );
   ACSmproto:    Procedure( Var ev_mgpbuff: ARRAY_8 );
   ACStimer:     Procedure;
   ACSinit0:     Function: Integer;
   dither:       Integer;
   ACSkey:       Procedure( Var kstate: Integer;
                       key: Integer );
   ACSbutton:    Procedure( Var button : Integer;
                       Var breturn : Integer );
   ACSmouse:     Procedure;
   ACSwikey:     Procedure (var kstate : Integer;
                       Var key : Integer );
   ev_bmask:     Integer;
   ev_bstate:    Integer;
   ev_mmobutton: Integer;
   ev_mbreturn:  Integer;
   ev_mkreturn:  Integer;
   ev_mmobutton: Integer;
   ev_mbreturn:  Integer;
   ev_mkreturn:  Integer;
   ev_mbclicks:  Integer;
   DEBUG_MEM:    Procedure( defective: Pointer );
   cfg_path:     packed array [1..128] of char;
   scrp_path:    packed array [1..128]of char;
   ACSerror:     Procedure( mess: Integer;
                       para: Pointer );
   menu_id:      Integer;
   dd_name:      Pointer;
   alert_name:   Pointer;
   mfsel_count:  Integer;
   separator:    packed array [1..256] of char;
   AppLongName:  Pointer;
   cfg:          UConfigPtr;
   GEMScript:    Function(
                       int16 anz, char **cmd,
                       A_GSAntwort *antwort
                    ) : Integer;
End;
!end_sourcecode
!end_blist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item ACSblk
!end_enumerate

!end_node


!begin_node Abp_create

 !begin_blist [Definition:]
 !item [Summary:]           Backplane generate

 !item [Category:]          Backplane support

 !item [C:]                 MFDB *Abp_create( int16 w, int16 h );

 !item [Pascal:]            Function Abp_create( w, h: Integer ) : MFDBPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Abp_create function creates a backplane with the width 'w' and
the height 'h' taking into account 'nplanes'. The content is filled
with 0. If a monochrome bitmap is desired, nplanes must be set to 1
for a short time around this call.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Backplane support

  !item Abp_delete
!end_enumerate

!end_node


!begin_node Abp_delete

 !begin_blist [Definition:]
 !item [Summary:]           Backplane release

 !item [Category:]          Backplane support

 !item [C:]                 void Abp_delete( MFDB *backplane );

 !item [Pascal:]            Procedure Abp_delete( backplane: MFDBPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Abp_delete function releases the backplane created using
Abp_create.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Backplane support

  !item Abp_create
!end_enumerate

!end_node


!begin_node Abp_end

 !begin_blist [Definition:]
 !item [Summary:]           Disable drawing on backplane

 !item [Category:]          Backplane support

 !item [C:]                 void Abp_end( void );

 !item [Pascal:]            Procedure Abp_end;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

After calling the Abp_end function, the AES and the VDI draw back
on the screen.

(!B)Note:(!b) The function should only be used if the offscreen
bitmaps e.g. from NVDI, are not available 
(i.e. for Ash_CallEdDI(0)<0x0100).

Internally LineA-Variables and the screen memory (per set screen)
are mangled - so dirty tricks!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Backplane support

  !item Abp_start
!end_enumerate

!end_node


!begin_node Abp_img2mfdb

 !begin_blist [Definition:]
 !item [Summary:]           Convert graphic from IMG format to MFDB

 !item [Category:]          Backplane support

 !item [C:]                 int16 Abp_img2mfdb( IMG_HEADER *org, MFDB **dest,
                                int16 do_trnsfm );

 !item [Pascal:]            Function Abp_img2mfdb( org: IMG_HEADERPTR;
                                   dest: Pointer; trnsfm: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Abp_img2mfdb function unpacks an image that is available and
loaded in IMG format, converts it into an MFDB, which can then be
used further. The image data must be exactly behind the IMG-HEADER
(as is the case with a file). A XIMG-HEADER is recognized and operated
correctly, but the evaluation of the colors must be carried out
yourself.

(!I)The data in 'dest' is only valid if OK has been returned.(!i)

Here 'org' is the common IMG-HEADER, in 'dest' a pointer to the
generated MFDB is returned. If 'do_trnsfm' is set to TRUE, the MFDB
is also transformed into the device-dependent format (for each
plane).


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Backplane support

  !item Abp_mfdb2img
!end_enumerate

!end_node


!begin_node Abp_mfdb2img

 !begin_blist [Definition:]
 !item [Summary:]           Convert graphic from MFDB format to IMG

 !item [Category:]          Backplane support

 !item [C:]                 int16 Abp_mfdb2img( MFDB* org, IMG_HEADER **dest,
                                long *img_len );

 !item [Pascal:]            Function Abp_mfdb2img (org: MFDBPTR;
                                   dest: Pointer; len: Longint
                                ): Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Abp_mfdb2img function converts an image as an MFDB into an IMG.
Only the image data is converted, if you want to create a XIMG-HEADER,
you have to create it yourself after the conversion. The compressed
image data is located directly behind the IMG-HEADER.

(!I)The data in 'dest' and 'len' are only valid if OK has been returned.(!i)

Here 'org' is the pointer to the MFDB, in 'dest' a pointer to the
target memory is returned. 'len' contains the length of the image
information (without IMG-HEADER!) - if 'dest' is passed NULL/NIL,
only this length is calculated.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Backplane support

  !item Abp_img2mfdb
!end_enumerate

!end_node


!begin_node Abp_start

 !begin_blist [Definition:]
 !item [Summary:]           Activate drawing on backplane

 !item [Category:]          Backplane support

 !item [C:]                 void Abp_start( MFDB *backplane );

 !item [Pascal:]            Procedure Abp_start( backplane: MFDBPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

After calling the Abp_start function, (!I)all(!i) AES and VDI outputs
are made on this backplane. The state up to the call of Abp_end is
very critical, since the error messages are also written to the
backplane!

(!B)Note:(!b) The function should only be used if the offscreen bitmaps
(e.g. from NVDI) are not available (i.e. for Ash_CallEdDI(0)<0x0100).
Internally LineA variables and the screen memory (per set screen) are
mangled - so dirty tricks!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Backplane support

  !item Abp_end
!end_enumerate

!end_node


!begin_node Acfg_clear

 !begin_blist [Definition:]
 !item [Summary:]           Reinitialize the UConfig structure

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 void Acfg_clear( UConfig *cfg, const UCfgInfo
                    *info );

 !item [Pascal:]            Procedure Acfg_clear( cfg: UConfigPtr;
                                   info: UCfgInfoPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_clear deletes all groups as well as the contained
cfg strings and the header comment lines, the UConfig management
structure is reinitialized. The data of the transferred info structure
are adopted. If the value NULL or NIL is passed for info, default
values are used.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_clearGroup
!end_enumerate

!end_node


!begin_node Acfg_clearAllGroups

 !begin_blist [Definition:]
 !item [Summary:]           Only delete the Cfg strings and the Cfg groups

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 void Acfg_clearAllGroups( UConfig *config );

 !item [Pascal:]            Procedure Acfg_clearAllGroups( config: UConfigPtr);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

In contrast to the Acfg_clear function, the Acfg_clearAllGroups
function only deletes the existing groups with their Cfg strings
and leaves all other data untouched.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_clear, Acfg_clearGroup
!end_enumerate

!end_node


!begin_node Acfg_clearGroup

 !begin_blist [Definition:]
 !item [Summary:]           Delete a Cfg group including Cfg strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 void Acfg_clearGroup( UConfig *config, char
                    *kategorie );

 !item [Pascal:]            Procedure Acfg_clearGroup( config: UConfigPtr;
                                 kategorie: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_clearGroup function deletes the transferred Cfg group
including the Cfg strings contained therein.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_clear, Acfg_clearAllGroups
!end_enumerate

!end_node


!begin_node Acfg_clearHeader

 !begin_blist [Definition:]
 !item [Summary:]           Delete the comment strings in the beginning

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 void Acfg_clearHeader( UConfig *config );

 !item [Pascal:]            Procedure Acfg_clearHeader( config: UConfigPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_clearHeader function deletes the comment strings at the
beginning of the cfg file.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_clearValue

 !begin_blist [Definition:]
 !item [Summary:]           Delete a single Cfg string

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_clearValue( UConfig *config,
                             const char *kategorie, const char *name,
                             char *value );

 !item [Pascal:]            Function Acfg_clearValue( config: UConfigPtr;
                                   kategorie, name, value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_clearValue function deletes the passed parameter from the
given group. The value of the parameter is entered in value before
deletion. If successful, the pointer to the parameter value is
returned, otherwise an empty string.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getValue, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_copyInfo

 !begin_blist [Definition:]
 !item [Summary:]           Copy data from an info structure

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 UCfgInfo *Acfg_copyInfo( UcfgInfo Üdest,
                                 const UCfgInfo *source );

 !item [Pascal:]            Function Acfg_copyInfo(
                                   dest, source: UCfgInfoPtr
                                ) : UCfgInfoPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_copyInfo function copies all data from one Cfg info structure
to another. The strings that may exist in the Cfg info structure 'dest'
are released using Ast_delete before the new strings are created using
Ast_create.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_create

 !begin_blist [Definition:]
 !item [Summary:]           Generate a management structure of Cfg strings
 
 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 UConfig *Acfg_create( const UCfgInfo *info,
                                int16 load );

 !item [Pascal:]            Function Acfg_create(
                                   info: UCfgInfoPtr; load: Integer
                                ) : UConfigPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_create function allocates and initializes the administration
structure of the configuration strings.

An info structure can be transferred via the info parameter, the
contents of which are transferred to the UConfig administration
structure. However, NULL or NIL can also be transferred (default
values are then used). If the flag load is set (TRUE), the CFG file
specified in the possibly existing info structure is loaded, if it
exists. Otherwise the UConfig management structure is only initialized.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_delete
!end_enumerate

!end_node


!begin_node Acfg_createInfo

 !begin_blist [Definition:]
 !item [Summary:]           Read data from the info structure from the CFG
                    strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 UCfgInfo *Acfg_createInfo( void );

 !item [Pascal:]            Function Acfg_createInfo : UCfgInfoPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_createInfo function creates a Cfg info structure for
configuring the Cfg strings.

(!B)Note:(!b) Every structure created with Acfg_createInfo should
also be released again with Acfg_deleteInfo, otherwise memory leaks
will occur!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_deleteInfo
!end_enumerate

!end_node


!begin_node Acfg_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete a management structure of the Cfg strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 void Acfg_delete( UConfig *config );

 !item [Pascal:]            Procedure Acfg_delete( config: UConfigPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_delete deletes the transferred Cfg management
structure and releases all memory used.

(!B)Note:(!b) Changes that have not yet been saved are (!I)not(!i) saved.
This may have to be implemented using the functions
Acfg_isChanged and Acfg_save.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_create, Acfg_isChanged, Acfg_save
!end_enumerate

!end_node


!begin_node Acfg_deleteInfo

 !begin_blist [Definition:]
 !item [Summary:]           Delete info structure for the Cfg strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 void Acfg_deleteInfo( UCfgInfo *info );

 !item [Pascal:]            Procedure Acfg_deleteInfo( info: UCfgInfoPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_deleteInfo function releases the transferred Cfg info structure.

(!B)Note:(!b) Every structure created with Acfg_createInfo should also
be released again with Acfg_deleteInfo, otherwise memory leaks will
occur!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_createInfo
!end_enumerate

!end_node


!begin_node Acfg_getBool
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_setBool"
!raw [stg] @xref "Acfg_getValue"

 !begin_blist [Definition:]
 !item [Summary:]           Determine the value of a logical Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_getBool( UConfig *config,
                             const char *kategorie,
                             const char *name );

 !item [Pascal:]            Function Acfg_getBool( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_getBool function reads out the 'name' parameter from the
'category' group and converts it to a logical value. The value
"True" is converted to TRUE, everything else to FALSE.

(!B)Note:(!b) Since Acfg_getValue is used internally, the environment
strings can also be used here for the search. The behavior can be
influenced using the Acfg_setInfo function.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_setBool, Acfg_getValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getChar
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_setChar"
!raw [stg] @xref "Acfg_getValue"

 !begin_blist [Definition:]
 !item [Summary:]           Determine the value of a logical Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char Acfg_getChar( UConfig *config,
                             const char *kategorie, const char *name);

 !item [Pascal:]            Function Acfg_getChar( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : Char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_getChar function reads the 'name' parameter from the
'category' group and returns the first character of the value.

(!B)Note:(!b) Since Acfg_getValue is used internally, the environment
strings can also be used here for the search. The behavior can be
influenced using the Acfg_setInfo function.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_setChar, Acfg_getValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getLong
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_setLong"
!raw [stg] @xref "Acfg_getValue"

 !begin_blist [Definition:]
 !item [Summary:]           Determine the value of a logical Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 INT32 Acfg_getLong( UConfig *config,
                             const char *kategorie, const char *name);

 !item [Pascal:]            Function Acfg_getLong( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : LongInt;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_getLong reads the parameter 'name' from the group
'category' and converts the value into a long integer.

(!B)Note:(!b) Since Acfg_getValue is used internally, the environment
strings can be used here for the search. The behavior can be influenced
using the Acfg_setInfo function.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_setLong, Acfg_getValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getHeader

 !begin_blist [Definition:]
 !item [Summary:]           Read the header comment lines

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char **Acfg_getHeader( UConfig *config,


 !item [Pascal:]            Function Acfg_getHeader(
                                   config: UConfigPtr;
                                   head_lines: Array of Pointer
                                ) : ^Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_getHeader function transfers the header comment lines of
the Cfg strings into the transferred array.

The return value is 'head_lines'.

(!B)Note:(!b) The array must be correctly dimensioned beforehand!
The Acfg_headAnzahl function is available for this.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_setHeader
!end_enumerate

!end_node


!begin_node Acfg_getInfo

 !begin_blist [Definition:]
 !item [Summary:]           Transfer data from the info structure to the CFG
                    strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 UCfgInfo *Acfg_getInfo( UConfig *config,
                                 UCfgInfo *info );

 !item [Pascal:]            Function Acfg_getInfo(
                                   config: UConfigPtr; info:
                    UCfgInfoPtr
                                ) : UCfgInfoPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_getInfo function transfers the info data from the Cfg
strings to the prepared Cfg info structure.

As a return value you get the pointer 'info' back to the info
structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getValue
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_clearValue"

 !begin_blist [Definition:]
 !item [Summary:]           Get the value of a Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_getValue( UConfig *config,
                             const char *kategorie, const char *name,
                             char *value );

 !item [Pascal:]            Function Acfg_getValue( config: UConfigPtr;
                                   kategorie, name, value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_getValue function determines the value of the transferred
parameter in the transferred group. The pointer to the parameter
value is returned.

(!B)Note:(!b) If the parameter is not found in the Cfg strings, the
Acfg_getValue function can also search for the value of the parameter
in the environment strings. The behavior can be influenced using the
Acfg_setInfo function.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_clearValue, Acfg_setValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_getString
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_clearValue"

 !begin_blist [Definition:]
 !item [Summary:]           Determine the value of a Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_getString( UConfig *config,
                             const char *kategorie, const char *name);

 !item [Pascal:]            Function Acfg_getString( config: UConfigPtr;
                                   kategorie, name: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_getString function uses a static string to access the
Acfg_getValue function to determine the value of the 'name' parameter
in the 'category' group.

(!B)Note:(!b) Since a static string for Acfg_getValue is used
internally, the function (!I)is not(!i) multithreaded fixed!

(!B)Note:(!b) If the parameter is not found in the Cfg strings, the
Acfg_getValue function can also search for the value of the parameter
in the environment strings. The behavior can be influenced using the
Acfg_setInfo function

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_clearValue, Acfg_setValue, Acfg_setInfo
!end_enumerate

!end_node


!begin_node Acfg_grpAnzahl

 !begin_blist [Definition:]
 !item [Summary:]           Determine the number of Cfg groups

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_grpAnzahl( UConfig *config );

 !item [Pascal:]            Function Acfg_grpAnzahl( config: UConfigPtr ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_grpAnzahl function determines the number of actual Cfg groups.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_grpName

 !begin_blist [Definition:]
 !item [Summary:]           Find the name of a Cfg group

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_grpName( UConfig *config,
                               int16 grp_nr, char *name )

 !item [Pascal:]            Function Acfg_grpName(
                                   config: UConfigPtr; grp_nr:
                    Integer; name: Pointer             ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_grpName function determines the group name of the group
passed in 'grp_nr' and enters it in 'name'. As a result, the pointer
'name' is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_headAnzahl

 !begin_blist [Definition:]
 !item [Summary:]           Determine the number of comment strings at the
                    beginning

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_headAnzahl( UConfig *config );

 !item [Pascal:]            Function Acfg_headAnzahl( config: UConfigPtr ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_headNumber function returns the number of comment strings
at the beginning of the Cfg file.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_isCfgfile

 !begin_blist [Definition:]
 !item [Summary:]           Check whether the file name is assigned to the
                    Cfg strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_isCfgfile( UConfig *config,
                             const char *filename );

 !item [Pascal:]            Function Acfg_isCfgfile(
                                   config: UConfigPtr;
                                   filename: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_isCfgfile function checks whether the transferred filename
is assigned to the Cfg strings or not.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_isChanged

 !begin_blist [Definition:]
 !item [Summary:]           Check whether Cfg strings have been changed

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_isChanged( UConfig *config );

 !item [Pascal:]            Function Acfg_isChanged(
                                   config: UConfigPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_isChanged function checks whether the Cfg strings have been
changed since the last time they were loaded or saved.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_load, Acfg_save
!end_enumerate

!end_node


!begin_node Acfg_load

 !begin_blist [Definition:]
 !item [Summary:]           Load Cfg strings from a file

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_load( UConfig *config,
                             const char *filename );

 !item [Pascal:]            Function Acfg_load(
                                   config: UConfigPtr; filename:
                    Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_load function loads the Cfg strings from the specified file.

If NULL or NIL is passed, the filename is used which could be set
using a Cfg info structure. If there is no filename there, nothing
will be loaded.

(!B)Note:(!b) The filename is edited beforehand. If no path has been
specified, the path from ACSblk->cfg_path is used.

(!B)Tip:(!b) The filename of the file is stored internally in the CFG
administration structure. With (!link [Save] [Acfg_save]) you only need to enter a
filename if it should differ!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_save
!end_enumerate

!end_node


!begin_node Acfg_save

 !begin_blist [Definition:]
 !item [Summary:]           Save Cfg strings to a file

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_save( UConfig *config,
                             const char *filename );

 !item [Pascal:]            Function Acfg_save(
                                   config: UConfigPtr; filename:
                    Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_save function loads the Cfg strings from the specified file.

When saving, any header comment lines that may have been set are saved
first if the first line to Savede is not itself a comment. When loading
and saving comments completely, nothing is changed in them! Since the
header comment lines (!link [can be changed] [Acfg_setHeader]) with the program, no simple check
can be implemented as to whether the header comment lines already exist
or not.

(!B)Note:(!b) After successfully saving the strings, the (!link [Change-Flag] [Acfg_isChanged]) is reset.

(!B)Note:(!b) The filename is edited beforehand. If no path has been
specified, the path from ACSblk->cfg_path is used.

(!B)Note:(!b) If NULL or NIL is passed, the filename is used which could
be set using a Cfg info structure. If there is no filename there,
nothing will be saveed.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getHeader, Acfg_isChanged, Acfg_load, Acfg_setHeader
!end_enumerate

!end_node


!begin_node Acfg_setBool
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_getBool"
!raw [stg] @xref "Acfg_setValue"

 !begin_blist [Definition:]
 !item [Summary:]           Set the value of a logical Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_setBool( UConfig *config,
                             const char *kategorie, const char *name,
                             const int16 value );

 !item [Pascal:]            Function Acfg_getBool( config: UConfigPtr;
                                   kategorie, name: Pointer;
                                   value: int16
                                ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_setBool is the opposite of Acfg_getBool and sets
the parameter 'name' of the group 'category'. The value TRUE is set
as a string "True", anything else as "False".

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getBool, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_setChar
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_getChar"
!raw [stg] @xref "Acfg_setValue"

 !begin_blist [Definition:]
 !item [Summary:]           Set the value of a logical Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_setBool( UConfig *config,
                             const char *kategorie, const char *name,
                             const int16 value );

 !item [Pascal:]            Function Acfg_getBool( config: UConfigPtr;
                                   kategorie, name: Pointer;
                                   value: int16
                                ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_setChar is the opposite of Acfg_getChar and sets
the parameter 'name' of the group 'category'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getChar, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_setLong
!raw [stg] @xref "The Configuration strings" "Configuration strings"
!raw [stg] @xref "Acfg_getLong"
!raw [stg] @xref "Acfg_setValue"

 !begin_blist [Definition:]
 !item [Summary:]           Set the value of a logical Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 INT32 Acfg_setLong( UConfig *config,
                             const char *kategorie, const char *name,
                             const INT32 value );

 !item [Pascal:]            Function Acfg_setLong( config: UConfigPtr;
                                   kategorie, name: Pointer;
                                   value: INT32
                                ) : INT32;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_setLong is the opposite of Acfg_getLong and sets
the parameter 'name' of the group 'category'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getLong, Acfg_setValue
!end_enumerate

!end_node


!begin_node Acfg_setHeader

 !begin_blist [Definition:]
 !item [Summary:]           Set the header comment lines

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char **Acfg_setHeader( UConfig *config,
                             int16 anzahl, const char **head_lines );

 !item [Pascal:]            Function Acfg_setHeader(
                                   config: UConfigPtr; anzahl:
                    Integer;
                                   head_lines: Array of Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_setHeader function transfers the transferred strings into
the Cfg strings as header comment lines.

The return value is 'head_lines'.

(!B)Note:(!b) The comment character at the beginning of the line is (!I)not(!i)
inserted and (!I)must(!i) be in the passed strings!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getHeader
!end_enumerate

!end_node


!begin_node Acfg_setInfo

 !begin_blist [Definition:]
 !item [Summary:]           Transfer data from the info structure to the
                    CFG strings

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 UCfgInfo *Acfg_setInfo( UConfig *config,
                                 const UCfgInfo *info );

 !item [Pascal:]            Function Acfg_setInfo(
                                   config: UConfigPtr; info:
                    UCfgInfoPtr
                                ) : UCfgInfoPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_setInfo function transfers the data from the prepared
info structure to the Cfg strings.

As a return value you get the pointer 'info' back to the info
structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_getInfo
!end_enumerate

!end_node


!begin_node Acfg_setValue

 !begin_blist [Definition:]
 !item [Summary:]           Set the value of a Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_setValue( UConfig *config,
                             const char *kategorie, const char *name,
                             const char *value );

 !item [Pascal:]       Function Acfg_setValue( config: UConfigPtr;
                                   kategorie, name, value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_setValue function sets the value of the transferred
parameter in the transferred group. If the group does not yet
exist, it is created, as is the parameter. If successful, the
pointer to the parameter value is returned, otherwise an empty
string.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_clearValue, Acfg_getValue
!end_enumerate

!end_node


!begin_node Acfg_strAnzahl

 !begin_blist [Definition:]
 !item [Summary:]           Determine the number of Cfg strings in a Cfg
                    group

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_strAnzahl( UConfig *config, const int16
                    grp_nr );

 !item [Pascal:]            Function Acfg_strAnzahl(
                                   config: UConfigPtr; grp_nr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_strAnzahl determines the number of Cfg strings in
the Cfg group.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])
!end_enumerate

!end_node


!begin_node Acfg_strIsComment

 !begin_blist [Definition:]
 !item [Summary:]           Check whether a Cfg string is a comment line

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 int16 Acfg_strIsComment( UConfig *config,
                             const int16 grp_nr, const int16 str_nr );

 !item [Pascal:]            Function Acfg_strIsComment(
                                   config: UConfigPtr; grp_nr: Integer
                                   str_nr: Integer             ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_strIsComment function checks whether the string specified
by 'str_nr' in the group specified by 'grp_nr' is a comment line.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_strName
!end_enumerate

!end_node


!begin_node Acfg_strName

 !begin_blist [Definition:]
 !item [Summary:]           Determine the name of a Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_strName( UConfig *config, const int16
                    grp_nr,
                             const int16 str_nr, char *name );

 !item [Pascal:]            Function Acfg_strName(
                                   config: UConfigPtr; grp_nr: Integer
                                   str_nr: Integer; name: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Acfg_strName function enters in 'name' the name of the Cfg string
specified by 'str_nr' in the group identified by 'grp_nr'. The result
is 'name'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_strValue
!end_enumerate

!end_node


!begin_node Acfg_strValue

 !begin_blist [Definition:]
 !item [Summary:]           Determine the value of a Cfg parameter

 !item [Category:]          (!link [Configuration strings] [The Configuration strings])

 !item [C:]                 char *Acfg_strValue( UConfig *config, const int16
                    grp_nr,
                             const int16 str_nr, char *value );

 !item [Pascal:]            Function Acfg_strValue(
                                   config: UConfigPtr; grp_nr: Integer
                                   str_nr: Integer; value: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Acfg_strName enters in 'value' the value of the Cfg
string specified by 'str_nr' in the group designated by 'grp_nr'.
The result is 'value'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Configuration strings] [The Configuration strings])

  !item Acfg_strName
!end_enumerate

!end_node


!begin_node Ach_isWhite

 !begin_blist [Definition:]
 !item [Summary:]           Check string for empty string

 !item [Category:]          String functions

 !item [C:]                 int16 Ach_isWhite( char ch );

 !item [Pascal:]            Function Ach_isWhite( ch: char ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ach_isWhite function checks whether a character is a "white space",
i.e. one of the characters tab, carriage return, line feed or space.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions
!end_enumerate

!end_node


!begin_node Ach_tolower

 !begin_blist [Definition:]
 !item [Summary:]           Convert characters to lower case

 !item [Category:]          String functions

 !item [C:]                 char Ach_tolower( char ch );

 !item [Pascal:]            Function Ach_tolower( ch: char ) : char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ach_tolower function converts a character to a lowercase letter.
The umlauts are recognized correctly.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ach_toupper
!end_enumerate

!end_node


!begin_node Ach_toupper

 !begin_blist [Definition:]
 !item [Summary:]           Convert characters to uppercase

 !item [Category:]          String functions

 !item [C:]                 char Ach_toupper( char ch );

 !item [Pascal:]            Function Ach_toupper( ch: char ) : char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ach_toupper function converts a character to an uppercase letter.
The umlauts are recognized correctly.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ach_tolower
!end_enumerate

!end_node


!begin_node Acreate

 !begin_blist [Definition:]
 !item [Summary:]           Data type for Create Routine

 !item [Category:]          (!link [Structures] [The Structures])

 !item [C:]                 typedef Awindow *(*Acreate)( void *extra );

 !item [Pascal:]       Acreate = Function( x: Pointer ) : (!link [AwindowPtr] [Awindow]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This data type is used for a window's create routine. The routine is
given a pointer of indeterminate type since it may differ depending on
the task of the window. For example, an editor window could be given
the file name.  If no parameter is required then NULL should be passed.
The result is a pointer to the generated window. If the window can not
be created, NULL should be returned for your routine to process.

!end_node


!begin_node ACSaboutme

 !begin_blist [Definition:]
 !item [Summary:]           Information about the Application

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSaboutme)( void );

 !item [Pascal:]            ACSaboutme: Procedure;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function to which the pointer ACSaboutme refers is called when
the user has selected the first entry in the accessories menu. Here,
e.g. In the (!I)ACSpro(!i)-(!I)GUI-Editor(!i), a separate routine can be entered.

The default routine shows a dialog with information about (!I)ACSpro(!i).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSblk

 !begin_blist [Definition:]
 !item [Summary:]           Pointer to the global (!I)ACSpro(!i) variables

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 Ablk *ACSblk;

 !item [Pascal:]            ACSblk: AblkPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

As of (!I)ACSpro(!i) version 2.00, all variables are components of the
structure Ablk. The ACSblk pointer points to this structure. All
global variables are available via this pointer.

In order to make variables that already exist in ACS 1.x available
with small restrictions, macros were defined in the header file ACS.H.
This makes it easy to convert projects from ACS 1.x to 2.x. If you
remove the macro __ACS1__ from ACS.H, these macros can no longer be
used in C. In C, old and new styles must not be mixed because the
preprocessor cannot distinguish them.

(!B)Note:(!b) (!I)In general, however, the variables should be accessed in the
"new style" using the pointer ACSblk.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Ablk, AblkPtr
!end_enumerate

!end_node


!begin_node ACSbutton

 !begin_blist [Definition:]
 !item [Summary:]           (!link [Protocol] [External communication]) & Filter Routine for Mouse clicks

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSbutton)( int16 *button, int16 *kreturn);

 !item [Pascal:]            ACSbutton: Procedure( Var button, kreturn: Integer);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the pointer ACSbutton is called before
the GEM mouse buttons are processed. You can enter your own routine
in the (!I)ACSpro(!i)-(!I)GUI editor(!i). You can use this to log or filter
buttons. To filter, the values must be changed appropriately.

The default routine does nothing.

'button' contains the bit mask of the pressed mouse buttons, 'kreturn'
contains the number of clicks (see also evnt_button). The mouse
positions are in the ACSblk

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSclose

 !begin_blist [Definition:]
 !item [Summary:]           Exit the Application

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSclose)( void );

 !item [Pascal:]            ACSclose: Procedure;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the pointer ACSclose is called from the
pure desktop if the menu item 'Exit' has been selected. A separate
routine can be entered in the (!I)ACSpro(!i)-(Builder), which e.g.
carries out a security check beforehand.

The default routine routine in turn calls Aev_quit - this should also
make its own routine at the end to cause (!I)ACSpro(!i) to end the Application.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSerror

 !begin_blist [Definition:]
 !item [Summary:]           Error routine for the output of errors

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSerror)( int16 mess, void *para );

 !item [Pascal:]            ACSerror: Procedure( mess: Integer; para: Pointer);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSerror pointer is used to output
errors that have occurred.

All (!I)ACSpro(!i) programs or modules should output their error messages using
this routine and the standard error numbers! Normally, the powerful
Ash_error routine is responsible for this, which should be called up
properly via ACSblk.

An error number is coded in 'mess', the optional parameter 'para' can
point to further data that you would like to display with your own
numbers. If you want to use your own routine instead - e.g. because
you want to output your own error numbers properly - you should log
in via ACSblk.

This happens, for example, in Pure-C

     ACSblk->ACSerror = my_error_call;

In Pure Pascal, this happens through

     ACSblk^.ACSerror := my_error_call;

The routine 'my_error_call' should then proceed in such a way that only
its own error numbers are evaluated, otherwise Ash_error should then
be jumped to - other modules rely on it!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, Ash_error
!end_enumerate

!end_node


!begin_node ACSGEMScript

 !begin_blist [Definition:]
 !item [Summary:]           Process general GEMScript commands

 !item [Category:]          (!link [Variables] [The Variables]), GEMScript Protocol

 !item [C:]                 int16 (*ACSGEMScript)( int16 anz, char **cmd,
                             A_GSAntwort *antwort )

 !item [Pascal:]            ACSGEMScript: Function(
                                         anz: Integer; cmd: Pointer;
                                         antwort: A_GSAntwortPtr
                                      ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSGEMScript pointer is used to
process GEMScript commands. The default function is called
Aev_GEMScript.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item GEMScript Protocol
!end_enumerate

!end_node


!begin_node ACSinit

 !begin_blist [Definition:]
 !item [Summary:]           Application initialization

 !item [Category:]          The Variables, Function pointers

 !item [C:]                 int16 ACSinit( void );

 !item [Pascal:]            Function ACSinit : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function ACSinit (!B)must(!b) be programmed itself. At this point
everything is already initialized from (!I)ACSpro(!i).

Usually windows are created, opened if necessary and the reaction
to the (!I)New(!i) symbol is defined. Then jump into the (event) main
loop. Return values are OK and FAIL. With FAIL, the Application
is ended.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSinit0

 !begin_blist [Definition:]
 !item [Summary:]           Initializations (!I)before(!i) the initialization
                    of the (!I)ACSpro(!i) systems

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 (*ACSinit0)( void );

 !item [Pascal:]            ACSinit0: Function : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function ACSinit0 is run after the initialization of the AES, the
VDI variables and the paths. The root window though has not yet been
initialized. Return values are OK and FAIL. With FAIL, the Application
is ended. A separate routine can be entered in the (!I)ACSpro(!i)-(!I)GUI editor(!i).

The default routine simply does nothing.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSkey

 !begin_blist [Definition:]
 !item [Summary:]           (!link [Protocol] [External communication]) & Filter Routine for key presses
 
 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSkey)( int16* kstate, int16* key );

 !item [Pascal:]            ACSkey: Procedure( Var kstate, key: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSkey pointer is called before the
GEM key presses are processed. You can enter your own routine. They
can be used to log key presses, to filter or to implement a program
keyboard table. The keys are encoded by NKCC. To filter, the values
must be changed appropriately.

The default routine does nothing.

(!B)Note:(!b) This routine is also called in modal dialogs.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, ACSwikey
!end_enumerate

!end_node


!begin_node ACSmessage

 !begin_blist [Definition:]
 !item [Summary:]           Process messages that are unknown to (!I)ACSpro(!i)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSmessage)( int16 *ev_mmgpbuf );

 !item [Pascal:]            ACSmessage: Procedure( Var ev_mmgpbuff: ARRAY_8 );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSmessage pointer processes the GEM
messages that (!I)ACSpro(!i) does not know. You can enter your own routine.

The default routine does nothing.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, ACSmproto
!end_enumerate

!end_node


!begin_node ACSmoduleterm

 !begin_blist [Definition:]
 !item [Summary:]           Terminate an ACS module

 !item [Category:]          Module Programming

 !item [C:]                 void ACSmoduleterm( void );

 !item [Pascal:]            The function is not available in
                    Pure-Pascal, since unfortunately modules
                    cannot be developed with it.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The ACSmoduleterm function only exists for reloadable modules. Only
the module can log out. It must know whether this is permissible. If
data or program code are referenced elsewhere, the module must not be
deregistered.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Module Programming

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSmouse

 !begin_blist [Definition:]
 !item [Summary:]           (!link [Protocol] [External communication]) & Filter Routine for mouse movements

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSmouse)( void );

 !item [Pascal:]            ACSmouse: Procedure;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSmouse function pointer is called
before the mouse movements are processed. You can use it to log or
filter mouse movements. To filter, the values must be changed
appropriately.

The values are in ACSblk->ev_mmox and ACSblk->ev_mmoy.

The default routine does nothing.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACSmproto

 !begin_blist [Definition:]
 !item [Summary:]           (!link [Protocol] [External communication]) & Filter Routine for GEM messages

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSmproto)( int16 *ev_mmgpbuf );

 !item [Pascal:]            ACSmproto: Procedure( Var ev_mmgpbuff: ARRAY_8 );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function to which the pointer ACSmproto refers is called before
the GEM messages are processed. You can enter your own routine. You
can use it to log or filter messages. To filter, the values of the
field must be changed appropriately.

The default routine does nothing.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, ACSmessage
!end_enumerate

!end_node


!begin_node ACSterm

 !begin_blist [Definition:]
 !item [Summary:]           Closing routine before the end of the program

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSterm)( void );

 !item [Pascal:]            ACSterm: Procedure;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSterm pointer is called before the
program is terminated.

(!B)Important:(!b) This call is made by (!I)ACSpro(!i). The program (!B)never(!b) calls on
the routine directly.

The default routine does nothing.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk
!end_enumerate

!end_node


!begin_node ACStimer

 !begin_blist [Definition:]
 !item [Summary:]           Closing routine before the end of the program

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACStimer)( void );

 !item [Pascal:]            ACStimer: Procedure;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACStimer pointer is called each time
in the main loop. The call is enclosed by Awi_update(BEG_UPDATE).

The default routine does nothing.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, ACSmproto
!end_enumerate

!end_node


!begin_node ACSwikey

 !begin_blist [Definition:]
 !item [Summary:]           (!link [Protocol] [External communication]) & Filter Routine for key presses
                    on window

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*ACSwikey)( int16* kstate, int16* key );

 !item [Pascal:]            ACSwikey: Procedure( Var kstate, key: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function referred to by the ACSwikey pointer is called after the
key codes for menu and object have been evaluated, but runs through
before calling Awindow.keys. You can enter your own routine. You can
use it to log keystrokes to the dialog, to filter or to implement a
keyboard keyboard table. The keys are encoded using NKCC. To filter,
the values must be changed appropriately.

The default routine does nothing.

(!B)Note:(!b) This routine is also called in modal dialogs.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, ACSkey
!end_enumerate

!end_node


!begin_node Adescr

 !begin_blist [Definition:]
 !item [Summary:]           Initialization structure of (!I)ACSpro(!i)

 !item [Category:]          (!link [Structures] [The Structures])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   char magic[8];
   int16 version;
   int16 dx, dy;
   int16 flags;
   char acc_reg[32];
   Awindow *root;
   Awindow *acc;
   Amouse mouse[32];
} Adescr;
!end_sourcecode

 !item [Pascal:]    
!begin_sourcecode
Adescr = RECORD
   magic: packed array [0..7] of char;
   version: Integer;
   dx, dy: Integer;
   flags: Integer;
   acc_reg: packed array [0..31] of char;
   root: AwindowPtr;
   acc: AwindowPtr;
   mouse: Array [0..31] of Amouse;
END;
!end_sourcecode

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This is the initialization structure for (!I)ACSpro(!i). The elements of the
structure are described as follows:

!begin_xlist [version]
!label Adescr.magic
 !item [magic]     Name of the (!I)ACSpro(!i) library.

!label Adescr.version
 !item [version]   Version number of (!I)ACSpro(!i).

!label Adescr.dx
!label Adescr.dy
 !item [dx, dy]    These values describe a frame around the desktop in
           character positions. (!I)ACSpro(!i) prevents windows from being
           placed outside this frame. Negative values indicate how
           many character positions that windows can protrude from.

!label Adescr.flags
 !item [flags]     These flags control general behavior. The following
           constants exist:  AB_CLICKMENU, AB_MOVIES, AB_ACUSTIC,
           AB_HIDEPOINTER, AB_CENTERDIALOG, AB_GDOSFONT,
           AB_MENUFIRST, AB_SMARTREDRAW, AB_NO3D, AB_LAZYEVAL,
           AB_NOMEMCHECK, AB_NOTRANSICON,

           !begin_xlist [Grow-/Shrink-Boxes]
            !item [Pulldown Menu (AB_CLICKMENU)] (!nl)
                              This applies to menus in windows and
                              forces the user to actually select
                              the menu titles before they drop down.

            !item [Grow/Shrink Boxes ((AB_MOVIES)]
                    When turned on, these are "Ghost"
                   frames that give the appearance that
                              the window is get larger or smaller
                              when the windows are opened or closed.

            !item [Audible Error (AB_ACUSTIC)] (!nl)
                 Reports some errors acoustically rather
                  that visually.

            !item [Hide Mouse (AB_HIDEPOINTER)] (!nl)
                    This can prevent the mouse from some
              flickering with longer text.

            !item [Center Dialogs (AB_CENTERDIALOG)] (!nl)
                Places dialogs in the center of the
             screen, otherwise they will be staggered.

            !item [Load GDOS Fonts (AB_GDOSFONT)] (!nl)
               Provides access to all fonts of the
                 system, but may require a longer startup
                              phase for the program.

            !item [Menu] Button First (AB_MENUFIRST)] (!nl)
                Forces processing of keys in the menu
                tree before the work object tree.
            !end_xlist

!label Adescr.acc_reg
 !item [acc_reg]   This is the text that is registered in the Accessories
           menu bar entry.

!label Adescr.root
 !item [root]      Points to the window structure of the the root window.
           In the Pascal version NIL stands for the generic
           desktop DESKTOP.

!label Adescr.acc
 !item [acc]       In accessory mode, a window other than the root window
           can be used.  Otherwise, NULL or NIL must be entered.

!label Adescr.mouse
 !item [mouse]     The 32 mouse shapes in the palette are entered here.
!end_xlist

!end_node


!begin_node Adr_add

 !begin_blist [Definition:]
 !item [Summary:]           Include an object in the selection list

 !item [Category:]          Selection operations

 !item [C:]                 void Adr_add( Awindow *window, const int16 obnr );

 !item [Pascal:]            Procedure Adr_add( window: (!link [AwindowPtr] [Awindow]); obnr:
                    Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Adr_add includes the object obnr from the work object
in the selection list. If the new object belongs to a different
window than the previous one, the list is deleted beforehand. The
routine puts the new object in the status (!I)SELECTED(!i) and refreshes
the screen. The display window is sent the message AS_SELECTADD.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations

  !item Adr_del, Adr_unselect
!end_enumerate

!end_node


!begin_node Adr_box

 !begin_blist [Definition:]
 !item [Summary:]           Draw a rectangle and add objects to the selection
                    list

 !item [Category:]          Selection operations

 !item [C:]                 void Adr_box( int16 x, int16 y );

 !item [Pascal:]            Procedure Adr_box( x, y: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Adr_box function creates a rectangle at the coordinates. All
affected objects are transferred to the selection list. If the SHIFT
key is pressed at the same time, the previously selected objects
remain in the list. The point of impact determines the window. During
the drag the mouse adopts mouse shape index 2 (by default, the
pointing hand)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations
!end_enumerate

!end_node


!begin_node Adr_del

 !begin_blist [Definition:]
 !item [Summary:]           Remove object from the selection list

 !item [Category:]          Selection operations

 !item [C:]                 void Adr_del( Awindow *window, const int16 obnr );

 !item [Pascal:]            Procedure Adr_del( window: (!link [AwindowPtr] [Awindow]); obnr:
                    Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Adr_del removes the object above the work object from
the selection list. The (!I)SELECTED(!i) flag is cleared and the screen
is refreshed. The message AS_SELECTDEL is sent to the window.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations

  !item Adr_add, Adr_unselect
!end_enumerate

!end_node


!begin_node Adr_drag

 !begin_blist [Definition:]
 !item [Summary:]           Dragging the objects from the selection list

 !item [Category:]          Selection operations

 !item [C:]                 void Adr_drag( int16 x, int16 y );

 !item [Pascal:]            Procedure Adr_drag( x, y: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Adr_drag function starts dragging the objects from the selection
list at the coordinates x, y. When the mouse button is released over
an accepting object, its drag routine is called. Otherwise the objects
move back to their origin. While dragging, the mouse adopts mouse shape
index 3 (the pushing hand by default).

Dragging can be configured. To do this, the message AS_CONFIGDRAG is
sent to the window to which the objects belong. For accepting objects
that have set the flag (!link [AO_ACCEPT] [AO_ACCEPT]), the message AS_CHECKDRAG is sent to
the receiving window. It can therefore refuse to accept with a visual
reaction!

For example, the trashcan in the DESKTOP does not accept the New icon!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations
!end_enumerate

!end_node


!begin_node Adr_next

 !begin_blist [Definition:]
 !item [Summary:]           Next object number to be processed

 !item [Category:]          Selection operations

 !item [C:]                 int16 Adr_next( void );

 !item [Pascal:]            Function Adr_next : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Adr_next function returns the next object number in the selection
list. Before the first call, you must initialize with Adr_start. This
routine takes into account Adr_del calls between two Adr_next calls.
If there is no other element in the list, the value -1 is returned.

If the object comes from the toolbar, the return value has been OR
linked with (!link [A_TOOLBAR] [A_TOOLBAR]).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations

  !item Adr_start, Adr_del
!end_enumerate

!end_node


!begin_node Adr_start

 !begin_blist [Definition:]
 !item [Summary:]           Initialize the selection list query

 !item [Category:]          Selection operations

 !item [C:]                 int16 Adr_start( void );

 !item [Pascal:]            Function Adr_start : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Adr_start function initializes the selection list query. The next
query with Adr_next returns the first object

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations

  !item Adr_next
!end_enumerate

!end_node


!begin_node Adr_unselect

 !begin_blist [Definition:]
 !item [Summary:]           Remove all objects from the selection list

 !item [Category:]          Selection operations

 !item [C:]                 void Adr_unselect( void );

 !item [Pascal:]            Procedure Adr_unselect;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Adr_unselect function removes all objects from the selection
list. The objects are drawn without the status (!I)SELECTED(!i). The message
AS_SELECTDEL with the parameter (!I)NULL(!i) or (!I)NIL(!i) is sent to the window.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Selection operations

  !item Adr_add, Adr_del
!end_enumerate

!end_node


!begin_node AESglobal

 !begin_blist [Definition:]
 !item [Summary:]           The initialized AES 'global' field

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 *AESglobal;

 !item [Pascal:]            AESglobal: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable AESglobal points to the initialized 'global' field, which
is filled in at appl_init.  Values such as version numbers and the
number of parallel processes are found in it.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node Aev_AcCopy

 !begin_blist [Definition:]
 !item [Summary:]           Copy the help page to the clipboard

 !item [Category:]          PureC Help Protocol

 !item [C:]                 int16 Aev_AcCopy( char *help_acc,
                             Awindow *window );

 !item [Pascal:]            Function Aev_AcCopy(
                                   help_acc, referenz: Pointer;
                                   window: (!link [AwindowPtr] [Awindow])
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_AcCopy tries to have the current help page from the
PureC help accessory copied to the clipboard.

If the help request is sent correctly, TRUE is returned, otherwise
FALSE.

If a help window is transferred, the AS_PC_VERSION message is sent to
the accessory upon receipt of the response.

A help accessory can be specified in help_acc. If the indicated
accessory is not found or if the pointer is NULL or NIL, the PureC
help (PC_HELP.ACC) is searched first, then ST-Guide.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item PureC Help Protocol
!end_enumerate

!end_node


!begin_node Aev_AcHelp

 !begin_blist [Definition:]
 !item [Summary:]           Show help page via PureC Help Protocol

 !item [Category:]          PureC Help Protocol

 !item [C:]                 int16 Aev_AcHelp( char *help_acc,
                             char *referenz, Awindow *window );

 !item [Pascal:]            Function Aev_AcHelp(
                                   help_acc, referenz: Pointer;
                                   window: (!link [AwindowPtr] [Awindow])
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_AcHelp tries to display a help page for the given
reference.

If the help request is sent correctly, TRUE is returned, otherwise
FALSE.

If a help window is transferred, the AS_PC_VERSION message is sent
to the accessory upon receipt of the response.

A help accessory can be specified in help_acc. If the transferred
accessory is not found or if the pointer is NULL or NIL, the PureC
help (PC_HELP.ACC) is searched first, then ST-Guide.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item PureC Help Protocol
!end_enumerate

!end_node


!begin_node Aev_AcVersion

 !begin_blist [Definition:]
 !item [Summary:]           Determine the version number of the PureC help
                    accessories

 !item [Category:]          PureC Help Protocol

 !item [C:]                 int16 Aev_AcVersion( char *help_acc,
                             Awindow *window );

 !item [Pascal:]            Function Aev_AcVersion(
                                   help_acc: Pointer; window:
                    (!link [AwindowPtr] [Awindow])
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_AcVersion tries to determine the version number
of the PureC help accessories.

If the help request is sent correctly, TRUE is returned, otherwise
FALSE.

If a window is transferred, the AS_PC_VERSION message is sent to it
when the accessory response arrives.

The preferred help accessory can be specified in help_acc. If the
transferred accessory is not found or the pointer is NULL or NIL,
the PureC help (PC_HELP.ACC) is searched first, then ST-Guide.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item PureC Help Protocol

  !item Aev_PCHelpVersion
!end_enumerate

!end_node


!begin_node Aev_DhstAdd

 !begin_blist [Definition:]
 !item [Summary:]           Register the document with the DHST server

 !item [Category:]          DHST Protocol

 !item [C:]                 int16 Aev_DhstSaved( const char *file );

 !item [Pascal:]            Function Aev_DhstSaved( const char *file ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_DhstAdd registers the transferred file with the
DHST server (e.g. (!link [Start Me Up!] [Start Me Up!])). If installed, this lists all
stored files system-globally and allows quick editing of one of the
files in the list.

The two strings passed to Aev_DhstAdd are sent to the DHST server
together with ACSblk->AppLongName and ACSblk->appname after copying
to global memory. The return value indicates whether the delivery
was successful (TRUE) or not (FALSE).

(!B)Note:(!b) The transferred strings are copied to global memory before
sending, i.e. "normal" strings can be used here.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item DHST Protocol

  !item (!link [Document History Protocol] [DHST Protocol])

  !item Aev_DhstSaved
!end_enumerate

!end_node


!begin_node Aev_DhstSaved

 !begin_blist [Definition:]
 !item [Summary:]           Register the file with the DHST server

 !item [Category:]          DHST Protocol

 !item [C:]                 int16 Aev_DhstSaved( const char *file );

 !item [Pascal:]            Function Aev_DhstSaved( file: Pointer ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_DhstSaved extracts the pure file name as a document
name using Af_2fullname and uses it to register the file with the
DHST server using Aev_DhstAdd.

(!B)Note:(!b) The transferred strings are copied to global memory before
sending, i.e. "normal" strings can be used here.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item DHST Protocol

  !item (!link [Document History Protocol] [DHST Protocol])

  !item Aev_DhstAdd
!end_enumerate

!end_node


!begin_node Aev_GEMScript

 !begin_blist [Definition:]
 !item [Summary:]           Process general GEMScript commands

 !item [Category:]          GEMScript Protocol

 !item [C:]                 int16 Aev_GEMScript( int16 anz, char **cmd,
                             A_GSAntwort *antwort );

 !item [Pascal:]            Function Aev_GEMScript(
                                   anz: Integer; cmd: Pointer;
                                   antwort: A_GSAntwortPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aev_GEMScript function processes some GEMScript commands by
default as implemented in (!I)ACSpro(!i). These are:

!begin_xlist [AppGetLongName]
 !item [AppGetLongName]  Returns the name of the Application. This is taken
                 from ACSblk->AppLongName. The default is the name
                 from ACSblk->basename.

 !item [CheckCommand]    Checks whether the specified command is understood

 !item [GetAllCommands]  Returns a list of the GEMScript commands understood
                 by the window

 !item [GetFront]        Returns the name of the top window

 !item [KeyPress]        Simulates a keystroke

 !item [Quit]            The Application is terminated via Aev_quit
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions, GEMScript Protocol
!end_enumerate

!end_node


!begin_node Aev_mess

 !begin_blist [Definition:]
 !item [Summary:]           Process urgent GEM messages (e.g. WM_REDRAW)

 !item [Category:]          Event support

 !item [C:]                 void Aev_mess( void );

 !item [Pascal:]            Procedure Aev_mess;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aev_mess function processes upcoming GEM messages. It is used to
refresh windows before returning to the main loop (message WM_REDRAW).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Event support
!end_enumerate

!end_node


!begin_node Aev_PCHelpVersion

 !begin_blist [Definition:]
 !item [Summary:]           Determine the version number of the PureC Help
                            Protocol

 !item [Category:]          PureC Help Protocol

 !item [C:]                 int16 Aev_PCHelpVersion( void );

 !item [Pascal:]            Function Aev_PCHelpVersion : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_PCHelpVersion returns the last received version
number of the PureC help accessories. If this does not exist or no
feedback came, then 0 is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item PureC Help Protocol

  !item Aev_SendAcVersion
!end_enumerate

!end_node


!begin_node Aev_OlgaBreaklink

 !begin_blist [Definition:]
 !item [Summary:]           Report the deletion of a file to the OLGA manager

 !item [Category:]          OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol])

 !item [C:]                 int16 Aev_OlgaBreaklink( const char *datei );

 !item [Pascal:]            Function Aev_OlgaBreaklink( datei: Pointer ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_OlgaBreaklink reports to the OLGA manager that a file
is no longer available for the OLGA protocol - e.g. because it was
deleted. This then informs the any existing clients.

The return value indicates whether the message could be sent to the
OLGA manager.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol])

  !item OLGA Infos
!end_enumerate

!end_node


!begin_node Aev_OlgaIdle

 !begin_blist [Definition:]
 !item [Summary:]           Test the OLGA connection

 !item [Category:]          OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol]), (!link [OLGA-Client] [OLGA Protocol])

 !item [C:]                 int16 Aev_OlgaIdle( void );

 !item [Pascal:]            Function Aev_OlgaIdle : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_OlgaIdle checks an existing OLGA connection. This
has no effect at the moment.

The return value indicates whether the message could be sent to the
OLGA manager.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol]), (!link [OLGA-Client] [OLGA Protocol])

  !item OLGA Infos
!end_enumerate

!end_node


!begin_node Aev_OlgaRename

 !begin_blist [Definition:]
 !item [Summary:]           Report renaming a file to OLGA Manager

 !item [Category:]          OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol])

 !item [C:]                 int16 Aev_OlgaRename( const char *old_datei,
                             const char *new_datei );

 !item [Pascal:]            Function Aev_OlgaRename(
                                   old_datei, new_datei: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_OlgaRename reports a renaming of a file to the OLGA
manager. This then informs any existing clients. It is left at the
discretion of every application to have the file renamed when saving
as a new filename (see message OLGA_RENAME in the OLGA documentation).

The return value indicates whether the message could be sent to the
OLGA manager.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol])

  !item OLGA Infos
!end_enumerate

!end_node


!begin_node Aev_OlgaUpdate

 !begin_blist [Definition:]
 !item [Summary:]           Contact the OLGA manager after saving

 !item [Category:]          OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol])

 !item [C:]                 int16 Aev_OlgaUpdate( const char *datei );

 !item [Pascal:]            Function Aev_OlgaUpdate( datei: Pointer ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_OlgaUpdate - or even better Awi_saved - should be
called after saving a file as (!link [OLGA-Server] [OLGA Protocol]) to notify any existing
OLGA clients of the update. If the specified file is a registered
(!link [OLGA Connection] [OLGA Infos]), the information registered there will be used, 
especially the information about a possibly available info file
(see also message OLGA_UPDATE in the OLGA documentation).

The return value indicates whether the message could be sent to the
OLGA manager.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item OLGA Protocol, (!link [OLGA-Server] [OLGA Protocol])

  !item Awi_saved

  !item OLGA Infos
!end_enumerate

!end_node


!begin_node Aev_quit

 !begin_blist [Definition:]
 !item [Summary:]           Quit the Application

 !item [Category:]          Event support

 !item [C:]                 void Aev_quit( void );

 !item [Pascal:]            Procedure Aev_quit;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aev_quit function causes the application to close. After returning
to the main loop, it is ended.

Typically this function is used as a click routine for the "Exit"
entry in the main menu.

(!B)Note:(!b) The Application should always be terminated via Aev_quit(). The
termination of the Application is then controlled by (!I)ACSpro(!i). So, every
window (!B)except(!b) the root window (usually the pure desktop) is sent the
message AS_TERM. The root window is only closed when all windows are
closed. (!I)If the scheduling of the window itself is arranged, then
generally the root window may be deleted too early, so accessing the
defunct window will lead to all kinds of (!link [Error Message] [Ash_error]) and crashes!(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Event support
!end_enumerate

!end_node


!begin_node Aev_release

 !begin_blist [Definition:]
 !item [Summary:]           Wait for the mouse buttons to be released

 !item [Category:]          Event support

 !item [C:]                 void Aev_release( void );

 !item [Pascal:]            Procedure Aev_release;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aev_release function waits until the mouse buttons are released.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Event support
!end_enumerate

!end_node


!begin_node Aev_STGuideHelp

 !begin_blist [Definition:]
 !item [Summary:]           View the help page of an ST-Guide hypertext

 !item [Category:]          ST-Guide Protocol

 !item [C:]                 int16 Aev_STGuideHelp( char *hyp_text,
                             char *referenz, Awindow *window )

 !item [Pascal:]            Function Aev_STGuideHelp(
                                   hyp_text, referenz: Pointer;
                                   window: (!link [AwindowPtr] [Awindow])
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_STGuideHelp tries to display a help page for the
given reference in the optionally specified file. If the help request
could be sent correctly to the ST-Guide, TRUE is returned, otherwise
FALSE.

If a window is transferred, the AS_PC_VERSION message is sent to the
accessory upon receipt of the response. 

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item ST-Guide Protocol
!end_enumerate

!end_node


!begin_node Aev_unhidepointer

 !begin_blist [Definition:]
 !item [Summary:]           Make the mouse pointer visible

 !item [Category:]          Event support

 !item [C:]                 void Aev_unhidepointer( void );

 !item [Pascal:]            Procedure Aev_unhidepointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_unhidepointer makes a mouse pointer hidden due to a
key press visible again.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Event support
!end_enumerate

!end_node


!begin_node Aev_WmRedraw

 !begin_blist [Definition:]
 !item [Summary:]           Send redraw message

 !item [Category:]          External communication

 !item [C:]                 int16 Aev_WmRedraw( const int16 dest_id,
                             const int16 wind_id, const Axywh *area );

 !item [Pascal:]            Function Aev_WmRedraw(
                                   dest_id, wind_id: int16;
                                   Var area: Axywh
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aev_WmRedraw sends a redraw message for the screen section
passed in 'area'. If the window handle passed in 'wind_id' is negative,
form_dial will force the redrawing of all affected windows. Since the
AES summarizes the incoming redraw messages, nothing should flicker.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item External communication
!end_enumerate

!end_node


!begin_node Af_2drv

 !begin_blist [Definition:]
 !item [Summary:]           Extract drive information from file path

 !item [Category:]          File functions

 !item [C:]                 int16 Af_2drv( const char *file );

 !item [Pascal:]            Function Af_2drv( file: Pointer ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_2drv function analyzes the drive that was specified in 'file'.
If this is not in the file specification, then the current drive is
determined. The return value is analogous to Dgetdrv.

For example, for Af_2drv("D:\TEMP\READ_ME.TXT") the value 3 is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_buildname, Af_2ext, Af_2fullname, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_2ext

 !begin_blist [Definition:]
 !item [Summary:]           Extract file type from file path

 !item [Category:]          File functions

 !item [C:]                 char *Af_2ext( char *dest, const char *file );

 !item [Pascal:]            Function Af_2ext( dest, file: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_2ext function determines the final file type from the file
specification in 'file' and stores it in 'dest'. If no file type
could be recognized, an empty string is stored. The return is the
pointer to 'dest'.

For example, after Af_2ext(dest, "D:\TEMP\READ_ME.TXT") the string
"TXT" is in dest.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_buildname, Af_2drv, Af_2fullname, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_2fullname

 !begin_blist [Definition:]
 !item [Summary:]           Extract the file name including the suffix from
                    the file path

 !item [Category:]          File functions

 !item [C:]                 char *Af_2fullname( char *dest, const char *file);

 !item [Pascal:]            Function Af_2fullname( dest, file: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Af_2fullname determines the final file name including the
type from the file specification in 'file' and stores it in 'dest'.
If no name could be recognized, an empty string is stored. The return
is the pointer to 'dest'.

For example, after Af_2fullname(dest, "D:\TEMP\READ_ME.TXT") the string
"READ_ME.TXT" in in dest.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_buildname, Af_2drv, Af_2ext, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_2name

 !begin_blist [Definition:]
 !item [Summary:]           Extract the pure file name from the file path

 !item [Category:]          File functions

 !item [C:]                 char *Af_2name( char *dest, const char *file );

 !item [Pascal:]            Function Af_2name( dest, file: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_2name function determines the final file name from the file
specification in 'file' and stores it in 'dest'. If no name could be
recognized, an empty string is stored. The return is the pointer to
'dest'.

For example, after Af_2name(dest, "D:\TEMP\READ_ME.TXT") the string
"READ_ME" is in dest.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_buildname, Af_2drv, Af_2ext, Af_2fullname, Af_2path
!end_enumerate

!end_node


!begin_node Af_2path

 !begin_blist [Definition:]
 !item [Summary:]           Extract the path from the file path

 !item [Category:]          File functions

 !item [C:]                 char *Af_2path( char *dest, const char *file );

 !item [Pascal:]            Function Af_2path(dest, file: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_2path function extracts the path from the specification in
'file' and stores it in 'dest'. If no path is recognized, "\" appears
in dest. The return is the pointer to 'dest'.

For example after Af_2path(dest, "D:\TEMP\READ_ME.TXT") the string
 "\TEMP\" is in dest.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_buildname, Af_2drv, Af_2ext, Af_2fullname, Af_2name
!end_enumerate

!end_node


!begin_node Af_buildname

 !begin_blist [Definition:]
 !item [Summary:]           Assemble absolute file path

 !item [Category:]          File functions

 !item [C:]                 char *Af_buildname(
                                char *dest, int16 drv,
                                const char *path, const char *name,
                                const char *ext
                             );

 !item [Pascal:]            Function Af_buildname( dest: Pointer; drv: Integer;
                                   path, name, ext: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_buildname function builds an absolute file specification from
the details of 'drv', 'path', 'name' and 'ext', which is stored in
'dest'. The return is the pointer to 'dest'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_2drv, Af_2ext, Af_2fullname, Af_2name, Af_2path
!end_enumerate

!end_node


!begin_node Af_cfgfile

 !begin_blist [Definition:]
 !item [Summary:]           Add file names to the file path of a cfg file

 !item [Category:]          File functions

 !item [C:]                 char *Af_cfgfile( char *file );

 !item [Pascal:]            Function Af_cfgfile( file: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_cfgfile function enhances the transferred filename to a full
path name for a configuration file. For this purpose, the cfg_path
is evaluated, which is determined in the initialization phase of each
(!I)ACSpro(!i) Application. If this path is empty, scrp_path is evaluated.
If it is not available, (!I)ACSpro(!i) uses the current root directory.

For example, Af_cfgfile("DESKTOP") returns "C:\HOME\DESKTOP.CFG".

(!B)Attention:(!b) Since a static buffer is used internally, this function
is not yet multithreading fixed!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions
!end_enumerate

!end_node


!begin_node Af_fileselect

 !begin_blist [Definition:]
 !item [Summary:]           Select a file using the File Selector

 !item [Category:]          File functions

 !item [C:]                 ULinList *Af_fileselect( char *title, char *path,
                                char *ext, int16 sort_mode,
                                int16 multi, Awindow *window );

 !item [Pascal:]            Function Af_fileselect(
                                   title, path, ext: Pointer;
                                   sort_mode, multi: Integer;
                                   window: (!link [AwindowPtr] [Awindow])
                                ) : ULinListPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_fileselect function calls the file selector. The multi parameter
specifies whether multiple files can be selected (TRUE) or not (FALSE).
window specifies whether the modal (window = NULL) or the non-modal
file selector (window! = NULL) should be used.

!begin_xlist [sort_mode]
 !item [title]      Contains the title line of the file selector

 !item [path]       The path and filename of the file to be selected (please
            transfer it in the form "C:\abc\file.dat"). The file name
            can be empty, then the path is preset.

 !item [ext]        Contains a list of extensions (file extensions) that are
            permitted for selection (see below).

 !item [sort_mode]  Specifies the sorting when using the FSLX functions (the
            parameter is ignored when using Af_select or Af_first_fsel
            and Af_next_fsel).

 !item [multi]      Indicates whether several files can be selected (= TRUE)
            (if the system supports this) or whether only one file can
            be selected (= FALSE)

 !item [window]     Contains either NULL or NIL for the modal file selector or
            a window to which the non-modal file selector should report
            the selected files using the AS_FILESELECT message.
!end_xlist

(!B)Note:(!b) The function uses the following strategy:

!begin_itemize
   !item If the FSLX functions (MagiC) are available, they are used via the
     Ash_fileselect function.

   !item Otherwise, depending on the multi parameter, either Af_select or
     the combination Af_first_fsel and Af_next_fsel is used.
!end_itemize

The return value is a linear list of the selected file names. The value
NULL signals an error.

This list can also be empty. Then either 'Cancel' was selected or the
non-modal window dialog was opened.

When the non-modal file selector is called, an empty list is always
returned. A linear list of the selected files (or NULL in the event of
an error) is sent to the transferred window using the AS_FILESELECT
message.

(!B)Note:(!b) As with all functions that return a linear list, the linear
list supplied by Af_fileselect must be deleted by the caller via
Alu_delete! However, the list reported by the non-modal file selector
via AS_FILESELECT is automatically released by (!I)ACSpro(!i).

(!B)Important:(!b) The following points are important for specifying
the extensions:

!begin_itemize
   !item The extensions to be used can be grouped together.

   !item The extensions can be grouped, with the groups representing
     different alternatives that can be activated by the user.

   !item The extensions of a group are separated from each other with
     ',', the group is terminated with a null byte '\0'.

   !item At the end of the extension groups, two null bytes are (!I)always(!i)
     expected.

   !item If the FSLX functions are available, they will be prepared and
     used. The first extension group is preset, the others can then
     alternatively be activated by the user.

   !item If the FSLX functions are available, the extension "*" is added
     to the end for the selection of all files, if this "special
     extension" does not already appear in one of the extension groups.

   !item If no FSLX functions are available and the file selection is
     carried out using Af_select or Af_first_fsel and Af_next_fsel,
     the first extension is used by the first extension group.

   !item If there is no valid extension, "*" is used for the FSLX functions
     and "*.*" For Af_selet or Af_first_fsel and Af_next_fsel.
!end_itemize

(!B)Example:(!b) The (!I)GUI editor(!i) transfers the C string
"ACS,acs\0RSC,rsc\0\0" to open the ACS files. These are two groups
of extensions. The first group allows all files of the form "*.ACS"
and "*.acs", the second group allows all files with the pattern
"*.RSC", "*.rsc".

!begin_itemize
   !item If the FSLX functions are available, three groups are created:
     "*.ACS, *.acs", "*.RSC, *.rsc" and "*".

   !item If the "old" ;-) functions are used, the extension "*.ACS" is used.
!end_itemize

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Ash_fileselect, Af_first_fsel, Af_next_fsel, Af_select
!end_enumerate

!end_node


!begin_node Af_first

 !begin_blist [Definition:]
 !item [Summary:]           Find the first file in a folder

 !item [Category:]          File functions

 !item [C:]                 char *Af_first( const char *start, A_FileList
                    *fileinfo );

 !item [Pascal:]            Function Af_first( start: Pointer;
                                   fileinfo: (!link [A_FileListPtr] [A_FileList])
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_first function opens, if it exists, the 'start' folder and
determines the first file from it. If possible, long file names are
supported and no assumptions are made about upper/lower case.

In the event of an error (folder does not exist, no file in the folder)
NULL is returned, otherwise a pointer to the first file is returned.

(!B)Attention:(!b) (!I)Since static data must be used internally, this function 
cannot be multithreading-proof! In general, the Af_readdir function
should be preferred!(!i)

(!B)Note:(!b) All files should be processed with Af_next, since memory is
requested internally, which is released again in Af_next at the end
of processing!

(!B)Note:(!b) This function is only available for compatibility reasons
and will disappear in one of the next versions. The functionality
will then be taken over entirely by Af_readdir.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_next, Af_readdir
!end_enumerate

!end_node


!begin_node Af_first_fsel

 !begin_blist [Definition:]
 !item [Summary:]           Multi-file selection, return the first file

 !item [Category:]          File functions

 !item [C:]                 char *Af_first_fsel( char *title, char *path,
                                   char *ext );

 !item [Pascal:]            Function Af_first_fsel(
                                   title, path, ext: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_first_fsel function enables the user to select multi files,
whereby the call is made completely in the same way as Af_select.
The 'title' is displayed from TOS 1.04 or on SELECTRIC or BoxKite.
The display is limited to 'ext' files. 'path' should be selected
long enough (128 characters), since the selected file name is stored
in it, it can also be pre-assigned.

NULL or NIL is returned on termination, otherwise the valid pointer
to 'path'. If several files were selected, the first file is returned
and with Af_next_fsel the remaining files can be determined (until
NULL or NIL is returned).

(!B)Attention:(!b) (!I)Since static data must be used internally, this
function cannot be multithreading-proof!(!i)

(!B)Note:(!b) Please pass 'path' in the form "C:\abc\file.dat".

(!B)Note:(!b) Af_fileselect should be used instead of this function.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item A_fileselect, Af_fileselect, Af_next_fsel, Af_select
!end_enumerate

!end_node


!begin_node Af_freedir

 !begin_blist [Definition:]
 !item [Summary:]           Release the file list

 !item [Category:]          File functions

 !item [C:]                 void Af_freedir( A_FileList *list );

 !item [Pascal:]            Procedure Af_freedir( list: (!link [A_FileListPtr] [A_FileList]) );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_freedir function releases the file list from Af_readdir.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_readdir
!end_enumerate

!end_node


!begin_node Af_length

 !begin_blist [Definition:]
 !item [Summary:]           Determine existence and length of a file

 !item [Category:]          File functions

 !item [C:]                 long Af_length( const char *file );

 !item [Pascal:]            Function Af_length( file: Pointer ) : Longint;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_length function determines the length of the transferred file.
If this file length or the folder cannot be determined (!), -2 is
returned.

If it is a folder, -1 is returned.

This function can be used to determine the existence of a file or
folder. If the file or folder exists, the return value is >=-1.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions
!end_enumerate

!end_node


!begin_node Af_next

 !begin_blist [Definition:]
 !item [Summary:]           Find the next file in a folder

 !item [Category:]          File functions

 !item [C:]                 char *Af_next( A_FileList *fileinfo );

 !item [Pascal:]            Function Af_next( fileinfo: (!link [A_FileListPtr] [A_FileList])) :
                    Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

After a file has been read from a folder with Af_first, all other
files can be determined one after the other with the Af_next function.

If there is no other file, NULL or NIL is returned.

(!B)Attention:(!b) (!I)Since static data must be used internally, this function
cannot be multithreading-proof! In general, the Af_readdir function
should be preferred!(!i)

(!B)Note:(!b) This function is only available for reasons of compatibility
and will disappear in one of the next versions, the functionality will
then be taken over entirely by Af_readdir.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_first, Af_readdir
!end_enumerate

!end_node


!begin_node Af_next_fsel

 !begin_blist [Definition:]
 !item [Summary:]           Get the next file after a multi-file selection

 !item [Category:]          File functions

 !item [C:]                 char *Af_next_fsel( void );

 !item [Pascal:]            Function Af_next_fsel : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

After the first file has been determined using Af_first_fsel (and
only then!), The Af_next_fsel function can be used to collect all
other selected files from the multi-file selection.

NULL or NIL is returned if no further file was originally selected,
otherwise a pointer to the name.

(!B)Important:(!b) Not only for reasons of consistency, but also to free up
the memory requested for the multi-file selection, all files should
be read out with this function!

(!B)Attention:(!b) (!I)Since static data must be used internally, this function
cannot be multithreading-proof!(!i)

(!B)Note:(!b) Af_fileselect should be used instead of this function.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item A_fileselect, Af_fileselect, Af_first_fsel, Af_select
!end_enumerate

!end_node


!begin_node Af_parseCmdLine

 !begin_blist [Definition:]
 !item [Summary:]           Find the next file in a folder

 !item [Category:]          File functions

 !item [C:]                 ULinList *Af_parseCmdLine( char *file_string )

 !item [Pascal:]            Function Af_parseCmdLine(
                                   file_string: Pointer
                                ) : ULinListPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_parseCmdLine function reads a command line and stores the
individual parameters one after the other in a linear list. Quoting
is taken into account in the same way as Af_unquote.

If NULL or NIL is returned, an error has occurred.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_unquote
!end_enumerate

!end_node


!begin_node Af_quote

 !begin_blist [Definition:]
 !item [Summary:]           If necessary, quote a filename

 !item [Category:]          File functions

 !item [C:]                 char *Af_quote( char *dest, char *source );

 !item [Pascal:]            Function Af_quote( dest, source: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_quote function prepares the file name passed in 'source' to
'dest' so that it can be passed on to other applications - e.g. via
VA_START, Pexec or similar.

If there are no spaces, tabs or quote characters in the file name
(this includes the (optional) path), the transferred string is not
changed.

(!B)Note:(!b) The function is specially optimized for the case where
'dest' is equal to 'source'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_unquote
!end_enumerate

!end_node


!begin_node Af_readdir

 !begin_blist [Definition:]
 !item [Summary:]           Create a list of all files or subfolders in a
                    directory

 !item [Category:]          File functions

 !item [C:]                 A_FileList *Af_readdir( char *start );

 !item [Pascal:]            Function Af_readdir( start: Pointer ) :
                    (!link [A_FileListPtr] [A_FileList]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_readdir function provides the contents of a directory in a list.
This saves unnecessary routines and structures for reading a folder.
If available, Af_readdir uses the routines Dopendir, Dclosedir and
Dxreaddir (or Dreaddir and Fxattr if Dxreaddir does not exist).

The pointer to the first list element is returned as the return value.
If an error occurred, NULL or NIL is returned.

The file list should be released at the end with Af_freedir.

(!B)Note:(!b) In one of the next versions, the list will be converted into a
linear, unsorted list ULinList. This allows a much better processing
of the data to be achieved, since ULinList offers some convenient
service routines that can be used immediately.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_first, Af_freedir, Af_next
!end_enumerate

!end_node


!begin_node Af_select

 !begin_blist [Definition:]
 !item [Summary:]           Select a file using the file selection box

 !item [Category:]          File functions

 !item [C:]                 char *Af_select( char *title, char *path, char
                    *ext );

 !item [Pascal:]            Function Af_select(
                                   title, path, ext: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_select function opens the file selection box. The title is
obtained from TOS 1.04 or displayed with SELECTRIC or BoxKite. The
selection is limited to files with the type 'ext', e.g. 'PRG', 'ACS'.
'path' is supplemented by the selected name of the file and returned
as a value. 'Cancel' returns NULL. From version 2.2, only one path can
be selected.

(!B)Important:(!b) 'path 'should be large enough to accommodate all paths
(>80 bytes). The (old) file name is automatically removed.

(!B)Note:(!b) Please pass 'path' in the form "C:\abc\file.dat".

(!B)Note:(!b) Af_fileselect should be used instead of this function.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item A_fileselect, Af_fileselect, Af_first_fsel, Af_next_fsel
!end_enumerate

!end_node


!begin_node Af_unquote

 !begin_blist [Definition:]
 !item [Summary:]           If necessary, unquote a filename

 !item [Category:]          File functions

 !item [C:]                 char *Af_unquote( char *dest, char *source );

 !item [Pascal:]            Function Af_unquote( dest, source: Pointer ) :
                    Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Af_unquote function, as a counterpart to Af_quote, restores the
transferred file name if it happens to be quoted.

The Af_unquote function prepares the file name passed in 'source',
usually received via command line or VA_START, into 'dest' so that
it can be used to open the file.

If after the removal of leading spaces the first character is not a
quote character (at the moment these are the characters " and ') the
filename remains unchanged. Otherwise the substring between the quote
character and the second occurrence of the quote character is copied to
'dest'. If the filename contains quote characters, they must appear
twice in a row, this is combined to form a quote character.

(!B)Note:(!b) The function is specially optimized for the case where
'dest' is equal to 'source'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Af_quote, Af_parseCmdLine
!end_enumerate

!end_node


!begin_node AGetObjText

 !begin_blist [Definition:]
 !item [Summary:]           Data type for the BubbleGEM Help (message
                    AS_GETBUBBLE)

 !item [Category:]          (!link [Structures] [The Structures])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   int16 obnr;
   char *text;
} AGetObjText;
!end_sourcecode

 !item [Pascal:]    
!begin_sourcecode
AGetObjTextPtr = ^AGetObjText;
AGetObjText = Record
   obnr: Integer;
   text: Pointer;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

!end_node


!begin_node Aic_create

 !begin_blist [Definition:]
 !item [Summary:]           Create a new icon

 !item [Category:]          Icon functions

 !item [C:]                 ICONBLK *Aic_create( const ICONBLK *icon );

 !item [Pascal:]            Function Aic_create( icon: ICONBLKPtr ) :
                    ICONBLKPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aic_create creates a copy of the icon. The image data
is (!B)not(!b) duplicated, but only referenced. The text is created with
Ast_create.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Icon functions

  !item Aic_delete

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Aic_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete an icon

 !item [Category:]          Icon functions

 !item [C:]                 void Aic_delete( ICONBLK *icon );

 !item [Pascal:]            Procedure Aic_delete( icon : ICONBLKPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aic_delete frees up the memory space of the ICONBLK
structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Icon functions

  !item Aic_create

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Aim_create

 !begin_blist [Definition:]
 !item [Summary:]           Create a new image

 !item [Category:]          Image functions

 !item [C:]                 BITBLK *Aim_create( const BITBLK *bitblk );

 !item [Pascal:]            Function Aim_create( bitblock: BITBLKPtr ) :
                    BITBLKPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aic_create creates a copy of the picture. The actual
image data is (!B)not(!b) duplicated, but only referenced.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Image functions

  !item Aim_delete
!end_enumerate

!end_node


!begin_node Aim_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete an image

 !item [Category:]          Image functions

 !item [C:]                 void Aim_delete( BITBLK *bitblock );

 !item [Pascal:]            Procedure Aim_delete( bitblock : BITBLKPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aim_delete function frees the memory space of the BITBLK structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Image functions

  !item Aim_create
!end_enumerate

!end_node


!begin_node alert_name

 !begin_blist [Definition:]
 !item [Summary:]           Window title for modal alert dialogs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char *alert_name;

 !item [Pascal:]            alert_name: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable alert_name contains an alternative window title for the
modal alert dialogs.

So that not only the specified window titles appear in modal alert
dialogs Awi_alert, you can use this variable (as needed) to enter
a pointer to a new title. If NULL or NIL is entered here, the titles
preset at Awi_alert are used.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, alert_str, Awi_alert
!end_enumerate

!end_node


!begin_node alert_str

 !begin_blist [Definition:]
 !item [Summary:]           Display an alert box with parameters

 !item [Category:]          Other functions

 !item [C:]                 int16 alert_str( const char *alert, const char
                    *para );

 !item [Pascal:]            Function alert_str( alert, para: Pointer ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The alert_str function displays an alert box using the Awi_alert
function. The first button is always the default button. The number
of the selected button is returned. As a special feature, the character
combination '%s' is replaced by the second parameter 'para'. This means
that alert boxes can have parameterized text, e.g. filenames.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item Awi_alert, Awi_dialog, Awi_modal
!end_enumerate

!end_node


!begin_node Alu_create

 !begin_blist [Definition:]
 !item [Summary:]           Generate a linear list

 !item [Category:]          Unsorted, double-linked, linear list

 !item [C:]                 ULinList *Alu_create( void );

 !item [Pascal:]            Function Alu_create : ULinListPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Alu_create function creates a linear, double-linked list and
initializes the allocated ULinList structure, which it returns.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Unsorted, double-linked, linear list

  !item ULinList, Alu_delete
!end_enumerate

!end_node


!begin_node Alu_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete a linear list

 !item [Category:]          Unsorted, double-linked, linear list

 !item [C:]                 void Alu_delete( ULinList *liste );

 !item [Pascal:]            Procedure Alu_delete( liste: (!link [ULinListPtr] [ULinList]) );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Alu_delete function deletes a linear list created with Alu_create
and tries to release the managed data using the function referenced
in ULinList.freeElem.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Unsorted, double-linked, linear list

  !item ULinList, Alu_create
!end_enumerate

!end_node


!begin_node Akt_GetExportCount

 !begin_blist [Definition:]
 !item [Summary:]           Determine the maximum index of the export filter

 !item [Category:]          KEYTAB Functions

 !item [C:]                 int16 Akt_GetExportCount( void );

 !item [Pascal:]            Function Akt_GetExportCount : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Akt_GetExportCount function supplies the maximum index of the
export filter. The export filters convert characters from the Atari
character set to other character sets. The filters of the number 0..AktGetExportCount() (incl.) are available.

(!B)Note:(!b) If KeyTab is not available, the result is 0. In this
case, the conversion functions return the input (in the Atari
character set).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item KEYTAB Functions

  !item Akt_GetKeyTab
!end_enumerate

!end_node


!begin_node Akt_getKeyTab

 !begin_blist [Definition:]
 !item [Summary:]           Get the KEYTAB (!link [Cookie] [The Cookie Jar]) Structure

 !item [Category:]          KEYTAB Functions

 !item [C:]                 KEYT *Akt_getKeyTab( void );

 !item [Pascal:]            Function Akt_getKeyTab : PKEYT;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Akt_getKeyTab provides a pointer to the KEYTAB structure
KEYT, which KEYTAB makes available via a (!link [Cookie] [The Cookie Jar]). If NULL or NIL is
returned, the (!link [Cookie] [The Cookie Jar]) is either not available (KEYTAB not  installed), or
the "magic value" in the structure is incorrect, so that the structure
is invalid.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item KEYTAB Functions
!end_enumerate

!end_node


!begin_node Ame_namefix

 !begin_blist [Definition:]
 !item [Summary:]           Customize the menu title

 !item [Category:]          Menu functions

 !item [C:]                 void Ame_namefix( OBJECT *menu );

 !item [Pascal:]            Procedure Ame_namefix( menu: ACSTreePtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The positions of the menu titles depend on the length of the menu
text. This routine adjusts these values and takes into account the
real text lengths, which are adjusted for leading and trailing spaces.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Menu functions
!end_enumerate

!end_node


!begin_node Ame_popup

 !begin_blist [Definition:]
 !item [Summary:]           Display the object tree as a popup

 !item [Category:]          Menu functions

 !item [C:]                 int16 Ame_popup( Awindow *window, OBJECT *popup,
                             int16 x, int16 y );

 !item [Pascal:]            Function Ame_popup(
                                   window: (!link [AwindowPtr] [Awindow]); popup:
                    ACSTreePtr;
                                   x, y: Integer
                                ): Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ame_popup represents a popup menu on the screen and
lets the user select an entry. The object number of the selected
popup entry is returned.

The popup menu is invoked. Any entered click routines are started.
Alternatively, the return value can be evaluated. This mode is
interesting for simple yes/no decisions.

(!I)Remarks:(!i)

 x, y  describe the start position of the popup. Alternatively,
       -1 can be specified, then the popup appears at the mouse
       position.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Menu functions
!end_enumerate

!end_node


!begin_node Ame_strpopup

 !begin_blist [Definition:]
 !item [Summary:]           Display the object tree as a popup

 !item [Category:]          Menu functions

 !item [C:]                 char *Ame_strpopup( Awindow *window, char *pstr,
                             char *chk, int16 width, int16 x, int16 y);

 !item [Pascal:]            Function Ame_strpopup(
                                   window: (!link [AwindowPtr] [Awindow]); pstr, chk:
                    Pointer;
                                   width, x, y: Integer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ame_strpopup displays a popup menu on the screen described
by a string and lets the user select an entry. The partial string of
the passed string which matches the selected popup entry is returned.

The pop-up menu is determined by the given string 'pstr'. Entries are
delimited with '|'. Submenus are described by square brackets '[..]'.
The first entry is then the title in the calling popup for the submenu.
This hierarchy can be nested as required.

char *erg;
char *popup="Red|"
         "[Yellow|Light Yellow|Normal Yellow|Green Yellow]|"
         "[Green|Watch out!|Normal Ride|Full Throttle]";

erg = Ame_strpopup(ACSblk->ev_window, popup, popup, 200, -1, -1);

represents the following popup:


!image (!IMAGES)cyclerot.img


The behavior can be tested in the (!I)GUI editor(!i) with the Userdef-Cycle
object.

(!I)Remarks:(!i)

 chk   The string 'chk' should be a substring of the 'pstr'. The
       pop-up entry that begins with 'chk' is marked with the
       CHECKED flag. If e.g. chk = pstr applies, the first entry
       gets the checkmark.

 x, y  describes the start position of the popup. Alternatively,
       -1 can be specified, then the popup appears at the mouse
       position.

The beginning of the selected substring of 'pstr' is returned. If
nothing is selected, NULL or NIL is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Menu functions
!end_enumerate

!end_node


!begin_node Amouse

!label AmousePtr
 !begin_blist [Definition:]
 !item [Summary:]           Specification of the mouse form

 !item [Category:]          (!link [Structures] [The Structures])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   int16 number;
   MFORM *form;
} Amouse;
!end_sourcecode

 !item [Pascal:]     
!begin_sourcecode
AmousePtr = ^Amouse;
Amouse = RECORD
   number: Integer;
   form: MFORMPtr;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The description of the mouse form is contained in this structure.
The numbers 0 to 7 indicate the mouse shapes predefined byhe AES.
In those cases, the form component must contain NULL or NIL.  For
user defined mouse shapes, number should have the value of 255 and
then form must point to a valid description of the mouse shape.

!end_node


!begin_node Amo_busy

 !begin_blist [Definition:]
 !item [Summary:]           Set waiting mouse shape ("Bee"))

 !item [Category:]          Mouse operations

 !item [C:]                 void Amo_busy( void );

 !item [Pascal:]            Procedure Amo_busy;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Amo_busy function sets the waiting mouse shape, usually the bee.
The number of calls is counted.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Mouse operations

  !item Amo_unbusy
!end_enumerate

!end_node


!begin_node Amo_hide

 !begin_blist [Definition:]
 !item [Summary:]           Hide or turn off the mouse pointer

 !item [Category:]          Mouse operations

 !item [C:]                 void Amo_hide( void );

 !item [Pascal:]            Procedure Amo_hide;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Amo_hide function hides the mouse pointer.

(!I)The number of calls is counted.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Mouse operations

  !item Amo_show
!end_enumerate

!end_node


!begin_node Amo_new

 !begin_blist [Definition:]
 !item [Summary:]           Set mouse shape

 !item [Category:]          Mouse operations

 !item [C:]                 void Amo_new( Amouse *mouse );

 !item [Pascal:]            Procedure Amo_new( mouse: AmousePtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Amo_new function sets a new mouse shape. The mouse shapes are
set automatically by (!I)ACSpro(!i). The mouse shape set within a
routine is retained at most until it returns to the main loop.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Mouse operations
!end_enumerate

!end_node


!begin_node Amo_show

 !begin_blist [Definition:]
 !item [Summary:]           Make the mouse pointer visible or
                    cancel a call to Amo_hide

 !item [Category:]          Mouse operations

 !item [C:]                 void Amo_show( void );

 !item [Pascal:]            Procedure Amo_show;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Amo_show function makes the mouse visible again after all Amo_hide
calls are compensated for.

(!I)The number of calls is counted.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Mouse operations

  !item Amo_hide
!end_enumerate

!end_node


!begin_node Amo_unbusy

 !begin_blist [Definition:]
 !item [Summary:]           Remove the waiting mouse shape or
                    cancel a call to Amo_busy

 !item [Category:]          Mouse operations

 !item [C:]                 void Amo_unbusy( void );

 !item [Pascal:]            Procedure Amo_unbusy;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Amo_unbusy function cancels the effect of an Amo_busy call.
Once you leave the busy state, the previous mouse form appears.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Mouse operations

  !item Amo_busy
!end_enumerate

!end_node


!begin_node AOBJECT

 !begin_blist [Definition:]
 !item [Summary:]           The extended Object AOBJECT

 !item [Category:]          (!link [Variables] [The Variables])

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The extended object is one of the key points of (!I)ACSpro(!i). The type
has the same size in bytes as the AES type OBJECT or AESOBJECT.
The component ob_flags is also in the same place. (!I)ACSpro(!i) generates
object trees that are always just behind a normal OBJECT of this
AOBJECT when Click- & Drag routines belong to the object.

!begin_blist [Kurzbeschreibung:]
 !item [C:]         
!begin_sourcecode
typedef struct
{
   Aaction click;
   Aaction drag;
   int16 ob_flags;
   int16 key;
   void *userp1;
   void *userp2;
   int16 mo_index;
   int16 type;
} AOBJECT;
!end_sourcecode

 !item [Pascal:]    
!begin_sourcecode
AOBJECTPtr = ^AOBJECT
AOBJECT = RECORD
   click: Aaction;
   drag: Aaction;
   ob_flags: Word;
   key: Word;
   userp1: Pointer;
   userp2: Pointer;
   mo_index: Integer;
   aob_type: Integer;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

!begin_xlist [userp1, userp2]
!label AOBJECT.click
 !item [click]           Points to the routine that performs the action.

!label AOBJECT.drag
 !item [drag]            Contains the pointer to the routine that
                 handles the drag operation for the object.

!label AOBJECT.ob_flags
 !item [ob_flags]        The flag AEO is set. Then this flag distringuishes
                 between the types OBJECT or AESOBJECT and AOBJECT
                 within the object tree.  If the object is also the
                 last object in the tree, the LASTOB flag must also
                 be set.  Other flags have no meaning and should be
                 deleted.

!label AOBJECT.key
 !item [key]             Contains the description of the keystroke which
                 the object reacts to. The key code is encoded as a
                 NKCC code

!label AOBJECT.userp1
!label AOBJECT.userp2
 !item [userp1, userp2]  These are user defined pointers. These values are
                 only set for system defined values of type.

!label AOBJECT.mo_index
 !item [mo_index]        The lower 5 bits describe the mouse shape index that
                 should be used when the mouse is over the object.
                 The upper bits are reserved.  An index of 0 means
                 the mouse form is taken from the parent object.

!label AOBJECT.type
 !item [type]            Describes the type of the extended object of which
                 there are many predefined (!link [Drag Types] [Predefined Drag types]). The accepting
                 (!link [Drag Routine] [Click Routine & Drag Routine]) can determine whether and how it will
                 process this object.  At the same time, the meaning
                 of the user pointer is also determined.
!end_xlist

!end_node


!begin_node Aob_alias

 !begin_blist [Definition:]
 !item [Summary:]           Forward a click event

 !item [Category:]          Object functions

 !item [C:]                 void Aob_alias( void );

 !item [Pascal:]            Procedure Aob_alias;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aob_alias function is a prepared click routine. It passes the
selection on to the object whose number is in userp1. Typecasting
allows the value to be set in the (!I)GUI editor(!i), in Pure-C 
e.g. '(void *) OK_BUT'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions
!end_enumerate

!end_node


!begin_node Aob_create

 !begin_blist [Definition:]
 !item [Summary:]           Create and initialize an object tree

 !item [Category:]          Object functions

 !item [C:]                 OBJECT *Aob_create( const OBJECT *parent );

 !item [Pascal:]            Function Aob_create( parent: ACSTreePtr ) :
                    ACSTreePtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aob_create function creates a copy of the parent object tree
and returns the pointer to it. If the flag AOS_CONST is set in the
sub-objects, the ob_spec structures are only referenced and not
copied.

Userdefs contained are initialized with AUO_CREATE, provided a
service routine has been defined for them in ub_serv.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_delete
!end_enumerate

!end_node


!begin_node Aob_delete

 !begin_blist [Definition:]
 !item [Summary:]           Release an allocated object tree

 !item [Category:]          Object functions

 !item [C:]                 void Aob_delete( OBJECT *object );

 !item [Pascal:]            Procedure Aob_delete( object : OBJECTPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_delete releases the object tree. But the ob_spec
structures are not released for sub-objects that have the flag
AOS_CONST, since they are only referenced.

Userdefs included are ended with AUO_TERM, provided a service
routine has been defined for them in ub_serv.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_create
!end_enumerate

!end_node


!begin_node Aob_findflag

 !begin_blist [Definition:]
 !item [Summary:]           Search for an object with certain flags

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_findflag(OBJECT *obj, int16 obnr,
                                int16 flag );

 !item [Pascal:]            Function Aob_findflag(
                                   obj: ACSTreePtr; obnr, flag:
                    Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_findflag searches in the object tree obj from the
object obnr for the next object for which the (!link [ob_flags] [AOBJECT]) and flag is
ANDed and the result is not 0. When querying for the first time,
you should set obnr to -1. If no object has this flag (anymore),
-1 is returned. This routine follows the hierarchy.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_up
!end_enumerate

!end_node


!begin_node Aob_fix

 !begin_blist [Definition:]
 !item [Summary:]           Convert character to pixel coordinates

 !item [Category:]          Object functions

 !item [C:]                 void Aob_fix( OBJECT *object );

 !item [Pascal:]            Procedure Aob_fix( object: ACSTreePtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_fix converts the character coordinates of the
object tree object into pixel based coordinates. The first object
(number 0) receives the status AOS_FIXED. If the tree already
has this status, the routine returns immediately.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions
!end_enumerate

!end_node


!begin_node Aob_flags

 !begin_blist [Definition:]
 !item [Summary:]           Set and delete flags in ob_flags

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_flags( Awindow *window, int16 obnr,


 !item [Pascal:]            Function Aob_flags(
                                   window: (!link [AwindowPtr] [Awindow]);
                                   obnr, flag, setflag: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_flags sets (setflag=TRUE) or clears (setflag=FALSE)
the Flags flag in the object with the number obnr of the Window window.
Objects of the toolbar are represented as usual by the OR operation
with A_TOOLBAR.

Example from the (!I)ACSpro(!i)-(!I)GUI-Editor(!i):

      Aob_state(window, EDMM_ACCMEN, DISABLED, !is_main);
      Aob_flags(window, EDMM_ACCMEN, EDITABLE, is_main);

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_state
!end_enumerate

!end_node


!begin_node Aob_gettext

 !begin_blist [Definition:]
 !item [Summary:]           Read text from object

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_gettext( const OBJECT *ob,
                                const int16 obnr, char *text );

 !item [Pascal:]            Function Aob_gettext (ob: ACSTreePtr;
                                   obnr: Integer; text: Pointer):
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

With the help of the function Aob_gettext you can read the Text
after 'text' from an object 'obnr' of the object tree 'ob' (from
version 2.3 also from icons). If NULL or NIL is passed for 'text',
no text is returned, only the return value (the length of the read
text) is determined. This can be useful for dynamic text handling.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_puttext
!end_enumerate

!end_node


!begin_node Aob_offset

 !begin_blist [Definition:]
 !item [Summary:]           Coordinate calculation of an object

 !item [Category:]          Object functions

 !item [C:]                 void Aob_offset( Axywh *offset, OBJECT *object,
                             int16 obnr );

 !item [Pascal:]            Procedure Aob_offset( offset: AxywhPtr;
                                   object: ACSTreePtr; obnr: Integer);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_offset calculates the coordinates of the object obnr
of the object tree object. The values are returned in the structure
offset. Statuses such as OUTLINED and SHADOWED are taken into account
and so, if the absolutely correct dimensions of the object rectangle
needs to be determined, they should be briefly hidden and then restored
again.

The Userdefs that are in the (!link [ACS.LIB] [The Pure-C Library]) are taken into account.

If you want to use this routine to determine the rectangle for a
(!link [Awindow.redraw] [Awindow]) call, you have to correct the x and y coordinates
by the object tree window coordinates:

     for Pure-C:

     offset.x += window.wi_work.x;
     offset.y += window.wi_work.y;

     for Pure-Pascal:

     offset^.x := offset^.x + window^.wi_work.x;
     offset^.x := offset^.x + window^.wi_work.x;

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions
!end_enumerate

!end_node


!begin_node Aob_printf

 !begin_blist [Definition:]
 !item [Summary:]           Formatted output in object

 !item [Category:]          Object functions

 !item [C:]                 void Aob_printf( const OBJECT *ob, const int16
                    obnr,
                             const char *format, ... );

 !item [Pascal:]            The function is unfortunately not
                    available for Pure-Pascal due to the
                    variable arguments.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_printf writes a formatted text in the object 'obnr'
of the object tree 'ob', which can be formatted analogously to printf.
A buffer of 1024 characters in length is available for this.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_scanf
!end_enumerate

!end_node


!begin_node Aob_puttext

 !begin_blist [Definition:]
 !item [Summary:]           Write text in object

 !item [Category:]          Object functions

 !item [C:]                 void Aob_puttext( const OBJECT *ob,
                             const int16 obnr, char *text );

 !item [Pascal:]            Procedure Aob_puttext( ob: ACSTreePtr;
                                   obnr: Integer; text: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_puttext enables the insertion of text 'text' into
the object 'obnr' of the object tree 'ob'.

All existing object types are taken into account (from version 2.3
also icons), but there are details that should be noted: For technical
reasons, G_BUTTON, G_STRING and G_TITLE 'text' is simply written into
the object, so you need to know the maximum number of letters there
that may be entered - going over the length leads to at best memory
block errors! With G_USERDEF (many objects provided by (!I)ACSpro(!i)) the
'text' is entered in the AUSERBLK ub_ptr1. So if you have your own
Userdef you should make sure to enter visible texts there (where
appropriate, the A_editor enters other data here!)! The TextLength is
irrelevant here, it is created dynamically. For the remaining objects,
the TextLength is automatically limited to a maximum defined in the
object mask.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_gettext
!end_enumerate

!end_node


!begin_node Aob_restore

 !begin_blist [Definition:]
 !item [Summary:]           Copy the saved rectangle back to the screen

 !item [Category:]          Object functions

 !item [C:]                 void Aob_restore( MFDB *save, Axywh *rect );

 !item [Pascal:]            Procedure Aob_restore( save: MFDBPtr; rect:
                    AxywhPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aob_restore function writes the rectangle saved with Aob_save
back to the rect rectangle.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_save
!end_enumerate

!end_node


!begin_node Aob_save

 !begin_blist [Definition:]
 !item [Summary:]           Save the rectangle on the screen

 !item [Category:]          Object functions

 !item [C:]                 MFDB *Aob_save( Axywh *rect );

 !item [Pascal:]            Function Aob_save( rect: AxywhPtr ) : MFDBPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_save saves the rectangle described by rect.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_restore
!end_enumerate

!end_node


!begin_node Aob_scanf

 !begin_blist [Definition:]
 !item [Summary:]           Read formatted text from object

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_scanf( const OBJECT *ob, const int16
                    obnr,
                                const char *format, ... );

 !item [Pascal:]            The function is unfortunately not
                    available for Pure-Pascal due to the
                    variable arguments.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_scanf reads a formatted text from the object 'obnr'
of the object tree 'ob'. The evaluation is completely analogous to
scanf. A buffer of 1024 characters in length is available for this.
If 'format' is NULL, only the length is determined - see Aob_gettext.

Internally, the routine goes through sscanf and accordingly likes to
fail if the text to be read is empty. Therefore, if the routine sees
that a number should be read in the format string (h,l,d,o,i,u,x in
the format string) and the text is empty, 10 zeros separated by spaces 
(0) are considered as text in advance, so that in this case the desired
zero values (and no waste) are determined in most cases.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_printf
!end_enumerate

!end_node


!begin_node Aob_service

 !begin_blist [Definition:]
 !item [Summary:]           Send message to an object

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_service( OBJECT *tree, int16 obnr,
                             int16 task, void *in_out );

 !item [Pascal:]            Function Aob_service(
                                   tree: OBJECTPtr; obnr, task: int16;
                                   in_out: Pointer
                                ) : MFDBPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_service forwards the transferred message to the
object specified by obnr - the OR operation with A_TOOLBAR is not
necessary here, but it does no harm either, because Aob_service
masks the number with A_MASK for security reasons.

The function carries out some security checks if the flag AB_LAZYEVAL
is deleted in (!link [ACSblk->description->flags] [Adescr]). If these checks fail, the
value FALSE is returned, otherwise you get the result of the UserDef
service routine. If the flag is set, no check is made, but the
service routine is called directly, the result of which is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Awi_observice
!end_enumerate

!end_node


!begin_node Aob_state

 !begin_blist [Definition:]
 !item [Summary:]           Set and delete status bits in ob_state

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_state( Awindow *window, int16 obnr,
                             int16 state, int16 setflag );

 !item [Pascal:]            Function Aob_state(
                                   window: (!link [AwindowPtr] [Awindow]);
                                   obnr, state, setflag: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_state sets (setflag=TRUE) or clears (setflag=FALSE)
the status state in the object with the number of the Window window.
Objects of the toolbar are represented as usual by the OR operation
with A_TOOLBAR.

Example from the (!I)ACSpro(!i)-(!I)GUI-Editor(!i):

      Aob_state(window, EDMM_ACCMEN, DISABLED, !is_main);
      Aob_flags(window, EDMM_ACCMEN, EDITABLE, is_main);

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_flags
!end_enumerate

!end_node


!begin_node Aob_up

 !begin_blist [Definition:]
 !item [Summary:]           Find parent object of a given object

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_up( OBJECT *obj, int16 obnr );

 !item [Pascal:]            Function Aob_up(
                                   obj: ACSTreePtr; obnr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_up finds the object number of the parent object in
obj. Start is the object obnr. If there is no parent object, -1 is
returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Aob_findflag
!end_enumerate

!end_node


!begin_node Aob_visible

 !begin_blist [Definition:]
 !item [Summary:]           Find parent object of a given object

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_visible( OBJECT *tree, int16 obnr );

 !item [Pascal:]            Function Aob_visible(
                                   tree: ACSTreePtr; obnr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aob_visible function checks whether the object identified by
'obnr' is visible in the 'tree' object tree. If there is no connection
between the object and the root of the tree or if one of the parent
objects lying between the object and the root is invisible, the object
is not visible and FALSE is returned, otherwise TRUE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions

  !item Awi_obvisible
!end_enumerate

!end_node


!begin_node Aob_watch

 !begin_blist [Definition:]
 !item [Summary:]           Monitor the object with the mouse button pressed

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_watch( Awindow *window, int16 obnr );

 !item [Pascal:]            Function Aob_watch(
                                   window: (!link [AwindowPtr] [Awindow]); obnr: Integer
                                ) : Boolean;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aob_watch function monitors an object. The obnr object becomes
inverse when the mouse is over it with the button pressed. Otherwise
the object is displayed normally. TRUE is returned if the mouse button
is released over the object, otherwise FALSE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions
!end_enumerate

!end_node


!begin_node Aob_within

 !begin_blist [Definition:]
 !item [Summary:]           Check whether the coordinate is in a rectangle

 !item [Category:]          Object functions

 !item [C:]                 int16 Aob_within( const Axywh *rect,
                                int16 x, int16 y );

 !item [Pascal:]            Function Aob_within(
                                   rext AxywhPtr; x, y: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aob_within checks whether the coordinates 'x, y' are
within the rectangle 'right' (returns TRUE) or not (returns FALSE).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Object functions
!end_enumerate

!end_node


!begin_node Apd_close

 !begin_blist [Definition:]
 !item [Summary:]           Close the top window

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_close( void );

 !item [Pascal:]            Procedure Apd_close;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_close function closes the top window. If it has a lock box,
the routine Awindow.closed is called, otherwise the message AS_TERM
is sent to the window. If successful, the (!link [last open window] [Awi_down]) is brought
up.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK

  !item Awi_down
!end_enumerate

!end_node


!begin_node Apd_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete objects and windows

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_delete( void );

 !item [Pascal:]            Procedure Apd_delete;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_delete function is used for deletion. If any objects are
contained in the selection list, the message AS_DELETE is sent to
the associated window. Otherwise, the message AS_TERM is sent to
the top window, if this is not exactly the root window.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_info

 !begin_blist [Definition:]
 !item [Summary:]           Display information about objects and windows

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_info( void );

 !item [Pascal:]            Procedure Apd_info;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_info function provides information about the selected objects
in the selection list. For this, the message AS_INFO is sent to the
associated window. If the selection list is empty, the routine entered
in ACSblk->ACSaboutme is called.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_list

 !begin_blist [Definition:]
 !item [Summary:]           Open the next window in the list or bring it up

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_list( void );

 !item [Pascal:]            Procedure Apd_list;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_list function opens the next window from the window list
or brings it up if it is already open.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK

  !item Awi_show
!end_enumerate

!end_node


!begin_node Apd_module

 !begin_blist [Definition:]
 !item [Summary:]           Open the module window or bring it up

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_module( void );

 !item [Pascal:]            Procedure Apd_module;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_module function brings the module window up by Awi_show.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_new

 !begin_blist [Definition:]
 !item [Summary:]           Call the installed New routine

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_new( void );

 !item [Pascal:]            Procedure Apd_new;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_new function calls the New routine registered with PUR_DESK
via the AS_NEWCALL message.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Apd_open

 !begin_blist [Definition:]
 !item [Summary:]           Open selected objects or call New routine

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_open( void );

 !item [Pascal:]            Procedure Apd_open;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_open function opens objects. If objects are selected in the
selection list, the message AS_OPEN is sent to the window to which
the selection list belongs. If nothing has been selected, then the
Apd_new function is called.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK

  !item Apd_new
!end_enumerate

!end_node


!begin_node Apd_quit

 !begin_blist [Definition:]
 !item [Summary:]           Exit the Application

 !item [Category:]          The "pure" desktop

 !item [C:]                 void Apd_quit( void );

 !item [Pascal:]            Procedure Apd_quit;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Apd_quit function calls the routine entered in ACSblk->ACSclose
to cause the Application to terminate.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node Aqu_create

 !begin_blist [Definition:]
 !item [Summary:]           Create a queue

 !item [Category:]          Unsorted, double-linked, linear list

 !item [C:]                 Queue *Aqu_create( void );

 !item [Pascal:]            Function Aqu_create : QueuePtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aqu_create function creates a queue and initializes the allocated
queue structure that it returns.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Queue, Aqu_delete
!end_enumerate

!end_node


!begin_node Aqu_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete a linear list

 !item [Category:]          Unsorted, double-linked, linear list

 !item [C:]                 void Aqu_delete( Queue *liste );

 !item [Pascal:]            Procedure Aqu_delete( liste: QueuePtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aqu_delete function deletes a queue created with Aqu_create and
tries to release the managed data using the function referenced in
Queue.freeElem.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Queue, Aqu_create
!end_enumerate

!end_node


!begin_node appexit

 !begin_blist [Definition:]
 !item [Summary:]           Flag whether the application is terminated

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 appexit;

 !item [Pascal:]            appexit: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable appexit shows whether the application is terminated
completely. The message AS_TERM may only remain unprocessed if this
is (!B)not(!b) the case.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk, AS_TERM
!end_enumerate

!end_node


!begin_node appfrom

 !begin_blist [Definition:]
 !item [Summary:]           Path and name of the calling program

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char appfrom[128];

 !item [Pascal:]            appfrom: packed array [1..128] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable appfrom contains the path and name of the calling program
if the caller enters "Para1 Par2 /caller" in the command line

(!I)The variable is only valid if the program is running as an application.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, appname, apppara, apppath, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node application

 !begin_blist [Definition:]
 !item [Summary:]           Flag whether the program is running as an
                    application or an accessory

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 application;

 !item [Pascal:]            application: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The application variable indicates whether the program is running as
an application (TRUE) or as an accessory (FALSE).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node appname

 !begin_blist [Definition:]
 !item [Summary:]           Name and path of the Application

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char appname[128];

 !item [Pascal:]            appname: packed array [1..128] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable appname contains the path and name of the application
as a C string.

(!I)The variable is only valid if the program is running as an application.(!i)

(!I)Cross references:(!i)
!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, apppath, apppara, appfrom, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node apppara

 !begin_blist [Definition:]
 !item [Summary:]           Complete parameter list of the application as C-
                    String

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char apppara[128];

 !item [Pascal:]            apppara: packed array [1..128] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable apppara contains the complete transfer of the parameter
string of the application as a C string.

(!I)The variable is only valid if the program is running as an application.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, appname, apppath, appfrom, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node apppath

 !begin_blist [Definition:]
 !item [Summary:]           Path of the Application as a C-String

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char apppath[128];

 !item [Pascal:]            apppath: packed array [1..128] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable apppath holds the path of the application as a C string.

(!I)The variable is only valid if the program is running as an application.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, appname, apppara, appfrom, basename, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node apterm

 !begin_blist [Definition:]
 !item [Summary:]           Flag for if the program is terminated due
                    to AP_TERM

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 apterm;

 !item [Pascal:]            apterm: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable apterm indicates that an AP_TERM message was received
and the program should now be ended! This message only comes into
effect under MultiTOS, N.AES or MagiC.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node argc

 !begin_blist [Definition:]
 !item [Summary:]           Number of Application parameters

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 argc;

 !item [Pascal:]            This has no meaning in Pure-Pascal.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The argc variable describes the number of command line parameters
passed.

(!B)Attention:(!b) The first value should be the program name, which
unfortunately is not always given on the Atari. For a parameter,
the value of argc is 2!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk, apppara, argv, env
!end_enumerate

!end_node


!begin_node argv

 !begin_blist [Definition:]
 !item [Summary:]           The parameters of the application

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char **argv;

 !item [Pascal:]            This has no meaning in Pure-Pascal.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The argv variable contains all the parameters of the application at
startup. In the first entry, i.e. argv [0], should contain the program
name. Unfortunately, this is not always the case on the Atari (see
also argc). The command line parameters are in the other elements.
The last entry argv [argc] is always NULL.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk, apppara, argc, env
!end_enumerate

!end_node


!begin_node array2xywh

 !begin_blist [Definition:]
 !item [Summary:]           Convert the pair of points to the Axywh structure

 !item [Category:]          Other functions

 !item [C:]                 void array2xywh( Axywh *to, const int16 *from );

 !item [Pascal:]            Procedure array2xywh( to: AxywhPtr; from: Pointer);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The array2xywh function converts an array with two diagonal vertices
into an Axywh structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item xywh2array
!end_enumerate

!end_node


!begin_node Asel

 !begin_blist [Definition:]
 !item [Summary:]           Data structure for the selection list

 !item [Category:]          (!link [Structures] [The Structures])

 !item [C:]         
!begin_sourcecode
typedef struct
{
   Awindow *window;
   int16 maxlen;
   int16 actlen;
   int16 next;
   int16 dragback;
   int16 x, y;
   int16 rx, ry;
   int16 *array;
} Asel;
!end_sourcecode

 !item [Pascal:]      
!begin_sourcecode
Asel = RECORD
   window: AwindowPtr;
   maxlen: Integer;
   actlen: Integer;
   next: Integer;
   dragback:Integer;
   x, y: Integer;
   rx, ry: Integer;
   parray: Pointer;
End;
!end_sourcecode

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The components for this data structure mean:

!begin_xlist [dragback]
 !item [window]    Contains the pointer to the structure of the window to
           which the selected object belongs.  The entry is only
           valide if actlen is greater than 0.

 !item [maxlen]    The maximum number of entries in the list.  For now it is
           limited to 256.

 !item [actlen]    Contains the current number of selected objects.

 !item [next]      This value is required for the Adr_next call.  Before
           you start to query the elements of the list, this value
           must be set to 0.

 !item [dragback]  Normally, the objects from the list are removed when
           they are processed.  The remaining (unprocessed) objects
           snap back to their origin.  This is prevented if the
           Drag Routine sets this value to FALSE.

 !item [x, y]      This value describes the mouse position at the time the
           list was pulled up.

 !item [rx, ry]    The relative distance the mouse has traveled while
           dragging is entered here.

 !item [array]     Points to the array that contains the entries.
!end_xlist

!end_node


!begin_node Ascrp_clear

 !begin_blist [Definition:]
 !item [Summary:]           Delete clipboard data

 !item [Category:]          Clipboard functions

 !item [C:]                 void Ascrp_clear( const char *ext );

 !item [Pascal:]            Procedure Ascrp_clear( ext: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ascrp_clear function deletes clipboard files. The files for
the clipboard data exchange have the name 'SCRAP' with various
clipboard types. A NULL or NIL in 'ext' means that all these files
('SCRAP.*') should be deleted, otherwise the type to be deleted can
be transferred in 'ext'.

If successful, the messages SC_CHANGED and SH_WDRAW are sent to all
accessible applications via Ash_sendall.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Clipboard functions

  !item Ascrp_get, Ascrp_put
!end_enumerate

!end_node


!begin_node Ascrp_get

 !begin_blist [Definition:]
 !item [Summary:]           Read data from the clipboard

 !item [Category:]          Clipboard functions

 !item [C:]                 int16 Ascrp_get( char *ext, void **buffer,
                             long *len );

 !item [Pascal:]            Function Ascrp_get(
                                   ext, buffer, len: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ascrp_get function reads the 'SCRAP' file of the 'ext' type or
the first file that matches the type from the clipboard ("*" for
'ext' is allowed). If NULL or NIL is passed in 'buffer', only the
length of the data is returned in 'len', otherwise the pointer to
the data is in 'buffer'.

If the process runs without errors, TRUE is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Clipboard functions

  !item Ascrp_clear, Ascrp_put
!end_enumerate

!end_node


!begin_node Ascrp_put

 !begin_blist [Definition:]
 !item [Summary:]           Write or append data to the clipboard

 !item [Category:]          Clipboard functions

 !item [C:]                 int16 Ascrp_put( char *ext, void *buffer,
                             long len, int16 append );

 !item [Pascal:]            Function Ascrp_put(
                                   ext, buffer, len: Pointer;
                                   append: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ascrp_put function writes the data from the buffer memory area
of Length len to the clipboard with the data name 'SCRAP' and the
type 'ext'. If the data is to be appended to an existing file
(meaningless with 'IMG' or 'GEM'), append must be set to TRUE.

If the process runs without errors, TRUE is returned and the messages
SC_CHANGED and SH_WDRAW are sent to all accessible applications via
Ash_sendall.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Clipboard functions

  !item Ascrp_clear, Ascrp_get
!end_enumerate

!end_node


!begin_node Ash_CallEdDI

 !begin_blist [Definition:]
 !item [Summary:]           Call an EdDI function

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_CallEdDI( int16 fkt_nr );

 !item [Pascal:]            Function Ash_CallEdDI( fkt_nr: int16 ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_CallEdDI function calls the EdDI function number fkt_nr. The
return value is that of the EdDI function or -1 if no EdDI functions
are available (or something went wrong when reading the (!link [Cookie] [The Cookie Jar]) 'EdDI').

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_error

!label Error Message
 !begin_blist [Definition:]
 !item [Summary:]           Standard error reporting routine

 !item [Category:]          System functions

 !item [C:]                 void Ash_error( int16 mess, void *para );

 !item [Pascal:]            Procedure Ash_error( mess: Integer;
                                 para: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_error function is the standard error output routine. It
should normally not be called directly, but via ACSblk->ACSerror!
An error number can be assigned in 'mess', the optional parameter
'para' is used for an additional data transfer, which can be
particularly interesting for own error routines in ACSblk.

This routine understands the following messages:

!begin_xlist [AE_DEFECTIVE_MEM]
!label AE_GEN
 !item [AE_GEN]            General error.

!label AE_GEN_MEM
 !item [AE_GEN_MEM]        General memory error.

!label AE_OUT_OF_MEM
 !item [AE_OUT_OF_MEM]     Not enough memory.

!label AE_DEFECTIVE_MEM
 !item [AE_DEFECTIVE_MEM]  Access to different memory.

!label AE_RANGE_MEM
 !item [AE_RANGE_MEM]      Bad memory size.

!label AE_ODD_MEM
 !item [AE_ODD_MEM]        Odd memory address.

!label AE_GEN_IO
 !item [AE_GEN_IO]         General input/output error.
!end_xlist

The following error messages accept a filename in 'para':

!begin_xlist [AE_DEFECTIVE_MEM]
!label AE_OPEN_IO
 !item [AE_OPEN_IO]        Failed to open.

!label AE_CREATE_IO
 !item [AE_CREATE_IO]      Creation failed.

!label AE_WRITE_IO
 !item [AE_WRITE_IO]       write error.

!label AE_READ_IO
 !item [AE_READ_IO]        Read error.
!end_xlist

The remaining messages are:

!begin_xlist [AE_DEFECTIVE_MEM]
!label AE_GEN_MOD
 !item [AE_GEN_MOD]        General module error.

!label AE_LOAD_MOD
 !item [AE_LOAD_MOD]       Error loading the module.

!label AE_VER_MOD
 !item [AE_VER_MOD]        Faulty version of the module.

!label AE_MEM_MOD
 !item [AE_MEM_MOD]        Remaining memory cannot be released.

!label AE_PORT
 !item [AE_PORT]           Interface error.

!label AE_COLORS
 !item [AE_COLORS]         Incorrect number of colors (well !?).

!label AE_REZ
 !item [AE_REZ]            Faulty resolution (well, should never
                   actually happen !?).

!label AE_VDI
 !item [AE_VDI]            Bad VDI-Version.

!label AE_AES
 !item [AE_AES]            Bad AES-Version.

!label AE_IMG
 !item [AE_IMG]            Error unpacking the IMG data.

!label AE_DD_WARN
 !item [AE_DD_WARN]        An inconclusive case occurred with the
                   external Drag&Drop.

!label AE_DD_ERR
 !item [AE_DD_ERR]         There was an error with Drag&Drop.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_fileselect

 !begin_blist [Definition:]
 !item [Summary:]           Select a file with the file selector

 !item [Category:]          File functions

 !item [C:]                 ULinList *Ash_fileselect( char *title, int16 x,
                                int16 y, char *path, char *fname,
                                char *patterns, XFSL_FILTER *filter,
                                char *paths, int16 sort_mode,
                                int16 flags, Awindow *meldung );

 !item [Pascal:]            Function Ash_fileselect(
                                   title: Pointer; x, y: int16;
                                   path, fname, patterns: Pointer;
                                   filter: XFSL_FILTER_Ptr;
                                   paths: Pointer;
                                   sort_mode, flags: int16;
                                   meldung: (!link [AwindowPtr] [Awindow])
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_fileselect function calls the (MagiC) file selector. The
parameters mean:

!begin_xlist [patterns]
 !item [title]      Title of the fileselector window

 !item [x, y]       Position of the fileselector window

 !item [path]       Path from which the file selector should start

 !item [fname]      Filename that should be selected first

 !item [patterns]   Masks for file extensions that are to be used.
            Several file extension masks are separated by ','
            and at the end of each extension group there is a
            Null byte. The list is completed with two Null bytes
            (see documentation on the FSLX functions).
 
 !item [filter]     Pointer to filter function

 !item [paths]      List of paths to be shown in the path history

 !item [sort_mode]  Sorting of the files displayed

 !item [flags]      Various settings of the selector.

 !item [meldung]    For the value NULL or NIL the modal file selector is
            called. If a window is transferred here, the non-modal
            file selector transmits the list of the selected files
            to this window via the message AS_FILESELECT.
!end_xlist

For additional information on these values, please refer to the MagiC
developer documentation.

(!B)Note:(!b) The function uses an FSLX file selector. Therefore, if the
FSLX functions are not available, it "refuses to work".

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item File functions

  !item Ash_print, Ash_font

  !item Af_fileselect, Af_first_fsel, Af_next_fsel, Af_select
!end_enumerate

!end_node


!begin_node Ash_font

 !begin_blist [Definition:]
 !item [Summary:]           Choose a character set using the (MAGIC) Font
                    Selector

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_font( const char *title, const int16 x,
                             const int16 y, const int16 font_flag,
                             const int16 button_flag,
                             A_FontSel *font, const char *sample,
                             const char *opt_button, A_FontFkt set,
                             A_FontFkt mark, A_FontFkt opt,
                             void *para, Awindow *window );

 !item [Pascal:]            Function Ash_font(
                                   title: Pointer
                                   x, y, font_flag, button_flag :
                    Integer;
                                   font: A_FontSelPtr;
                                   sample, opt_button: Pointer;
                                   set, mark, opt: A_FontFkt;
                                   para: Pointer; window: (!link [AwindowPtr] [Awindow])
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ash_font

(!B)Note:(!b) The function uses the FNTS selector. Therefore, if the
FNTS functions are not available, it "refuses to work".

Die Parameter bedeuten im Einzelnen:

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions

  !item Ash_fileselect, Ash_print
!end_enumerate

!end_node


!begin_node Ash_getcookie

 !begin_blist [Definition:]
 !item [Summary:]           Request a (!link [Cookie] [The Cookie Jar]) from the (!link [Cookie Jar] [The Cookie Jar])

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_getcookie( long cookie, void *val );

 !item [Pascal:]            Function Ash_getcookie(
                                   cookie: Longint; value: Pointer
                                ): Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_getcookie function searches the (!link [Cookie Jar] [The Cookie Jar]) for an (!link [Cookie] [The Cookie Jar]).
If the return value is TRUE, the cookie was found and the pointer
to the (!link [Cookie] [The Cookie Jar]) value is returned in 'value'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_getenv

 !begin_blist [Definition:]
 !item [Summary:]           Get the value of an environment variable

 !item [Category:]          System functions

 !item [C:]                 char *Ash_getenv( char *name );

 !item [Pascal:]            Function Ash_getenv( name: Pointer ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_getenv function searches for the existence of the 'name'
variable in its own environment. The value of the variable or NULL
or NIL is returned.

The variable "HOME" is known, which should have the path to the
user's own directory. In ACSblk, the variable cfg_path is provided
with this content, if it exists.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_getOSHeader

 !begin_blist [Definition:]
 !item [Summary:]           Get the value of an environment variable.

 !item [Category:]          System functions

 !item [C:]                 SYSHDR *Ash_getOSHeader( void )

 !item [Pascal:]            Function Ash_getOSHeader : SYSHDRPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_getOSHeader function provides a pointer to the SYSHDR
structure (sometimes also called OSHEADER) of the operating system.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_gettimer

 !begin_blist [Definition:]
 !item [Summary:]           Get the value of an environment variable

 !item [Category:]          System functions

 !item [C:]                 UINT32 Ash_gettimer( void );

 !item [Pascal:]            Function Ash_gettimer : UINR32;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_gettimer function returns the value of the 200 Hz timer.
The value is preferably determined by the system (if available),
otherwise the timer is read out "as usual" in supervisor mode.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_module

 !begin_blist [Definition:]
 !item [Summary:]           Reload an (!I)ACSpro(!i) module

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_module( char *path );

 !item [Pascal:]            Function Ash_module( path: Pointer ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ash_module reloads, initializes and starts the module
'path'.

(!B)Note:(!b) Modules have their own version number, which ACS uses to
decide whether it can be loaded (due to a new (!I)ACSpro(!i) version,
this situation may occur). So don't be surprised that a version
you have rejects an old module with a corresponding (!link [Error Message] [Ash_error]).
In this case you have to get a new version of the module.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_nextdd

 !begin_blist [Definition:]
 !item [Summary:]           Identify external Drag&Drop partners

 !item [Category:]          System functions

 !item [C:]                 A_dd *Ash_nextdd( A_dd *act );

 !item [Pascal:]            Function Ash_nextdd( act: A_ddPtr ) : A_ddPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_nextdd function determines the external Drag&Drop partners.
For this purpose 'act' is preset with NULL/NIL and as long as further
calls of this routine do not return a NULL or NIL, you get further
partners in 'act'

(!B)Note:(!b) (!I)This function is only available for reasons of backward
compatibility! By using the variables ListOfApps as (!link [linear list] [ULinList]),
much more convenient options are available!(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions

  !item ListOfApps, ULinList
!end_enumerate

!end_node


!begin_node Ash_NVDICookie

 !begin_blist [Definition:]
 !item [Summary:]           Provide pointer to NVDI's (!link [Cookie] [The Cookie Jar]) structure

 !item [Category:]          System functions

 !item [C:]                 NVDI_STRUC *Ash_NVDICookie( void )

 !item [Pascal:]            Function Ash_NVDICookie : NVDI_STRUCPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ash_NVDICookie returns the entry of the (!link [Cookie] [The Cookie Jar]) 'NVDI'
as a pointer to the NVDI structure NVDI_STRUC. If the (!link [Cookie] [The Cookie Jar]) was
not found or an error occurred, NULL or NIL is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_NVDIDatum

 !begin_blist [Definition:]
 !item [Summary:]           Get NVDI date

 !item [Category:]          System functions

 !item [C:]                 Uint16 Ash_NVDIDatum( void );

 !item [Pascal:]            Function Ash_NVDIDatum : Uint16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_NVDIDatum function returns the NVDI date from the NVDI
structure found from Ash_NVDICookie and so is a "simplification"
(including error checking) of Ash_NVDICookie()->nvdi_datum.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions

  !item Ash_NVDICookie
!end_enumerate

!end_node


!begin_node Ash_NVDIVersion

 !begin_blist [Definition:]
 !item [Summary:]           Determine the NVDI version number

 !item [Category:]          System functions

 !item [C:]                 Uint16 Ash_NVDIVersion( void );

 !item [Pascal:]            Function Ash_NVDIVersion : Uint16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_NVDIVersion function supplies the NVDI version number from the
NVDI structure found from Ash_NVDICookie and so is a "simplification"
(including error checking) of Ash_NVDICookie()->nvdi_version.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions

  !item Ash_NVDICookie
!end_enumerate

!end_node


!begin_node Ash_print

 !begin_blist [Definition:]
 !item [Summary:]           Call the WDIALOG print dialog

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_print( PRN_SETTINGS *setting,
                             int16 x, int16 y, int16 option,
                             char *title, Awindow *window );

 !item [Pascal:]            Function Ash_print(
                                   setting: PRN_SETTINGSPtr;
                                   x, y, option: int16; title:
                    Pointer;
                                   window: (!link [AwindowPtr] [Awindow])
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ash_print

(!B)Note:(!b) The function uses the PDLG print dialogs. Therefore,
if the PDLG functions are not available, it "refuses to work".

The parameters mean in detail:

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions

  !item Ash_fileselect, Ash_font
!end_enumerate

!end_node


!begin_node Ash_prog

 !begin_blist [Definition:]
 !item [Summary:]           Starting external programs

 !item [Category:]          System functions

 !item [C:]                 long Ash_prog( char *path, char *command,
                            char **env );

 !item [Pascal:]            Function Ash_prog(
                                   path, command, env: Pointer
                                ) : LongInt;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_prog function is used to start external programs. The program
in 'path' is started, the environment 'env' and the command line
'command' are passed to it. The latter must have encoded the length
of the commands that actually follow in the first byte. At the start,
the standard path and the standard drive are set to the program.

Under multitasking (no environment transfer possible) an attempt is
made to start the programs via shel_write, whereby MagiC is observed.
The return value is the result of shel_write.

Otherwise, a start is made via Pexec. The types in the environment
variable 'GEMSUFFIX' or the program type are used to determine whether
the program is a GEM or TOS program. In the latter case, the screen is
deleted, the VT52 emulator is initialized, the program is started and
a final key press is waited for.

If this call is made as an accessory, (!I)ACSpro(!i) tries to find an
AV-(!link [Protocol] [External communication]) server and passes  this, if possible, AV_STARTPROG using
this information (e.g. then jinnee or GEMINI will start the program
correctly). At this point, (!I)ACSpro(!i) waits for the AV-(!link [Protocol] [External communication]) server
to report success and returns the result.

If necessary, all windows are closed correctly, opened again on return
(only via Pexec) and any 'WIND_UPDATE' brackets are removed.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_sendall

 !begin_blist [Definition:]
 !item [Summary:]           Send messages to all available Applications

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_sendall( int16 *buff, long type );

 !item [Pascal:]            Function Ash_sendall(
                                   buff: Pointer; type: Longint
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_sendall function sends a GEM message to all available external
Applications, which is coded in 'buff' as a large field of 8 int16s.
(Example: evnt_mesag). You can limit the target to specific Drag&Drop
partners (combine 'type' with DD_XACC or DD_VA via OR) or address all
applications that can be reached in the system using appl_search (set
'type' to -1) provided your TOS supports this call!

If successful, TRUE is returned, otherwise FALSE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate

!end_node


!begin_node Ash_thermometer

 !begin_blist [Definition:]
 !item [Summary:]           Display a progress bar during an action

 !item [Category:]          System functions

 !item [C:]                 int16 Ash_thermometer( const int16 kind,
                             const char *titel, const int16 color,
                             void *data, A_ThermFkt init,
                             A_ThermFkt start, A_ThermFkt cont,
                             A_ThermFkt fkt, A_ThermFkt stop,
                             A_ThermFkt quit );

 !item [Pascal:]            Function Ash_thermometer(
                                   kind: int16; titel: Pointer;
                                   color: Integer; data: Pointer;
                                   init, start, cont, fkt, stop,
                                   quit: A_ThermFkt
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ash_thermometer function provides a progress bar in a window
dialog during a lengthy action ((!link [see example] [Ash_thermometer - Example])). I have called this
functionality "thermometer" for so long, that I don't even remember
why...;-).

The window dialog is influenced by the parameter kind. The following
constants are defined for this, which must be ORed together:

!begin_xlist [THERMO_NONMODAL]
 !item [THERMO_MINIMAL]   Minimal progress bar

 !item [THERMO_TEXT]      Explanatory text is present

 !item [THERMO_CANCEL]    Cancel button is available

 !item [THERMO_PERCENT]   Percentage is available

 !item [THERMO_NONMODAL]  The progress bar runs in a non-modal window
!end_xlist

The parameter color specifies the color of the progress bar, the
value -1 stands for a normal (!link [3D-Button] [Userdef-3D-Button]).

The function pointers init, start, cont, fkt, stop and quit, which
may also be NULL or NIL, represent the action behind the thermometer.
In principle, they form the following program structure:
!begin_sourcecode
     init(data);
     if( start(data) )
     {
        while( cont(data) )
           fkt(data);
        stop(data);
     }
     quit(data);
!end_sourcecode

The functions that are passed here are given a pointer to the data
type A_ThermoData. In this structure, the data transferred in data
and the transferred function pointers are passed on and then the
information important for the progress bar is returned.

(!B)Note:(!b)

!begin_enumerate
  !item The string passed in the A_ThermoData structure is displayed
     (!I)after(!i) calling the function passed in cont as text in the
     progress bar. To display a text here as user info, the text must
     be set when checking the termination condition, i.e. in init for
     the start text, in cont for the subsequent call of fkt or stop
     and in stop will be the text until the window is closed.

  !item The init function is called before the window appears. The window
     is already initialized.

  !item After opening the window, the start function is called.

  !item The cont function is called repeatedly and checks whether the
     loop should continue. The data (data for percentage/scroll bar
     length, info text) is also set here in the structure A_ThermoData,
     which should be used for the screen update directly after cont.
     A return value FALSE signals that the loop should be terminated,
     otherwise the function fct is called after the progress bar has
     been updated on the screen.

  !item The function transferred in fkt carries out the actual action of
     the progress bar and thus corresponds to the inner core of a loop.

  !item The stop function is called after the actions have ended before
     the window is closed.

     The function has two roles. It is called up when the 'Cancel'
     button is clicked. If it returns FALSE here, the loop continues,
     otherwise the progress bar is stopped and ended. If the loop is
     terminated by the return value FALSE of the "regular" function
     transferred in cont, stop is also called. The return value does
     not matter here.

     (!B)Note:(!b) To differentiate between these two call variants, the
     termination criterion implemented in the actual test function
     cont should be used. The transferred function pointers are passed
     on in A_ThermoData for this purpose!

  !item The function passed in quit is called after the window has been
     closed and is for cleaning up .
!end_enumerate

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item System functions
!end_enumerate


!begin_node Ash_thermometer - Example

The following progress bar


!image (!IMAGES)img00731.img

Shows bascially a for loop visually and is generated by the following
code:

The init function is:
!begin_sourcecode
int16 init( ThermoData *thermo )
{
   thermo->aktuell=0;
   thermo->maximum=500;
   strcpy(thermo->text, "Zähler-Initialisierung...");
   return TRUE;
}
!end_sourcecode

The function that implements the termination criterion is
!begin_sourcecode
int16 isRunning( ThermoData *thermo )
{
   return (thermo->aktuell<thermo->maximum);
}
!end_sourcecode

As a loop function this is used:
!begin_sourcecode
int16 zaehlfkt( ThermoData *thermo )
{
   sprintf(thermo->text, "Aufruf Nr. %li", thermo->aktuell);
}
!end_sourcecode

Instead of simply outputting the thermo->current counter here, more
lengthy ongoing actions could be going on.

Although the start function is not required. The stop function is in
this example:
!begin_sourcecode
int16 stop( ThermoData *thermo )
{
   strcpy(thermo->text, "Zähler anhalten?");

   return (thermo->cont)(thermo)
               && Awi_alert(2, Nachfrage)==1;
}
!end_sourcecode

where Nachrage is an alert box defined in the (!I)GUI editor(!i), which
is used to ask whether the counter should be ended. As you can see,
the abort condition is implemented via the pointer cont in the first
part of the query.

The call of the thermometer is then very simple:

!begin_sourcecode
     Ash_thermometer(THERMO_PERCENT|THERMO_TEXT|THERMO_CANCEL,
        " Ein kleiner Zähler... ", -1, NULL, init,
        (A_ThermFkt)NULL, isRunning, zaehlfkt, stop,
        (A_ThermFkt)NULL);
!end_sourcecode

Here the appearance of the progress bar is specified by the first
parameter. If the corresponding bits, represented here by constants,
are not set, the corresponding component is not available or is
hidden.

!end_node

!end_node


!begin_node Ast_adc

 !begin_blist [Definition:]
 !item [Summary:]           String centered fill with spaces

 !item [Category:]          String functions

 !item [C:]                 char *Ast_adc( char *string, long len );

 !item [Pascal:]            Function Ast_adc(
                                   string : Pointer; len: LongInt
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_adc function fills a string from both sides with spaces, so
that the string is centered.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_adl, Ast_adr
!end_enumerate

!end_node


!begin_node Ast_add

 !begin_blist [Definition:]
 !item [Summary:]           Several strings are concatenated

 !item [Category:]          String functions

 !item [C:]                 char *Ast_add( int16 anzahl, char *ergebnis, ... )

 !item [Pascal:]            Die Funktion ist in Pure-Pascal wegen der
                    Variables Parameter leider nicht möglich.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_add function concatenates several strings after the spaces
are removed by Ast_alltrim and fills the result left-justified with
spaces to a certain length.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions
!end_enumerate

!end_node


!begin_node Ast_adl

 !begin_blist [Definition:]
 !item [Summary:]           Fill a left-aligned string with spaces from the
                    right

 !item [Category:]          String functions

 !item [C:]                 char *Ast_adl( char *string, long len );

 !item [Pascal:]            Function Ast_adl(
                                   string : Pointer; len: LongInt
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_adl function fills a string from the right with spaces, so
that the string is left-justified.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_adc, Ast_adr
!end_enumerate

!end_node


!begin_node Ast_adr

 !begin_blist [Definition:]
 !item [Summary:]           Fill a right-aligned string with spaces from the
                    left

 !item [Category:]          String functions

 !item [C:]                 char *Ast_adr( char *string, long len );

 !item [Pascal:]            Function Ast_adr(
                                   string : Pointer; len: LongInt
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_adr function fills a string from the left with spaces, so
that the string is right-justified.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_adc, Ast_adl
!end_enumerate

!end_node


!begin_node Ast_alltrim

 !begin_blist [Definition:]
 !item [Summary:]           Remove leading and trailing spaces from a string

 !item [Category:]          String functions

 !item [C:]                 char *Ast_alltrim( char *string );

 !item [Pascal:]            Function Ast_alltrim( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Ast_alltrim function is the combination of Ast_ltrim and Ast_rtrim.
It removes leading and trailing spaces in a string.

(!B)Note:(!b) The characters are converted directly in the passed string,
i.e. the passed string is (!B)changed(!b)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_ltrim, Ast_rtrim
!end_enumerate

!end_node


!begin_node Ast_cmp

 !begin_blist [Definition:]
 !item [Summary:]           Compare two strings (case sensitive)

 !item [Category:]          String functions

 !item [C:]                 int16 Ast_cmp( const char *str_1,
                             const char *str_2 );

 !item [Pascal:]            Function Ast_cmp(
                                   str_1, str_2: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_cmp function compares two strings, taking the case into
account.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_icmp, Ast_fcmp
!end_enumerate

!end_node


!begin_node Ast_count

 !begin_blist [Definition:]
 !item [Summary:]           Determine frequency of characters in a string in
                    another string

 !item [Category:]          String functions

 !item [C:]                 long Ast_count( char *string, char *zeichen );

 !item [Pascal:]            Function Ast_count(
                                   string, zeichen: Pointer
                                ) : LongInt;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_count function determines the number of characters in a string
that are included in the second string .

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions
!end_enumerate

!end_node


!begin_node Ast_countASCIZZ

 !begin_blist [Definition:]
 !item [Summary:]           Determine the number of strings in an ASCIIZZ
                    string

 !item [Category:]          String functions

 !item [C:]                 int16 Ast_countASCIZZ( const char *asciizz );

 !item [Pascal:]            Function Ast_countASCIZZ(
                                   string: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Ast_countASCIZZ function determines the number of strings contained
in an ASCIIZZ string. This is required for the implementation of
GEMSCript, because ASCIIZZ strings are sent there.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions, GEMScript
!end_enumerate

!end_node


!begin_node Ast_create

 !begin_blist [Definition:]
 !item [Summary:]           Duplicate string

 !item [Category:]          String functions

 !item [C:]                 char *Ast_create( const char *parent );

 !item [Pascal:]            Function Ast_create( parent : Pointer) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_create function copies the string 'parent' into a newly
allocated memory area. The same string is only returned for the
empty string.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Ast_delete
!end_enumerate

!end_node


!begin_node Ast_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete a copy of a string

 !item [Category:]          String functions

 !item [C:]                 void Ast_delete( char *string );

 !item [Pascal:]            Procedure Ast_delete( string : Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_delete function frees up the storage space of the string.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Ast_create
!end_enumerate

!end_node


!begin_node Ast_deleteAry

 !begin_blist [Definition:]
 !item [Summary:]           Completely release the array of strings

 !item [Category:]          String functions

 !item [C:]                 void Ast_deleteAry( char **strings,
                            int16 anzahl );

 !item [Pascal:]            Procedure Ast_deleteAry(
                                 strings: array of Pointer;
                                 anz: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_deleteAry function releases the array again (e.g. built
by Ast_splitASCIZZ). Before the array is released by Ax_free, the
individual strings are deleted using Ast_delete.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions, GEMScript

  !item Ast_splitASCIIZZ
!end_enumerate

!end_node


!begin_node Ast_fcmp

 !begin_blist [Definition:]
 !item [Summary:]           Compare two strings with wildcards

 !item [Category:]          String functions

 !item [C:]                 int16 Ast_fcmp( const char *str_1,
                             const char *str_2 );

 !item [Pascal:]            Function Ast_fcmp(
                                   str_1, str_2: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_fcmp function compares two strings, and is case-sensitive.
The first string may also contain the usual wildcard characters
'*' and '?'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_cmp, Ast_icmp
!end_enumerate

!end_node


!begin_node Ast_filter

 !begin_blist [Definition:]
 !item [Summary:]           Remove characters from string

 !item [Category:]          String functions

 !item [C:]                 char *Ast_filter( char *string, char *wrg_char );

 !item [Pascal:]            Function Ast_filter(
                                   string, wrg_char: Pointer
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ast_filter takes away from a string all the characters
of another string. These are so-called "disallowed characters".

(!B)Note:(!b) The characters are removed directly from the passed string,
i.e. the passed string is (!I)changed(!i)!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions
!end_enumerate

!end_node


!begin_node Ast_icmp

 !begin_blist [Definition:]
 !item [Summary:]           Compare strings (!I)without(!i) regard to case

 !item [Category:]          String functions

 !item [C:]                 int16 Ast_icmp( const char *str_1,
                             const char *str_2 );

 !item [Pascal:]            Function Ast_icmp(
                                   str_1, str_2: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_icmp function compares two strings, the case (!I)does not matter(!i).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_cmp, Ast_fcmp
!end_enumerate

!end_node


!begin_node Ast_isEmpty

 !begin_blist [Definition:]
 !item [Summary:]           Check for an empty string

 !item [Category:]          String functions

 !item [C:]                 int16 Ast_isEmpty( char *string );

 !item [Pascal:]            Function Ast_isEmpty( string: Pointer ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_isEmpty function checks whether a string contains only
"white spaces" (see also Ach_isWhite).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ach_isWhite
!end_enumerate

!end_node


!begin_node Ast_istr

 !begin_blist [Definition:]
 !item [Summary:]           Find a substring in a string, (!I)not(!i) case
                    sensitive 

 !item [Category:]          String functions

 !item [C:]                 char *Ast_istr( const char *s1, const char *s2 )

 !item [Pascal:]            char * Function Ast_istr(
                                   s1, s2: Pointer
                                ) : Pointer)

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_istr function searches for the first occurrence of the
substring s2 in the string s1, whereby upper and lower case
(!I)is not considered(!i).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions
!end_enumerate

!end_node


!begin_node Ast_ltrim

 !begin_blist [Definition:]
 !item [Summary:]           Remove leading spaces

 !item [Category:]          String functions

 !item [C:]                 char *Ast_ltrim( char *string );

 !item [Pascal:]            Function Ast_ltrim( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_ltrim function trims off all leading spaces, i.e. removes
all spaces to the left of the string.

(!B)Note:(!b) The characters are converted directly in the passed string,
i.e. the passed string is (!I)changed(!i)!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_alltrim, Ast_rtrim
!end_enumerate

!end_node


!begin_node Ast_mergeASCIIZZ

 !begin_blist [Definition:]
 !item [Summary:]           Merge an array of strings into an ASCIIZZ string

 !item [Category:]          String functions

 !item [C:]                 char *Ast_mergeASCIIZZ( const char **strings,
                             const int16 anzahl, const int16 global )

 !item [Pascal:]            Function Ast_mergeASCIIZZ(
                                   strings: Array of Pointer;
                                   anzahl, global: int16
                                ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_mergeASCIIZZ function is the reverse of Ast_splitASCIIZZ.
The string array strings, which contains 'number' strings, is
converted into an ASCIIZZ string. If global=TRUE, global memory
is allocated for this.

(!B)Note:(!b) The ASCIIZZ string must be released using Ax_free or
Ax_glfree after use.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions, GEMScript

  !item Ast_countASCIIZZ, Ast_deleteAry
!end_enumerate

!end_node


!begin_node Ast_reverse

 !begin_blist [Definition:]
 !item [Summary:]           "Read" a string backwards

 !item [Category:]          String functions

 !item [C:]                 char *Ast_reverse( char *reverse, const char
                    *string );

 !item [Pascal:]            Function Ast_reverse( reverse, string : Pointer) :
                    Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ast_reverse reverses the string 'string' character
by character, i.e. the first character in 'reverse' is the last
character of 'string' and the last character of 'reverse' is the
first character of 'string'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions
!end_enumerate

!end_node


!begin_node Ast_rtrim

 !begin_blist [Definition:]
 !item [Summary:]           Remove trailing spaces

 !item [Category:]          String functions

 !item [C:]                 char *Ast_rtrim( char *string );

 !item [Pascal:]            Function Ast_rtrim( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_rtrim function cuts off all trailing spaces, i.e. removes
all spaces to the right of the string.

(!B)Note:(!b) The characters are converted directly in the passed string,
i.e. the passed string is (!I)changed(!i)!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_alltrim, Ast_ltrim
!end_enumerate

!end_node


!begin_node Ast_splitASCIIZZ

 !begin_blist [Definition:]
 !item [Summary:]           Split an ASCIIZZ string into an array of strings

 !item [Category:]          String functions

 !item [C:]                 int16 Ast_splitASCIZZ( const char *asciizz,
                             char ***strings, int16 *anz )

 !item [Pascal:]            Function Ast_splitASCIZZ(
                                   string: Pointer;
                                   Var strings: array of Pointer;
                                   Var anz: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ast_splitASCIZZ function determines the number of strings and
splits them into an array of normal C strings. The array and the
number are supplied via the passed parameters, the function then
indicates whether it was successful or unsuccessful (e.g. lack of
memory).

(!B)Note:(!b) The generated array must be released using Ast_deleteAry.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions, GEMScript

  !item Ast_countASCIIZZ, Ast_mergeASCIIZZ, Ast_deleteAry
!end_enumerate

!end_node


!begin_node Ast_tolower

 !begin_blist [Definition:]
 !item [Summary:]           Convert string to lowercase

 !item [Category:]          String functions

 !item [C:]                 char *Ast_tolower( char *string );

 !item [Pascal:]            Function Ast_tolower( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ast_tolower converts all letters of a string to
lowercase. The umlauts 'Ä', 'Ö' and 'Ü' are treated correctly in
contrast to strlwr.

(!B)Note:(!b) The characters are converted directly in the passed string,
i.e. the passed string will be (!I)changed(!i)!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_toupper
!end_enumerate

!end_node


!begin_node Ast_toupper

 !begin_blist [Definition:]
 !item [Summary:]           Convert string to uppercase

 !item [Category:]          String functions

 !item [C:]                 char *Ast_toupper( char *string );

 !item [Pascal:]            Function Ast_toupper( string : Pointer) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ast_toupper converts all letters of a string to
uppercase. The umlauts 'ä', 'ö' and 'ü' are treated correctly in
contrast to strupr.

(!B)Note:(!b) The characters are converted directly in the passed string,
i.e. the passed string will be (!I)changed(!i)!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item String functions

  !item Ast_tolower
!end_enumerate

!end_node


!begin_node AS_ACCLOSED

 !begin_blist [Definition:]
 !item [Summary:]           Accessory has been closed

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The program running as an accessory has just received the GEM message
AC_CLOSE. If necessary, the window should correct its own structures,
which entails the rough behavior of GEM.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ALLOWBUBBLE

 !begin_blist [Definition:]
 !item [Summary:]           Permission to BubbleGEM Help

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *erlaubt;

 (!B)Pascal (in_out):(!b)   erlaubt: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A BubbleGEM Help for an object from the work object or the toolbar
of the window is to be displayed. The window should check whether
BubbleGEM Help is generally possible or not. The value FALSE should
be saved in allowed if the BubbleGEM Help is rejected. The value is
preset with TRUE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ASKHELP

 !begin_blist [Definition:]
 !item [Summary:]           Determine window to display help

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [Awindow]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Are you a help window that can output data according to AS_HELP?
Then a pointer to your own window structure should be entered in
'wind'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ASKLAZY

 !begin_blist [Definition:]
 !item [Summary:]           Detect LAZy-Shell tools window

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [Awindow]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Are you a LAZy-Shell tools window? Then a pointer to your own window
structure should be entered in 'wind'.

Please refer to the LAZy-Shell documentation for more information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ASKFILE

 !begin_blist [Definition:]
 !item [Summary:]           Determine window to display file directory

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [Awindow]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Are you a file directory display window? Then a pointer to your
own window structure should be entered in 'wind'.

(!B)Note:(!b) Please refer to the LAZy-Shell documentation for additional
information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ASKNOTIO

 !begin_blist [Definition:]
 !item [Summary:]           Find the Notio window

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [Awindow]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Are you a Notio window? Then a pointer to your own window structure
should be entered in 'wind'.

Please refer to the Notio documentation for more information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ASKTURNUS

 !begin_blist [Definition:]
 !item [Summary:]           Find the TurnUs window

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        Awindow **window;

 (!B)Pascal (in_out):(!b)   Var in_out: (!link [AwindowPtr] [Awindow]);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Are you a TurnUs window? Then a pointer to your own window structure
should be entered in 'wind'.

Please refer to the TurnUs documentation for more information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_ASK_STGUIDE

 !begin_blist [Definition:]
 !item [Summary:]           Ask before displaying the ST-Guide help

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        AGetSTGuide *data;

 (!B)Pascal (in_out):(!b)   data: ^AGetSTGuide;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The data for the ST-Guide help is transferred to the window to
examine. The help title and possibly the filename are contained
in the structure. The strings can be modified.

(!B)Example:(!b) To modify the help topic, you should do the
following:

     data->hyp_title=Ast_create("Neues Hilfethema");

(!B)Example:(!b) If no help is to be displayed, you should proceed
as follows:

     data->hyp_title=NULL;

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_CHECKDELETE

 !begin_blist [Definition:]
 !item [Summary:]           Signal ability to delete objects from object list?

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *ok;

 (!B)Pascal (in_out):(!b)   in_out: ok: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Objects of the window are to be deleted. This message will be sent
to the associated window. The window checks the Aselect.array list
to decide whether the erasability should be signaled visually. The
value FALSE should appear in ok if the deletion is rejected. The
value TRUE is preset.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_CHECKDRAG

 !begin_blist [Definition:]
 !item [Summary:]           Signal willingness to accept when dragging in an
                    open window?

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 pass[2];

 (!B)Pascal (in_out):(!b)   pass: ^Array [0..1] of Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Objects were dragged onto an accepting object. This message will be
sent to the associated window. The window checks the selection list
and the pass parameter to decide whether the readiness to accept
should be signaled visually.

 pass[0]  Contains the object number of the accepting (window) object

 pass[1]  The value will be FALSE if the acceptance is rejected. The
          default value is TRUE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_CHECKDRAGGED

 !begin_blist [Definition:]
 !item [Summary:]           Signal willingness to accept when dragging on a
                    closed window?

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *ok;

 (!B)Pascal (in_out):(!b)   ok: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Objects were dragged onto an accepting window icon that represents
a closed window. This message will be sent to the associated window.
The window checks the selection list in order to decide whether the
readiness to accept should be signaled visually. FALSE should be
saved in ok if the acceptance is rejected.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_CEWS_BASE

 !begin_blist [Definition:]
 !item [Summary:]           (!I)ACSpro(!i) CEWS internal message...

 !item [Category:]          Predefined window messages
 !end_blist

Please refer to the documentation or source for CEWS for more
information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_CEWS_ACSSAVE

 !begin_blist [Definition:]
 !item [Summary:]           (!I)ACSpro(!i) CEWS internal message...

 !item [Category:]          Predefined window messages
 !end_blist

Please refer to the documentation or source for CEWS for more
information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_CONFIGDRAG

 !begin_blist [Definition:]
 !item [Summary:]           Configuration of dragging

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 pass[14];

 (!B)Pascal (in_out):(!b)   pass: ^Array [0..13] of Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

When objects of the window should be dragged this message will be
sent to the associated window. It should modify the transferred
configuration appropriately.

The components contain the following data (in the brackets are the
default values that can be modified)

!begin_xlist [pass[6-13]]
 !item [pass[0]]    X Grid jumps (1)

 !item [pass[1]]    Y Grid jumps (1)

 !item [pass[2]]    X-Position of the allowed rectangle (full desktop)

 !item [pass[3]]    Y-Position of the allowed rectangle (full desktop)

 !item [pass[4]]    Width (W) of the allowed rectangle (full desktop)

 !item [pass[5]]    Height (H) of the allowed rectangle (full desktop)

 !item [pass[6-13]] Here are the mouse shape indices. The default is
            Form 3, the pushing hand. Depending on the key status
            of the special keys, the following index is fetched
            from the pass field:

!begin_xlist [pass[13]]
             !item [pass[6]] <no special keys pressed>

             !item [pass[7]] SHIFT

             !item [pass[8]] CONTROL

             !item [pass[9]] SHIFT + CONTROL

             !item [pass[10]] ALT

             !item [pass[11]] SHIFT + ALT

             !item [pass[12]] CONTROL + ALT

             !item [pass[13]] SHIFT + CONTROL + ALT
!end_xlist
!end_xlist

(!B)Cross references:(!b)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_DELETE

 !begin_blist [Definition:]
 !item [Summary:]           Delete objects from the selection list

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

They are objects of the window in the selection list. The window is
instructed to delete them. On the desktop, your own selected objects
are deleted, which are listed in the Aselect selection list. The
trashcan and the NEW symbol on the generic desktop DESKTOP cannot be
deleted.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_DOARCHIVE

 !begin_blist [Definition:]
 !item [Summary:]           (Please refer to the LAZy-Shell documentation)

 !item [Category:]          Predefined window messages

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Please refer to the LAZy-Shell documentation for more information.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_DRAGABORTED

 !begin_blist [Definition:]
 !item [Summary:]           Dragging objects to other windows

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *wi_nr;

 (!B)Pascal (in_out):(!b)   wi_nr: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The drag operation was ended on another window. The window number
of the other window is transferred.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_DRAGGED

 !begin_blist [Definition:]
 !item [Summary:]           Dragging objects onto the icon of a closed window

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Objects were either dragged onto the iconified window or sent to
the window by an external communication partner. In the second case,
no receiving object could be located, so that the window is informed
about this message. The window can now respond appropriately.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_EDITCHG

 !begin_blist [Definition:]
 !item [Summary:]           Change the length of a text field by entering text

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

When entering text in a GEM object, this message is sent to the
active window - more precisely if the field length changes due to
the entry.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_FOCUSCHG

 !begin_blist [Definition:]
 !item [Summary:]           Input focus is set to new field

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *tofield;

 (!B)Pascal (in_out):(!b)   tofield: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The input focus should be set to another field. The number of the new
input object is transferred. The window can now check the consistency
of the input. The current edit field is in Awindow->ob_edit.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_HELP

 !begin_blist [Definition:]
 !item [Summary:]           Help window should display Help

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *mess;

 (!B)Pascal (in_out):(!b)   mess: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A window previously determined by AS_ASKHELP should now display help.
There is no such window in the (!I)ACSpro(!i)-(!I)GUI editor(!i) itself, but it can
be submitted as a module! There is a specific format to provide help
easily and yet efficiently.

'mess' contains a ready-made help text path or an IMG path. These
files are displayed in the help window. Individual 'chapters' as the
help text are selected by following the path the heading follows
(separated by 'TAB'); the text is then searched for '#' followed by
the heading at the beginning of the line. If the heading is present,
it will be displayed until the next '#' or the end of the file.

The text to be displayed can also be transferred directly, so no file
can be specified.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_GEM_MESS

 !begin_blist [Definition:]
 !item [Summary:]           Unknown GEM message received

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *messbuff;

 (!B)Pascal (in_out):(!b)   Var messbuff: Array [0..7] of Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If an unknown GEM message is received, the root window receives
this message with a pointer to the unknown message.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_GETBUBBLE

 !begin_blist [Definition:]
 !item [Summary:]           BubbleGEM Help is requested

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        AGetObjText *info;

 (!B)Pascal (in_out):(!b)   Var info: AGetObjTextPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A BubbleGEM Help for an object from the work object or the toolbar
of the window is to be displayed. The window should provide the
BubbleGEM text for the object specified in info.

(!B)Note:(!b) This message is only sent if there is a standard GEM
object or USERDEF that does not know the message AUO_GETBUBBLE.
The BubbleGEM protocol explains how (!I)ACSpro(!i) works with BubbleGEM
Help.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AGetObjText
!end_enumerate

!end_node


!begin_node AS_ICONIZED

 !begin_blist [Definition:]
 !item [Summary:]           The window was closed and placed as an icon by
                    the root window

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The window has been iconified automatically and can now react
appropriately.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_INFO

 !begin_blist [Definition:]
 !item [Summary:]           The window should inform itself and about the
                    objects in the selection list

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The window should inform about itself. If the Aselect selection
list belongs to the window, you can also report on selected objects.
Informed depending on the state of the selection list, e.g. the
generic desktop DESKTOP 'about itself', New, trashcan or forwards
the message to selected windows.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_LOADFILE

 !begin_blist [Definition:]
 !item [Summary:]           The program should load a file into the editor

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

In order to avoid that each module contains the routines of the
editor window and thus requires memory and hard disk space, the
message AS_LOADFILE can be sent in a program (not a module!). The
program then loads the file specified in 'f' into the integrated
(!link [Editor] [Userdef-Editor]).

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_LOOKSTRING

 !begin_blist [Definition:]
 !item [Summary:]           Search for an entry in the internal data

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *txt;

 (!B)Pascal (in_out):(!b)   txt: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The window should search for an entry in its internal data structures
that matches the text in 'txt' - this is especially important for
windows that provide a lot of data, as this enables a cross-window
search. A found entry should then be identified somehow - but not
through a modal dialog!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_MOUSE

 !begin_blist [Definition:]
 !item [Summary:]           The mouse was moved over the window

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The mouse was moved over the window. The coordinates are available
in the global variables ev_mmox and ev_mmoy.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_OPEN

 !begin_blist [Definition:]
 !item [Summary:]           Objects in the selection list should be opened

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

They are objects of the window in the selection list. The window
is asked to open them.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_PC_VERSION

 !begin_blist [Definition:]
 !item [Summary:]           Confirmation of a help action has arrived

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *help_version;

 (!B)Pascal (in_out):(!b)   help_version: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A confirmation of a PureC help action triggered by (!I)ACSpro(!i) has been
received, or an error was detected after sending of the message
(time-out, start of a second (!link [PureC-Hilfe-Aktion] [PureC Help Protocol]) before the end of
the first, etc.).

This message will be sent by (!I)ACSpro(!i) if this is specified
when starting a PureC help action.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_REALMENU_END

 !begin_blist [Definition:]
 !item [Summary:]           Completion of the menu operation

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

At the end of the menu operation, 'AS_REALMENU_END' is sent to
the window.

(!B)Attention:(!b) In contrast to the real-time selection, the programmer
must ensure that the menu and any display due to these messages do
not overlap graphically. The only possibility is to evaluate the
dimensions of the menu GEM object tree!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALMENU_START, AS_REALMENU_UPDATE
!end_enumerate

!end_node


!begin_node AS_REALMENU_START

 !begin_blist [Definition:]
 !item [Summary:]           Start of menu operation

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If the user starts navigating the menu of a window, it receives the
message 'AS_REALMENU_START' with an int16 pointer to the object number
that triggered the popup.

(!B)Attention:(!b) In contrast to the real-time selection, the programmer
must ensure that the menu and any display due to these messages do
not overlap graphically. The only possibility is to evaluate the
dimensions of the menu GEM object tree!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALMENU_UPDATE, AS_REALMENU_END
!end_enumerate

!end_node


!begin_node AS_REALMENU_UPDATE

 !begin_blist [Definition:]
 !item [Summary:]           Object change when using the menu

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If an object changes during operation of the menu, the message
'AS_REALMENU_UPDATE' is sent and the window also receives the new
PopupObject Number.

(!B)Attention:(!b) In contrast to the real-time selection, the programmer
must ensure that the menu and any display due to these messages do
not overlap graphically. The only possibility is to evaluate the
dimensions of the menu GEM object tree!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALMENU_START, AS_REALMENU_END
!end_enumerate

!end_node


!begin_node AS_REALPOP_END

 !begin_blist [Definition:]
 !item [Summary:]           Completion of the popup control

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

At the end of the popup control, the message 'AS_REALPOP_END' is
sent to the window.

(!B)Attention:(!b) In contrast to the real-time selection, the programmer
must ensure that the popup and any possible display due to these
messages do not overlap graphically (e.g. by checking the absolute
coordinates of the popup) - because neither moving to another window,
nor moving to the left/top/bottom of the popup guarantees that the
areas do not even overlap. The only possibility is to evaluate the
dimensions of the popup GEM object tree!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALPOP_START, AS_REALPOP_UPDATE
!end_enumerate

!end_node


!begin_node AS_REALPOP_START

 !begin_blist [Definition:]
 !item [Summary:]           Start of popup control

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If a popup is operated by the user, the original window initially
receives the message 'AS_REALPOP_START' with an int16 pointer to
the object number that triggered the popup.

(!B)Attention:(!b) In contrast to the real-time selection, the programmer
must ensure that the popup and any possible display due to these
messages do not overlap graphically (e.g. by checking the absolute
coordinates of the popup) - because neither moving to another window,
nor moving to the left/top/bottom of the popup guarantees that the
areas do not even overlap. The only possibility is to evaluate the
dimensions of the popup GEM object tree!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALPOP_UPDATE, AS_REALPOP_END
!end_enumerate

!end_node


!begin_node AS_REALPOP_UPDATE

 !begin_blist [Definition:]
 !item [Summary:]           Object change in the popup control

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *ob;

 (!B)Pascal (in_out):(!b)   ob: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If an object changes during operation, 'AS_REALPOP_UPDATE' is sent
and the window also receives the new PopupObject Number (which can
also be -1).

(!B)Attention:(!b) In contrast to the real-time selection, the programmer
must ensure that the popup and any possible display due to these
messages do not overlap graphically (e.g. by checking the absolute
coordinates of the popup) - because neither moving to another window,
nor moving to the left/top/bottom of the popup guarantees that the
areas do not even overlap. The only possibility is to evaluate the
dimensions of the popup GEM object tree!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALPOP_START, AS_REALPOP_END
!end_enumerate

!end_node


!begin_node AS_REALSEL_END

 !begin_blist [Definition:]
 !item [Summary:]           Completion of the real-time selection

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

When the user has finished the selection, the window receives the
message 'AS_REALSEL_END'. The Aselect selection list is available
at any time and can be evaluated.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALSEL_START, AS_REALSEL_UPDATE
!end_enumerate

!end_node


!begin_node AS_REALSEL_START

 !begin_blist [Definition:]
 !item [Summary:]           Start of real-time selection

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

'AS_REALSEL_START' tells your own window that the user has started
a new selection. The Aselect selection list is available at any time
and can be evaluated.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALSEL_UPDATE, AS_REALSEL_END
!end_enumerate

!end_node


!begin_node AS_REALSEL_UPDATE

 !begin_blist [Definition:]
 !item [Summary:]           Change in real-time selection

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

'AS_REALSEL_UPDATE' is sent to the window when the selection has
changed. The Aselect selection list is available at any time and
can be evaluated.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_REALSEL_START, AS_REALSEL_END
!end_enumerate

!end_node


!begin_node AS_REDRAWFILE

 !begin_blist [Definition:]
 !item [Summary:]           File tree refresh due to a path/drive change

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A window that somehow shows a current file tree and is therefore
dependent on being up-to-date should refresh its display based on
this message, because a drive/path has changed. In 'f' the path
for which this applies can be found!

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_SAVEFILE

 !begin_blist [Definition:]
 !item [Summary:]           Request to save the data

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If a file name is passed in 'f', the window should save any data
that is saved under this filename, or save all of its data if
NULL or NIL is passed.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_SCRAP_EXPORT

 !begin_blist [Definition:]
 !item [Summary:]           Export data to the clipboard

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *typ;

 (!B)Pascal (in_out):(!b)   typ: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

With a request to export data to the clipboard, the window should
interpret the message 'AS_SCRAP_EXPORT'. The desired type (!I)can(!i)
be sent to 'typ'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_SCRAP_UPDATE, AS_SCRAP_IMPORT
!end_enumerate

!end_node


!begin_node AS_SCRAP_IMPORT

 !begin_blist [Definition:]
 !item [Summary:]           Import data from the clipboard

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *typ;

 (!B)Pascal (in_out):(!b)   typ: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

As a request to import data from the clipboard, the window should
interpret the message 'AS_SCRAP_IMPORT'. You (!I)can(!i) get the type of
the file in 'typ'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_SCRAP_UPDATE, AS_SCRAP_EXPORT
!end_enumerate

!end_node


!begin_node AS_SCRAP_UPDATE

 !begin_blist [Definition:]
 !item [Summary:]           Clipboard data has changed

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

If the content of the clipboard changes (e.g. using Ascrp_put
or SC_CHANGED), this is indicated to the windows by the message
'AS_SCRAP_UPDATE'.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_SCRAP_EXPORT, AS_SCRAP_IMPORT
!end_enumerate

!end_node


!begin_node AS_SELECTADD

 !begin_blist [Definition:]
 !item [Summary:]          Selection list has been extended by an object

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *obnr;

 (!B)Pascal (in_out):(!b)   obnr: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

An object of the window was added to the selection list. The pointer
references the number of the object.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_SELECTDEL

 !begin_blist [Definition:]
 !item [Summary:]           The selection list was reduced by one object or
                    completely deleted

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        int16 *obnr;

 (!B)Pascal (in_out):(!b)   obnr: ^Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The selection list was deleted or reduced by one object. If the
pointer is NULL or NIL, the list has been completely deleted,
otherwise it points to the number of the removed object

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_SELECTFILE

 !begin_blist [Definition:]
 !item [Summary:]           File window should select file or delete selection

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        char *f;

 (!B)Pascal (in_out):(!b)   f: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A window that represents a file tree or snippet should, based on
this message, add the file transferred in 'f' to the selection list,
or remove all selected files from the selection if NULL/NIL has been
transferred. 

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_SHADED

 !begin_blist [Definition:]
 !item [Summary:]           The window is now in the "shaded" state

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The system has the window "shaded", i.e. rolled-up. The (!link [state] [Awindow]) 
AWS_SHADED has already been set and the window is informed that
it is now shaded.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_UNSHADED
!end_enumerate

!end_node


!begin_node AS_TERM

 !begin_blist [Definition:]
 !item [Summary:]           The window should be deleted and released

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This is the most important service and it (!B)must(!b) be operated from all
windows. The service may be denied if the appexit flag is set to
FALSE. If the appexit flag is set to TRUE, the window must release
its data structures and then delete the window. Asking whether
certain data should be backed up is allowed.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item appexit
!end_enumerate

!end_node


!begin_node AS_UNSHADED

 !begin_blist [Definition:]
 !item [Summary:]           The window is no longer in the "shaded" state

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The system has the window "unshaded", i.e. unrolled and opened.
The (!link [state] [Awindow]) AWS_SHADED has already been reset, the window is
informed that it is now fully visible again.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_SHADED
!end_enumerate

!end_node


!begin_node AS_UNTOPPED

 !begin_blist [Definition:]
 !item [Summary:]           The Application is put in the background

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Another Application has come up in a multitasking environment so this
one is in the background.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node AS_WIAUTOPOS

 !begin_blist [Definition:]
 !item [Summary:]           The window was positioned automatically

 !item [Category:]          Predefined window messages

 (!B)C (in_out):(!b)        NULL

 (!B)Pascal (in_out):(!b)   NIL

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The window was positioned automatically. The x/y values are in
wi->wi_act.x or wi->wi_act.y. They may be corrected appropriately.
The standard procedure calculates the values from the window ID
wi->wi_id.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages
!end_enumerate

!end_node


!begin_node Ate_create

 !begin_blist [Definition:]
 !item [Summary:]           Duplicate TEDINFO structure

 !item [Category:]          Tedinfo functions

 !item [C:]                 TEDINFO *Ate_create( const TEDINFO* tedi );

 !item [Pascal:]            Function Ate_create( tedi: TEDINFOPtr ) :
                    TEDINFOPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ate_create function creates an exact copy of a transferred
TEDINFO structure. Ast_create is used to create the strings within
the structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Tedinfo functions

  !item Ate_delete

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Ate_delete

 !begin_blist [Definition:]
 !item [Summary:]           Release TEDINFO structure

 !item [Category:]          Tedinfo functions

 !item [C:]                 void Ate_delete( TEDINFO *tedi );

 !item [Pascal:]            Procedure Ate_delete( tedi : TEDINFOPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ate_delete frees the storage space of a TEDINFO structure.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Tedinfo functions

  !item Ate_create

  !item Ast_create/Ast_delete
!end_enumerate

!end_node


!begin_node Auo_boxed

 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for the Userdef-BoxEdit

 !item [Category:]          (!link [User defined objects] [ACSpro UserDefs]), Userdef-(!link [BoxEdit] [Userdef-BoxEdit])

 !item [C:]                 int16 Auo_boxed( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_boxed(
                                   entry: ACSOBJECTPtr;
                                   task: Integer
                                ) : Integer

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine provides a convenient service routine of Userdef-(!link [BoxEdit] [Userdef-BoxEdit]).

Messages that involve the cursor position or selections are only
processed if this object currently also has the cursor. Operations
that change the text (insert, delete) always consider a selection
first! For almost all operations, the Userdef must have communcicated
its identity using (!link [AUO_SELF] [Standard Userdef messages]), otherwise the message will not be
processed.

The following messages - with their data types for the pointer
in_out - are processed:

!begin_xlist [AUO_BESETSELECT]
 !item [AUO_CREATE]       The internal data structures are created and
                  initialized.

                       For Pure-C: int16 *success;

                       For Pure-Pascal: success: Integer;

 !item [AUO_SELF]         Sets the identity of the userdef via the parameter
                  in_out, which refers to an awiob structure.

                       For Pure-C: Awiob *ident;

                       For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_OWNER]        Fetches the identity of the userdef and fills
                  the Awiob structure passed via the parameter.

                       For Pure-C: Awiob *ident;

                       For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_TERM]         Releases the internal structures.

 !item [AUO_SETVAL]       Defines a new text.

                       For Pure-C: char *text;

                       For Pure-Pascal: text: Pointer;

 !item [AUO_GETVAL]       Retrieves the text, taking a selection into
                  account!

                       For Pure-C: char **text;

                       For Pure-Pascal: text: Pointer;

 !item [AUO_FULLUPDATE]   Redraws the object completely.

 !item [AUO_UPDATE]       Redraws the necessary parts.

 !item [AUO_BEGIN]        Moves the cursor to the beginning.

 !item [AUO_END]          Places the cursor at the end of the text.

 !item [AUO_POS]          Sets the position to this value.

                       For Pure-C: int16 *new_pos;

                       For Pure-Pascal: new_pos: ^Integer;

!label AUO_BEINCPOS
 !item [AUO_BEINCPOS]     Moves the cursor one position over.

!label AUO_BEDECPOS
 !item [AUO_BEDECPOS]     Moves the cursor back one position.

!label AUO_BEINCWPOS
 !item [AUO_BEINCWPOS]    Moves the cursor one word over.

!label AUO_BEDECWPOS
 !item [AUO_BEDECWPOS]    Moves the cursor back one word

!label AUO_BEINSCHAR
 !item [AUO_BEINSCHAR]    Inserts a character at the current position.

                       For Pure-C: char *new_char;

                       For Pure-Pascal: new_char: Pointer;

!label AUO_BEINSTEXT
 !item [AUO_BEINSTEXT]    Inserts text at the current position and marks it.

!label AUO_BESETSELECT
 !item [AUO_BESETSELECT]  Sets the selection to start (sel[0]) and end (sel[1]).
                  Sel[1] is always pushed into the visible area.

                       For Pure-C: int16 *sel;

                       For Pure-Pascal: sel: ^Integer;

!label AUO_BEGETSELECT
 !item [AUO_BEGETSELECT]  Determines the selection in the same way as above.

!label AUO_BEBS
 !item [AUO_BEBS]         Deletes the character to the left of the cursor.

!label AUO_BEBSW
 !item [AUO_BEBSW]        Deletes the word to the left of the cursor.

!label AUO_BEBSLINE
 !item [AUO_BEBSLINE]     Deletes from the current position to the beginning.

!label AUO_BEDEL
 !item [AUO_BEDEL]        Deletes the character to the right of the cursor.

!label AUO_BEDELW
 !item [AUO_BEDELW]       Deletes the word to the right of the cursor.

!label AUO_BEDELLINE
 !item [AUO_BEDELLINE]    Deletes from the current position to the end.

!label AUO_BEDELALL
 !item [AUO_BEDELALL]     Deletes everything.

!label AUO_BEMASK
 !item [AUO_BEMASK]       In addition to the internal mask index, a freely
                  selectable mask can also be specified. If this
                  message does not pass NULL/NIL, this text is used
                  as a mask. NULL/NIL resets to the internal mask
                  index.

                       For Pure-C: char *mask;

                       For Pure-Pascal: mask: Pointer;

!label AUO_BECHARLIST
 !item [AUO_BECHARLIST]   Makes a popup appear for the current object, from
                  which a character can be selected from out of all
                  allowed characters.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item BoxEdit (A_boxed/Aus_boxed)

  !item (!link [User defined objects] [ACSpro UserDefs])
!end_enumerate

!end_node


!begin_node Auo_cycle

 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for the Userdef-Cycle

 !item [Category:]          User defined objects, Userdef-Cycle

 !item [C:]                 int16 Auo_cycle( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_cycle(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the service routine of the Userdefs-Cycle.

The following messages - with their data types for the pointer
in_out - are processed

!begin_xlist [AUO_CYCGETINDEX]
 !item [AUO_CREATE]      The internal data structures are created and
                 initialized.

                      For Pure-C: int16 *success;

                      For Pure-Pascal: succesInteger;

 !item [AUO_SELF]        Sets the identity of the Userdef via the parameter
                 in_out, which refers to an awiob structure.

                      For Pure-C: Awiob *ident;

                      For Pure-Pascal: idenAwiobPtr;

 !item [AUO_TERM]        Releases the internal structures

 !item [AUO_SETVAL]      Sets value in the display field

                      For Pure-C: char *DispString;

                      For Pure-Pascal: DispString: Pointer;

 !item [AUO_GETVAL]      Returns pointer to current display value

                      For Pure-C: char *DispString;

                      For Pure-Pascal: DispString: Pointer;

 !item [AUO_FULLUPDATE]  Forces a full update and sets the delta mode
                 back

 !item [AUO_UPDATE]      Refreshes only what is needed. In delta mode
                 only the display text is redrawn.

!label [AUO_CYCINDEX]
 !item [AUO_CYCINDEX]    Jumps to the Nth entry.

                      For Pure-C: int16 *EntryNr;

                      For Pure-Pascal: EntryNr: ^Integer;

!label [AUO_CYCGETINDEX]
 !item [AUO_CYCGETINDEX] Returns the current index

                      For Pure-C: int16 *EntryNr;

                      For Pure-Pascal: EntryNr: ^Integer;

!label [AUO_CYCPOPUP]
 !item [AUO_CYCPOPUP]    Sets a new popup string

                      For Pure-C: char *PopString;

                      For Pure-Pascal: PopString: Pointer;
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Cycle (A_cycle/Aus_cycle)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Auo_editor

 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for the Userdef-Editor

 !item [Category:]          User defined objects, Userdef-Editor

 !item [C:]                 int16 Auo_editor( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_editor(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the convenient service routine of the Userdefs-
Editor.

The editor edits lines that are counted from 0. Apart from the
storage space, an unlimited number of lines can be entered. The
following messages - with their data types for the pointer in_out -
are processed:

!begin_xlist [AUO_EDSELECTWORD]
 !item [AUO_CREATE]        The internal data structures are created and
                   initialized.

                        For Pure-C: int16 *success;

                        For Pure-Pascal: success: Integer;

 !item [AUO_TERM]          Releases the internal structures.

 !item [AUO_SELF]          Sets identity for own 'actions'

                        For Pure-C: Awiob *ident;

                        For Pure-Pascal: ident: AwiobPtr;

                   (!B)Important(!b): This information must be known to the
                   UserDef-Editor if independent actions have to be
                   carried out!

 !item [AUO_OWNER]         Returns identity back.

                        For Pure-C: Awiob *ident;

                        For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_FULLUPDATE]    Completely refreshes the object. The delta mode will
                   deleted.

 !item [AUO_UPDATE]        Refreshes the necessary parts of the editor and the
                   Slider controlled by the editor. Which parts are
                   refreshed depends on the previous actions.

 !item [AUO_SETVAL]        Exchanges the text of the current line with the
                   new one.

                        For Pure-C: char *Text;

                        For Pure-Pascal: Text: Pointer;

 !item [AUO_GETVAL]        Returns the pointer to the text of the current line

 !item [AUO_NEXT]          The next line becomes the current one.

 !item [AUO_PREV]          The previous line becomes the current one.

 !item [AUO_NEXTPAGE]      The line one page further becomes the current one.

 !item [AUO_PREVPAGE]      The line one page before becomes the current one.

 !item [AUO_BEGIN]         The first line becomes the current one.

 !item [AUO_END]           The last line becomes the current one.

 !item [AUO_POS]           The passed line becomes the current one.

                        For Pure-C: long *NewLineNr;

                        For Pure-Pascal: NewLineNr: ^LongInt;

!label AUO_EDCURSOR
 !item [AUO_EDCURSOR]      Sets the cursor shape. 0=dash, 1=underscore,
                   2=block, 3=frame

                        For Pure-C: int16 *NewCursForm;

                        For Pure-Pascal: NewCursForm: ^Integer;

!label AUO_EDSELECTWORD
 !item [AUO_EDSELECTWORD]  Selects the word under the cursor. If the selection
                   is activated, the start of the selection is taken.

!label AUO_EDGETNEED
 !item [AUO_EDGETNEED]     Determines the memory requirement that the text
                   needs.

                        For Pure-C: long *ByteNeeded;

                        For Pure-Pascal: ByteNeeded: ^LongInt;

!label AUO_EDRESET
 !item [AUO_EDRESET]       Clear the dirty flag. The dirty flag indicates
                   whether changes have been made.

!label AUO_EDGETCHANGED
 !item [AUO_EDGETCHANGED]  Reports the status of the dirty flag.

                        For Pure-C: int16 *dirty;

                        For Pure-Pascal: dirty: ^Integer;

!label AUO_EDFIND
 !item [AUO_EDFIND]        Finds the passed string. The search can be
                   configured. If successful, the next location will
                   be selected.

                        For Pure-C: char *SearchText;

                        For Pure-Pascal: SearchText: Pointer;

!label AUO_EDWORD
 !item [AUO_EDWORD]        The word-by-word search is activated.

!label AUO_EDNOWORD
 !item [AUO_EDNOWORD]      The word-by-word search is switched off.

!label AUO_EDBACKWARD
 !item [AUO_EDBACKWARD]    Searches seek backwards.

!label AUO_EDFORWARD
 !item [AUO_EDFORWARD]     Searches seek forward.

!label AUO_EDNOCASE
 !item [AUO_EDNOCASE]      No distinction is made between upper and lower case.

!label AUO_EDCASE
 !item [AUO_EDCASE]        A distinction is made between upper and lower case.

!label AUO_EDBLOCKMODE
 !item [AUO_EDBLOCKMODE]   It is reported whether the block mode (2-Dim) is
                   switched on.

                        For Pure-C: int16 *IsBlockMode;

                        For Pure-Pascal: IsBlockMode: ^Integer;

!label AUO_EDRESIZE
 !item [AUO_EDRESIZE]      The dimensions of the object are adapted to the
                   current font and height.

!label AUO_EDCLEARUNDO
 !item [AUO_EDCLEARUNDO]   Deletes the UNDO buffer.

!label AUO_EDUNDO
 !item [AUO_EDUNDO]        Performs an UNDO. Only changes made with AUO_EDSUB
                   and AUO_EDUNDO are undo-capable.

!label AUO_EDGETROW
 !item [AUO_EDGETROW]      Gets a line from the text. If the selection is
                   activated, only the selected area is transferred.
                   If the line does not exist, - 1 is returned as
                   line length.

                   The structure EDITGETS is transferred. The line
                   number is specified and the text and length are
                   returned

                        For Pure-C: EDITGETS *GetRow;

                        For Pure-Pascal: GetRow: EDITGETSPtr;

!label AUO_EDGETTABSIZE
 !item [AUO_EDGETTABSIZE]  Returns the current TAB jump

                        For Pure-C: int16 *TabWidth;

                        For Pure-Pascal: TabWidth: ^Integer;

!label AUO_EDTABSIZE
 !item [AUO_EDTABSIZE]     Sets TAB jump.

                        For Pure-C: int16 *TabWidth;

                        For Pure-Pascal: TabWidth: ^Integer;

!label AUO_EDSUB
 !item [AUO_EDSUB]         A text that has been set up in the EDITSUBS
                   structure is transferred - an area can be replaced
                   or inserted. This operation is UNDO capable.

                        For Pure-C: EDITSUBS *TextDescr;

                        For Pure-Pascal: TextDescr: EDITSUBSPtr;

!label AUO_EDGETROWS
 !item [AUO_EDGETROWS]     Returns the number of lines.

                        For Pure-C: long *LineNr;

                        For Pure-Pascal: LineNr: ^LongInt;

!label AUO_EDGETLENGTH
 !item [AUO_EDGETLENGTH]   Returns the length of the current line.

                        For Pure-C: long *LineLen;

                        For Pure-Pascal: LineLen: ^LongInt;

!label AUO_EDGETCURPOS
 !item [AUO_EDGETCURPOS]   Returns the current cursor position.

                        For Pure-C: long *GetCursRow;

                        For Pure-Pascal: GetCursRow: ^LongInt;

!label AUO_EDUNSELECT
 !item [AUO_EDUNSELECT]    Turns selection off.

!label AUO_EDGETSELECT
 !item [AUO_EDGETSELECT]   Enters the selection area into a field with 4
                   values. The assignments of the field are:

                    0  Starting line

                    1  Starting column

                    2  Ending line

                    3  Ending column

                   If no selection is activated, the value -1 is put
                   in the first entry (index 0).

                   If the discontinuous selection is activated, the
                   field must also be initialized as below, then each
                   successive call returns the next area.

                        {0L, 0L, -1L, -1L}

                        For Pure-C: long GetSel[4];

                        For Pure-Pascal:
                        GetSel: ARRAY [0..3] OF LongInt;

!label AUO_EDSETSELECT
 !item [AUO_EDSETSELECT]   Set the selection in the same way as AUO_EDGETSELECT.
                   No 2-dimensional selection can be set!

!label AUO_EDCALL
 !item [AUO_EDCALL]        Set the live routine. The first entry points to
                   the routine. The second one is a parameter that
                   is passed.

                        For Pure-C: EDITLIVE *LiveFkt;

                        For Pure-Pascal: LiveFkt: EDITLIVEPtr;

                   The live routine must have the following type,
                   where 'text' is the text of the current line if
                   the selection mode AUO_ED1SELECT or AUO_ED01SELECT
                   is switched on or an empty string otherwise:

                        For Pure-C:
                        void live( void *obj, char *text );

                        For Pure-Pascal:
                        PROCEDURE live(obj: Pointer; text:
                        Pointer);

!label AUO_EDLIVE
 !item [AUO_EDLIVE]        Calls the live routine.

!label AUO_ED1SELECT
 !item [AUO_ED1SELECT]     Exactly one line can be selected.

!label AUO_ED01SELECT
 !item [AUO_ED01SELECT]    One or no lines can be selected.

!label AUO_EDNSELECT
 !item [AUO_EDNSELECT]     A continuous area can be selected.

!label AUO_EDNMSELECT
 !item [AUO_EDNMSELECT]    An area can be selected discontinuously.

!label AUO_EDCHARSELECT
 !item [AUO_EDCHARSELECT]  The character selection mode is switched on.

!label AUO_EDBLKSELECT
 !item [AUO_EDBLKSELECT]   The block mode (2-dimensional selection) is
                   switched on.

!label AUO_EDVIEW
 !item [AUO_EDVIEW]        The cursor position should come into the visible
                   area.

!label AUO_EDCURON
 !item [AUO_EDCURON]       The cursor is turned on.

!label AUO_EDCUROFF
 !item [AUO_EDCUROFF]      The cursor is turned off.

!label AUO_EDCURHIDE
 !item [AUO_EDCURHIDE]     The cursor is hidden.

!label AUO_EDCURSHOW
 !item [AUO_EDCURSHOW]     The cursor becomes visible again.

!label AUO_EDCURPOS
 !item [AUO_EDCURPOS]      Sets the column position of the cursor.

                        For Pure-C: long *NewCursColumn;

                        For Pure-Pascal: NewCursColumn: ^LongInt;

!label AUO_EDGETPOS
 !item [AUO_EDGETPOS]      Get the number of the current line.

                        For Pure-C: long *GetAktRow;

                        For Pure-Pascal: GetAktRow: ^LongInt;

!label AUO_EDFONT
 !item [AUO_EDFONT]        Sets a new font ID.

                        For Pure-C: int16 *FontID;

                        For Pure-Pascal: FontID: ^Integer;

!label AUO_EDHEIGHT
 !item [AUO_EDHEIGHT]      Sets a new pixel height.

                        For Pure-C: int16 *NewHeight;

                        For Pure-Pascal: NewHeight: ^Integer;

!label AUO_EDCOLOR
 !item [AUO_EDCOLOR]       Sets a new text color.

                        For Pure-C: int16 *NewTextColor;

                        For Pure-Pascal: NewTextColor: ^Integer;

!label AUO_EDCFULL
 !item [AUO_EDCFULL]       Sets the maximum number of visible columns.

                        For Pure-C: long *MaxVColumns;

                        For Pure-Pascal: MaxVColumns: ^LongInt;

                   The maximum is currently 512.

!label AUO_EDAPPLINE
 !item [AUO_EDAPPLINE]     The text is appended to the current line.

                        For Pure-C: char *Text;

                        For Pure-Pascal: Text: Pointer;

!label AUO_EDWRAP
 !item [AUO_EDWRAP]        After how many lines should the first lines be lost?
                   For editors, the number should simply be very large
                   (e.g. 999 999 999).

                        For Pure-C: long *WrapLines;

                        For Pure-Pascal: WrapLines: ^LongInt;

                   (!B)Important(!b): The WRAP value must be realistic because
                   all lines are requested at once.

!label AUO_EDDELETE
 !item [AUO_EDDELETE]      All text content is deleted.

!label AUO_EDUPDATE
 !item [AUO_EDUPDATE]      The editor is refreshed without the Slider.

!label AUO_EDHCOL
 !item [AUO_EDHCOL]        Sets the column that is visible on the left.

                        For Pure-C: long *LeftColumn;

                        For Pure-Pascal: LeftColumn: ^LongInt;

!label AUO_EDHROW
 !item [AUO_EDHROW]        Sets the line that is visible at the top.

                        For Pure-C: long *TopRow;

                        For Pure-Pascal: TopRow: ^LongInt;

!label AUO_EDNEWLINE
 !item [AUO_EDNEWLINE]     Adds a new line to the end. This becomes the
                   current line.

                   (!B)Important(!b): The WRAP value must be realistic
                   because all lines are requested at once.

!label AUO_EDVERSLIDER
 !item [AUO_EDVERSLIDER]   Returns the identity of the vertical slider.

!label AUO_EDHORSLIDER
 !item [AUO_EDHORSLIDER]   Returns the identity of the horizontal slider.

!label AUO_EDSLIDERS
 !item [AUO_EDSLIDERS]     Only the Sliders are refreshed.

!label AUO_EDGETVCURPOS
 !item [AUO_EDGETVCURPOS]  Returns the visual cursor position. Because of
                   the tabs this can deviate from the logical position.

!label AUO_EDGETHCOL
 !item [AUO_EDGETHCOL]     Returns the number of the left visible column.

!label AUO_EDGETHROW
 !item [AUO_EDGETHROW]     Returns the number of the top visible line.

!label AUO_EDGETERROR
 !item [AUO_EDGETERROR]    Get the error status. Out of memory sets bit 0.
                   This allows you to react to errors yourself.

                        For Pure-C: int16 *ErrStatus;

                        For Pure-Pascal: ErrStatus: ^Integer;

!label AUO_EDRESETERROR
 !item [AUO_EDRESETERROR]  Reset the error flag.

!label AUO_EDPUTINFO
 !item [AUO_EDPUTINFO]     (is no longer supported)
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Editor (A_editor/Aus_editor)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Auo_ftext

 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for Userdef-FText

 !item [Category:]          User defined objects, Userdef-FText

 !item [C:]                 int16 Auo_ftext( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_ftext(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine is the service routine for the Userdefs-FText.

This service routine processes the following messages - with their
data types for the pointer in_out -, all other messages are passed
on to the Auo_string function:

!begin_xlist [AUO_FTEFFECTS]
!label AUO_FTFONT
 !item [AUO_FTFONT]       Set a new Fontid

                       For Pure-C: int16 *fontID;

                       For Pure-Pascal: fontID: ^Integer;

!label AUO_FTHEIGHT
 !item [AUO_FTHEIGHT]     Set the height from 0..255

                       For Pure-C: int16 *fontHeight;

                       For Pure-Pascal: fontHeight: ^Integer;

 !item [AUO_FTCOLOR]      Sets new color for the text 0..15

                       For Pure-C: int16 *textColor;

                       For Pure-Pascal: textColor: ^Integer;

 !item [AUO_FTEFFECTS]    Sets an effect

                   Bit 0  Bold

                   Bit 1  Light

                   Bit 2  Cursive

                   Bit 3  Underlined

                   Bit 4  Hollow (Outlined)

                   Bit 5  Shaded (is documented, just doesn't work :-(

                       For Pure-C: int16 *effekt;

                       For Pure-Pascal: effekt: ^Integer;

!label AUO_FTLEFT
 !item [AUO_FTLEFT]       Sets left-justified

!label AUO_FTRIGHT
 !item [AUO_FTRIGHT]      Sets right-justified

!label AUO_FTCENTER
 !item [AUO_FTCENTER]     Sets centered

!label AUO_FTBLOCK
 !item [AUO_FTBLOCK]      Sets justification
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item FText (A_ftext)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Auo_picture

 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for the Userdef-Picture

 !item [Category:]          User defined objects, Userdef-Picture

 !item [C:]                 int16 Auo_picture( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_picture(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the convenient service routine of the Userdef-
Picture dar.

The following messages - with their data types for the pointer
in_out - are processed:

!begin_xlist [AUO_FULLUPDATE]
 !item [AUO_CREATE]      The internal data structures are created and
                 initialized.

                      For Pure-C: int16 *success;

                      For Pure-Pascal: success: ^Integer;

 !item [AUO_TERM]        Releases the internal structures.

!label AUO_PICMFDB
 !item [AUO_PICMFDB]     Accepts the new MFDB as an image. The MFDB is not
                 copied because images take up a lot of space. However,
                 this means that the MFDB must exist until a new one is
                 transferred or the user definition is terminated. The
                 MFDB must be in the standard format!

 !item [AUO_SELF]        Sets the identity

                      For Pure-C: Awiob *ident;

                      For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_FULLUPDATE]  Redraws the object completely.

 !item [AUO_UPDATE]      Redraws the object completely.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Picture (A_picture)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Auo_slider

!label Auo_wislider
 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for the Userdef-Slider

 !item [Category:]          User defined objects, Userdef-Slider

 !item [C:]                 int16 Auo_slider( OBJECT *entry, int16 task,
                             void *in_out);
                    int16 Auo_wislider( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_slider(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer; Function Auo_wislider(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the convenient service routine of the Userdef-
Slider or the Userdefs "Window-Slider".

The following messages - with their data types for the pointer
in_out - are processed:

!begin_xlist [AUO_FULLUPDATE]
 !item [AUO_CREATE]      The internal data structures are created and
                 initialized.

                      For Pure-C: int16 *success;

                      For Pure-Pascal: success: Integer;

 !item [AUO_TERM]        Releases the internal structures.

 !item [AUO_SELF]        Provides the userdef with their own identity.

                      For Pure-C: Awiob *ident;

                      For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_OWNER]       The identity of the userdef is read. To do this,
                 a pointer to the Awiob structure is passed in
                 in_out:

                      For Pure-C: Awiob *ident;

                      For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_FULLUPDATE]  Completely refreshes the object. The delta mode
                 is deleted

 !item [AUO_UPDATE]      Refreshes the necessary parts of the Slider. 
                 Which parts are necessary depends on the previous
                 actions.

 !item [AUO_SETVAL]      (!I)Not with the Window-Slider:(!i) Resets the text in
                 the slider (maximum 11 characters).

                      For Pure-C: char *text;

                      For Pure-Pascal: text: Pointer;

 !item [AUO_GETVAL]      (!I)Not with the Window-Slider:(!i) Returns the pointer
                 to the slider text.

                      For Pure-C: char *text;

                      For Pure-Pascal: text: Pointer;

 !item [AUO_NEXT]        Goes one step ahead

 !item [AUO_PREV]        Goes one step back

 !item [AUO_NEXTPAGE]    Goes one page ahead

 !item [AUO_PREVPAGE]    Goes one page back

 !item [AUO_BEGIN]       Jump to the beginning

 !item [AUO_END]         Jump to the end

!label AUO_SLCALL
 !item [AUO_SLCALL]      Set the live routine. Two pointers are passed.
                 The first points to the live routine. The second
                 (obj) is given to the live routine when it is called.

                      For Pure-C: SLLIVE *LiveFkt;

                      For Pure-Pascal: LiveFkt: SLLIVEPtr;

                 The live routine must have the following type (where
                 pos is the current position):

                      For Pure-C:
                      char *sl_live( void *obj, long pos );

                      For Pure-Pascal:
                      FUNCTION live( obj: Pointer; pos: LongInt)
                      : Pointer;

                 The return value is used as slider text.

!label AUO_SLFULL
 !item [AUO_SLFULL]      Sets the full area

                      For Pure-C: long *set_full;

                      For Pure-Pascal: set_full: ^LongInt

!label AUO_SLSIZE
 !item [AUO_SLSIZE]      Sets the slider size. At the same time, this is
                 the step size for side operations.

                      For Pure-C: long *set_size;

                      For Pure-Pascal: set_size: ^LongInt

!label AUO_SLLEN
 !item [AUO_SLLEN]       (!I)Not with the Window-Slider:(!i) Sets the length of the
                 slider text.

                      For Pure-C: long *set_len;

                      For Pure-Pascal: set_len: ^LongInt

!label AUO_SLSTEP
 !item [AUO_SLSTEP]      Sets the step size for individual steps.

                      For Pure-C: long *set_step;

                      For Pure-Pascal: set_step: ^LongInt

!label AUO_SLWIPOS
 !item [AUO_SLWIPOS]     (!I)Just for the Window-Slider:(!i) Sets the position
                 directly in WF_HSLID/WF_WSLID format.

                      For Pure-C: long *set_pos;

                      For Pure-Pascal: set_pos: ^LongInt

 !item [AUO_POS]         Sets the position directly.

                      For Pure-C: long *set_pos;

                      For Pure-Pascal: set_pos: ^LongInt

!label AUO_SLLIVE
 !item [AUO_SLLIVE]      Calls the live routine

!label AUO_SLGETPOS
 !item [AUO_SLGETPOS]    Get the current position

                      For Pure-C: long *get_pos;

                      For Pure-Pascal: get_pos: ^LongInt
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Slider (A_slider/Aus_slider)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Auo_string

 !begin_blist [Definition:]
 !item [Summary:]           Service Routine for the String-like Userdefs

 !item [Category:]          User defined objects, Userdef-Checkbox,
                    Radio-Button, Userdef-3D-Button, Userdef-
                    Innerframe

 !item [C:]                 int16 Auo_string( OBJECT *entry, int16 task,
                             void *in_out );

 !item [Pascal:]            Function Auo_string(
                                   entry: ACSOBJECTPtr; task: INTEGER;
                                   in_out: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the convenient service routine of the Userdefs
Checkbox, Radiobutton, 3D-Button and Innerframe.

The following messages - with their data types for the pointer
in_out - are processed:

!begin_xlist [AUO_FULLUPDATE]
 !item [AUO_CREATE]      The string of the template (ub_ptr1) is allocated
                 and assigned to ub_ptr1. Errors are reported by
                 assigning FAIL to the transferred variable *in_out.

                      For Pure-C: int16 *success;

                      For Pure-Pascal: success: ^Integer;

 !item [AUO_SELF]        Sets the identity of the Userdef via the parameter
                 in_out, which refers to an Awiob structure. The
                 window is assigned to ub_ptr2, the object number
                 is entered in ub_ptr3.

                      For Pure-C: Awiob *ident;

                      For Pure-Pascal: ident: AwiobPtr;

 !item [AUO_TERM]        The string is released

 !item [AUO_SETVAL]      A new string is entered.

                      For Pure-C: char *text;

                      For Pure-Pascal: text: Pointer;

 !item [AUO_FULLUPDATE]
 !item [AUO_UPDATE]      In both cases the Userdef is redrawn, provided a
                 window has been registered with AUO_SELF.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Checkbox, Radiobutton (A_checkbox)

  !item 3D-Button (A_3Dbutton)

  !item Innerframe (A_innerframe)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Aus_boxed

 !begin_blist [Definition:]
 !item [Summary:]           Click routine for the BoxEdit objects
                    (A_boxed/Aus_boxed)

 !item [Category:]          User defined objects, BoxEdit

 !item [C:]                 void Aus_boxed( void );

 !item [Pascal:]            Procedure Aus_boxed( void );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine provides for convenient mouse selection of the Userdefs-
BoxEdit.

A simple click repositions the cursor. Double-clicking selects the
word that is separated by a separator - while successive separators
are also regarded as a word.

If the mouse pointer is moved out of the object while the mouse button
is pressed, the routine tries to scroll the text further at two speeds
and to expand any selection accordingly - by double-clicking word by
word.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item BoxEdit (A_boxed/Auo_boxed)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Aus_create

 !begin_blist [Definition:]
 !item [Summary:]           Create a Userdef

 !item [Category:]          Userdef functions

 !item [C:]                 AUSERBLK *Aus_create( const AUSERBLK *user );

 !item [Pascal:]            Function Aus_create(
                                   user: AUSERBLKPtr
                                ) : AUSERBLKPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Aus_create creates an exact duplicate in 'user' of the
passed Userdef. The Userdef is (!B)not(!b) initialized with AUO_CREATE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Userdef functions

  !item Aus_delete
!end_enumerate

!end_node


!begin_node Aus_cycle

 !begin_blist [Definition:]
 !item [Summary:]           Click routine for the Userdef-Cycle

 !item [Category:]          User defined objects, Userdef-Cycle

 !item [C:]                 void Aus_cycle( void );

 !item [Pascal:]            Procedure Aus_cycle( void );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine provides for convenient mouse selection of the
Userdefs-Cycle.

A click on the down arrow (more precisely on the right 3 char positions)
switches the next value to the display field.

A click on the display field causes a popup to appear, with the current
value being marked with CHECKED. After selection from the list, the new
value is shown in the display field.

Live updates may be realized by a separate click-routine which first
calls Aus_cycle and then correspondingly reacts to the value.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Cycle (A_cycle/Auo_cycle)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Aus_delete

 !begin_blist [Definition:]
 !item [Summary:]           Release a Userdef

 !item [Category:]          Userdef functions

 !item [C:]                 void Aus_delete( AUSERBLK *user );

 !item [Pascal:]            Procedure Aus_delete( user : AUSERBLKPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Aus_delete function releases the memory space of the transferred
AUSERBLK structure. The Userdef is (!B)not(!b) ended with AUO_TERM.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Userdef functions

  !item Aus_create
!end_enumerate

!end_node


!begin_node Aus_editor

 !begin_blist [Definition:]
 !item [Summary:]           Click routine for the Userdef-Editor

 !item [Category:]          User defined objects, Userdef-Editor

 !item [C:]                 void Aus_editor( void );

 !item [Pascal:]            Procedure Aus_editor( void );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the click routine of the Userdefs-(!link [Editor] [Userdef-Editor]).

This click-routine responds to the selection mode as follows:

!begin_xlist [BLOCK]
 !item [CHAR]   Text selection

         Drag                  Area is selected

         Drag + Shift          Area is expanded

         Double click          Word or clip range is selected

         Double click + Shift  Entire line is selected

 !item [BLOCK]  Text selection

         Drag               Area is selected

         Drag + Shift       Area is expanded

 !item [1]      The current line is selected and the live routine is called

 !item [01]     The current line is selected or deselected and the live
        routine is called.

 !item [N]      Continuous selection

         Drag               Area is selected

         Drag + Shift       Area is expanded

        The live routine is called.

 !item [NM]     Discontinuous selection

         An additional area is selected

        The live routine is called.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Editor (A_editor/Auo_editor)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Aus_help

 !begin_blist [Definition:]
 !item [Summary:]           Click routine for any objects

 !item [Category:]          Userdef functions

 !item [C:]                 void Aus_help( void );

 !item [Pascal:]            Procedure Aus_help( void );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine can be entered as a click routine for any object.
It simply branches in Awi_help for the current window of 
ACSblk->ev_window.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Aev_STGuideHelp, Awi_help
!end_enumerate

!end_node


!begin_node Aus_slider

 !begin_blist [Definition:]
 !item [Summary:]           Click routine for the Userdef-Slider

 !item [Category:]          User defined objects, Userdef-Slider

 !item [C:]                 void Aus_slider( void );

 !item [Pascal:]            Procedure Aus_slider( void );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This routine represents the click routine of the Userdefs-Slider.

This click routine reacts when you click on:

!begin_xlist [Side bars]
 !item [Arrow]         Depending on whether it is a single-click or a
               double-click, the routine reacts as follows

                Click         Change by one step.

                Double click  Jump to the beginning or the end.

 !item [Side bars]     Jump one page.

 !item [Slider]        Drag to the position. Please note that not every
               position can be reached by dragging.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Slider (A_slider/Auo_slider)

  !item User defined objects
!end_enumerate

!end_node


!begin_node Avdi_getRGB

 !begin_blist [Definition:]
 !item [Summary:]           RGB color values of the NVDI colors

 !item [Category:]          Other functions

 !item [C:]                 const RGBColor * const Avdi_getRGB( int16 index );

 !item [Pascal:]            Function Avdi_getRGB( index: Integer ) :
                    RGBColorPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Avdi_getRGB function returns the RGB values of the NVDI color
palette (from NVDI 5.x). This means that objects that are matched
to the color palette can also be drawn correctly under Hicolor or
Truecolor resolutions.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions
!end_enumerate

!end_node


!begin_node Awindow

The structure Awindow is the fundamental structure that contains
the window data and the window functions.

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   void *user;
   int16 (*service)( Awindow *window, int16 task,
      void *in_out );
   Awindow *(*create)( void *a );
   int16 (*open)( Awindow *window );
   int16 (*init)( Awindow *window );
   OBJECT *work;
   OBJECT *toolbar;
   int16 ob_edit, ob_col;
   int16 wi_id;
   int16 wi_kind;
   Axywh wi_act;
   Axywh wi_normal;
   Axywh wi_work;
   Axywh wi_slider;
   int16 wi_nx, wi_ny;
   int16 snap_mask;
   char *name;
   char *info;
   int16 ob_len;
   int16 kind;
   int16 state;
   int16 icon;
   CICONBLK *iconblk;
   OBJECT *menu;
   int16 (*keys)( Awindow *window, int16 kstate,
      int16 key );
   void (*obchange)( Awindow *window,
      int16 obnr, int16 new_state );
   void (*redraw)( Awindow *window, Axywh *rect );
   void (*topped)( Awindow *window );
   void (*closed)( Awindow *window );
   void (*fulled)( Awindow *window );
   void (*arrowed)( Awindow *window, int16 which );
   void (*hslid)( Awindow *window, int16 pos );
   void (*vslid)( Awindow *window, int16 pos );
   void (*sized)( Awindow *window, Axywh *rect );
   void (*moved)( Awindow *window, Axywh *rect );
} Awindow;
!end_sourcecode

The definition for Pure-Pascal reads:

!label AwindowPtr
!begin_sourcecode
AwindowPtr = ^Awindow;

Awindow = RECORD
      user:       Pointer;
      service:    Function( w: AwindowPtr; task: Integer;
         in_out: Pointer ) : Boolean;
      create:     Function( a: Pointer ) : AwindowPtr;
      open:       Function( w: AwindowPtr ) : Integer;
      init:       Function( w: AwindowPtr ) : Integer;
      work:       ACSTreePtr;
      toolbar:    ACSTreePtr;
      ob_edit, ob_col:  Integer;
      wi_id:      Integer;
      wi_kind:    Integer;
      wi_act:     Axywh;
      wi_normal:  Axywh;
      wi_work:    Axywh;
      wi_slider:  Axywh;
      wi_nx, wi_ny: Integer;
      snap_mask:  Word;
      name:       Pointer;
      info:       Pointer;
      ob_len:     Integer;
      kind:       Integer;
      state:      Integer;
      icon:       Integer;
      iconblk:    CICONBLKPtr;
      menu:       ACSTreePtr;
      keys:       Function( w: AwindowPtr; kstate: Integer;
                     key: Integer ) : Integer;
      obchange:   Procedure( w: AwindowPtr; obnr: Integer;
                     new_state: Integer );
      redraw:     Procedure( w: AwindowPtr );
      topped:     Procedure( w: AwindowPtr );
      closed:     Procedure( w: AwindowPtr );
      fulled:     Procedure( w: AwindowPtr );
      arrowed:    Procedure( w: AwindowPtr );
      hslid:      Procedure( w: AwindowPtr );
      vslid:      Procedure( w: AwindowPtr );
      sized:      Procedure( w: AwindowPtr );
      moved:      Procedure( w: AwindowPtr );
   END;
!end_sourcecode

The components of the structure mean here:

!begin_xlist [wi_slider]
 !item [user]       Pointer to the (!link [User Data] [Awindow.user]) of the window.

 !item [service]    The (!link [Service Routine] [Awindow.service]) provides the functionality
            of the window to the outside world.

 !item [create]     The (!link [Create Routine] [Awindow.create]) is called to create the window.

 !item [open]       The (!link [Open Routine] [Awindow.open]) of the window.

 !item [init]       The (!link [Init Routine] [Awindow.init]) of the window.

 !item [work]       The (!link [Work Object] [Awindow.work]) of the window.

 !item [toolbar]    The (!link [Toolbar] [Awindow.toolbar]) of the window.

 !item [ob_edit]    The current (!link [Edit Field] [Awindow.ob_edit]).

 !item [ob_col]     The current (!link [Cursor Position] [Awindow.ob_col]).

 !item [wi_id]      The GEM window ID is noted here.

!label Awindow.wi_kind
 !item [wi_kind]    The bit field of the GEM window attributes is entered
            here.  The values are only sent to GEM when the window
            is opened.

 !item [wi_act]     The (!link [Outer Coordinates] [Awindow.wi_act]) of the GEM window are stored in
            this structure.

 !item [wi_normal]  The saved (!link [Normal Values] [Awindow.wi_normal]) before the FULLED state.

 !item [wi_work]    This rectangle describes the inner (!link [Work Area] [Awindow.wi_work]) without
            the menu bar and without the toolbar.

 !item [wi_slider]  The values stored here control the refreshing of the
            (!link [Window Slider] [Awindow.wi_slider]).

 !item [wi_nx]      x-(!link [Offset] [Awindow.wi_nx]) of the work object.

 !item [wi_ny]      y-(!link [Offset] [Awindow.wi_ny]) of the work object.

 !item [snap_mask]  The (!link [Grid] [Awindow.snap_mask]) of the window.

 !item [name]       The (!link [Name (Title Bar)] [Awindow.name]) of the window.

 !item [info]       The (!link [Info Line] [Awindow.info]) of the window.

 !item [ob_len]     The (!link [Length] [Awindow.ob_len]) of a selected area of a input field.

!label Awindow.kind
 !item [kind]       The type of window is described by kind.  The defined
            window flags are available as constants.

!label Awindow.state
 !item [state]      The status of the window is stored in this component.
            The defined window status flags are available as
            constants.

 !item [icon]       The (!link [Object Number] [Awindow.icon]) of the iconified window in the window
            that manages the icon (usually PUR_DESK or DESKTOP).

 !item [menu]       The (!link [Menu Bar] [Awindow.menu]) of the window.

 !item [keys]       This routine reacts to (!link [Keyboard Input] [Awindow.keys]).

!label Awindow.obchange
 !item [obchange]   This pointer points to the routine that can quickly
            draw status changes to objects.  The default routine
            is called Awi_obchange and is not usually replaced.

!label Awindow.redraw
 !item [redraw]     The specified region of the window is redrawn. The
            default routine is called Awi_redraw and is not
            usually replaced.

 !item [topped]     This (!link [Routine] [Awindow.topped]) brings forward the window.

 !item [closed]     The (!link [Routine] [Awindow.closed]) referred to by this pointer closes the window.

 !item [fulled]     The (!link [Routine] [Awindow.fulled]) noted here reacts to selecting the FULL box
            of the window.

!label Awindow.arrowed
 !item [arrowed]    This routine uses the arrows and scrolls page-wise.
            The default routine is Awi_arrowed.

!label Awindow.hslid
 !item [hslid]      Called when the horizontal slider is used.  The default
            routine is Awi_hslid.

!label Awindow.vslide
 !item [vslid]      Called when the vertical slider is used.  The default
            default routine is Awi_vslid.

 !item [sized]      This routine handles (!link [Size Changes] [Awindow.sized]) of the window.

!label Awindow.moved
 !item [moved]      This routine manages changes in the position of the
            window.  The default routine is Awi_moved.
!end_xlist

!end_node


!begin_node Awindow.user

This pointer references the user data of the window. This makes it
possible to bind data locally to a window structure, which can then
be generated as often as required.

Example:

!begin_sourcecode
/* Somewhere in the program where a window should */
/* be created according to the class F_ADR ...    */
new_win = F_ADR.create(NULL);

/* The create routine entered */
/* in the variable F_ADR      */
static Awindow *adr_create( void *para );
{
   ADR_BLOCK *adr;
   Awindow   *new_wi;

   /* Create a new window */
   new_wi=Awi_create(&F_ADR);
   if( new_wi==NULL )
      return NULL;

   /* Create the data for the window */
   adr = Ax_malloc(sizeof(ADR_BLOCK));
   if( adr==NULL )
   {
      /* Memory could not be allocated */
      Awi_delete(new_wi);
      return NULL;
   }

   /* Memory initialization */
   memset(adr, 0, sizeof(ADR_BLOCK));

   /* Note the data created in the window structure */
   new_wi->user = adr;

   return new_wi;
}
!end_sourcecode

!end_node


!begin_node Awindow.service

The pointer to the routine that processes the messages for the window
is entered here. The standard routine is called Awi_service. It is
usually replaced by a user's own, which is important if you e.g. would
like to react to the (!link [window termination] [AS_TERM]). This is necessary if memory
is allocated in the (!link [Create Routine] [Awindow.create]) and entered in the user pointer,
which must be released when the window is terminated. Or you can
insert a security question here whether the window should really be
deleted.

(!I)It is important that all messages not consumed should be forwarded
to Awi_service. As of version 2.4, Iconify is no longer performed
by Awi_service, but by Awi_iconify etc., but in this way windows
can benefit from later extensions of the Awi_service routine!(!i)

Care should be taken to ensure that the return value is correct. If
the return value FALSE is returned for a message, the window either
does not know this message or an error has occurred while processing
the message. The return value TRUE always signals that the message
was processed successfully. For all queries of values or similar the
pointer in_out is available, which is defined appropriately depending
on the message or can be passed appropriately for any self-defined
messages.

Example:

!begin_sourcecode
static int16 service_adr( Awindow *this, int16 task, void *para )
{
   ADR_BLOCK *adr;
   char *frage="[2][Wirklich beenden?][OK|Abbruch]";

   switch(task)
   {
      case AS_TERM:
         if( !appexit && Awi_alert(1, frage)==2 )
            return TRUE;

         adr = wi->user;
         Ax_free(adr);
         Awi_delete(this);
#ifdef __ACS_MODULE__
         ACSmoduleterm ();
#endif
         break;

      default:
         return Awi_service(this, task, para);
   }

   return TRUE;
}
!end_sourcecode

!end_node


!begin_node Awindow.create

The pointer to the create routine is entered here. The create
routine takes all measures to create the window. This can be the
creation of user-defined structures, this can be asking for a file
name. For create, there is the standard routine Awi_selfcreate.

An example can be found at (!link [user] [Awindow.user]).

!end_node


!begin_node Awindow.open

The pointer to the open routine is entered here. The return value
will inform you about the success of the opening. Possible values
are OK or FAIL.

An alternative is for windows whose icons on the desktop only serve
as a 'start' for further actions. Then, for example, a file can be
determined using A_fileselect and a window opened with it - as happens
with the IMG-EDIT or IMG-VIEW module. A popup may also appear, which
allows more detailed functions.

Example:

!begin_sourcecode
static int16 open_adr( Awindow *this )
{
   /* further actions by Popup */
   Ame_popup(wi, &P_ADR, ev_mmox, ev_mmoy);
   return OK;
}
!end_sourcecode

!end_node


!begin_node Awindow.init

The purpose of this routine is to dynamically adjust the inner
object. However, the adjustment should only be carried out when it
is necessary, to avoid unnecessary work.

The standard routine Awi_init simply does nothing.

This routine is called if the flag AWS_MODIFIED is found when the
window is opened. This flag is set when the window is created.

If you set AWS_LATEUPDATE, this routine is called after all other
events (especially the time events) have been processed. If you set
AWS_LATEUPDATE within your own routine, this routine is called again
after and then after the next event. This enables pseudo-cooperative
multitasking between the windows within (!I)ACSpro(!i). Then you should take
care that ev_mtcount is set to 'balanced'.

Example:

!begin_sourcecode
/* real time difference */
static long timer200( void )
{
   return *((long *) 0x4BA);
}

/* The init routine entered in the structure */
static adr_init( Awindow *this )
{
   this->state |= AWS_LATEUPDATE;
   new_timer = Supexec(timer200);
   if( new_timer-old_timer>=200l )
   {
      old_timer = new_timer;

      /* refresh the display every new second */

      /* ... */
   }

   return OK;
}
!end_sourcecode

!end_node


!begin_node Awindow.work

The work object tree (non-modal dialog, inner object tree) is
entered here, which, in contrast to the toolbar, also allows fields
with text input. If there is no object tree, NULL or NIL is entered.

If you want to briefly exchange a menu, toolbar or work object tree
for an existing window class (e.g. to take over all other properties
of the class otherwise), the best way to do this is as in the following
example:

!begin_sourcecode
     old_menu = &PROTOCOL.menu;
     PROTOCOL.menu = &MY_MENU;
     new_proto = PROTOCOL.create(NULL);
     PROTOCOL.menu = old_menu;
!end_sourcecode

!end_node


!begin_node Awindow.toolbar

The toolbar object tree is entered here. If there is no toolbar,
NULL or NIL is to be entered.

The toolbar object tree is the same as the menu or work object tree
except for the lack of a text entry field, but it is not moved in
the event of scrolling events, but remains at the top. Furthermore,
the width of the tool object tree father is always adjusted to the
inner window width.

See an example at (!link [work] [Awindow.work]).

!end_node


!begin_node Awindow.ob_edit

ob_edit references the current edit field in the work object tree.
If there is no current edit field, -1 is entered.

Awindow.ob_col indicates the current cursor position within the
input field. If -1 is entered here, the complete text will be marked
at the next opportunity.

Example:

!begin_sourcecode
     /* Finish input, hide cursor, ... */
     Awi_diaend();

     /* ... reposition the cursor, ... */
     wi->ob_edit = D_ADRINPUT;

     /* ... place the cursor at the end of the field ... */
     wi->ob_col = -1;

     /* ... Make the cursor visible and start typing */
     Awi_diastart();
!end_sourcecode

!end_node


!begin_node Awindow.ob_col

ob_col indicates the current cursor position within the input field.
If -1 is entered here, the complete text will be marked at the next
opportunity.

Awindow.ob_edit references the current edit field in the work object
tree. If there is no current edit field, -1 is entered.

An example of Awindow.ob_col can be found at Awindow.ob_edit.

!end_node


!begin_node Awindow.wi_id

Here either the AES window id is entered, or -1 if the window does
not currently have a GEM window.

(!I)This value should not be changed by the user.(!i)

!end_node


!begin_node Awindow.wi_act

The outer coordinates of the GEM window are stored in this structure.


!image (!IMAGES)coord2.img

!end_node


!begin_node Awindow.wi_normal

This is where the wi_act values are saved before the window changes
to the FULLED state. After returning to normal mode, these values
become wi_act again.


If the window is in the AWS_ICONIZED state, the dimensions of the
original Awindow.wi_act rectangle are saved here.

!end_node


!begin_node Awindow.wi_work

This rectangle describes the inner work area without the menu bar
and toolbar. (!I)These values should not be modified by the user.(!i)


!image (!IMAGES)coord1.img

!end_node


!begin_node Awindow.wi_slider

These values control the refreshing of the slider. The sliders are
only reset if the values change during corresponding user actions.

!begin_xlist [wi_slider.x]
 !item [wi_slider.x]  Contains the X position of the horizontal slider in
              parts per thousand (left = 1, right = 1000)

 !item [wi_slider.y]  Contains the Y position of the vertical slider in
              parts per thousand (left = 1, right = 1000)

 !item [wi_slider.w]  Contains the size of the horizontal slider in parts
              per thousand (minimum = 1, maximum = 1000)

 !item [wi_slider.h]  Contains the size of the vertical slider in parts
              per thousand (minimum = 1, maximum = 1000)
!end_xlist

!end_node


!begin_node Awindow.wi_nx

The offset of the work object is saved here before the window changes
to the AWS_FULL state. When returning to normal mode, these values
are used to restore the original state.

(!I)These are internal values that should not be changed by the user.(!i)

!end_node


!begin_node Awindow.wi_ny

The offset of the work object is saved here before the window changes
to the AWS_FULL state. When returning to normal mode, these values
are used to restore the original state.

(!I)These are internal values that should not be changed by the user.(!i)

!end_node


!begin_node Awindow.snap_mask

This value determines the grid on the screen in which the window and
the work object are placed and moved. The object is only displayed
within this grid. This also defines the step size for any scrolling
operations. Since it is a mask, only powers of 2 can be selected. The
high byte is responsible for the Y-coordinates and the low byte for
the X-coordinates.

     (!B)From step size 16, the screen structure becomes considerably
     faster, since word limits are always hit in the VDI.(!b)

 Mask   Step

 0xff   1 Any position possible

 0xfe   2

 0xfc   4

 0xf8   8

 0xf0   16

 0xe0   32

 0xc0   64

!end_node


!begin_node Awindow.name

The pointer to the window name is entered here.

If you want to change this name, the procedure in the following
example is recommended:

!begin_sourcecode
     old_name = wi->name;
     wi->name = Ast_create("Neuer Name");

     if( wi->name==NULL )
        wi->name = old_name;
     else
     {
        Ast_delete(old_name);
        wind_set(wi->wi_id, WF_NAME, wi->name);
     }
!end_sourcecode

!end_node


!begin_node Awindow.info

The pointer to the Window info line is stored here.

If you want to change this info, the procedure in the following
example is recommended:

!begin_sourcecode
     old_info = wi->info;
     wi->info = Ast_create("Mausposition: 10, 45"):

     if( wi->info==NULL )
        wi->info = old_info;
     else
     {
        Ast_delete(old_info);
        wind_set(wi->wi_id, WF_INFO, wi->info);
     }
!end_sourcecode

!end_node


!begin_node Awindow.ob_len

If a selection is active in the input field described by
Awindow.ob_edit, its length is entered here. A value <=0 indicates
that no selection is active. Awindow.ob_col is always the cursor
position or the start of the selection.

!end_node


!begin_node Awindow.icon

The value denotes the object number of the iconized window in the
icon-managing window (generally this is the root window which can
be determined with Awi_root). If there is none, it is -1.

(!B)For example, if you want to determine the rectangle of the icon,
you must test whether the (root) window in question even has a work
area at all.(!b)

This value must not be changed.

!end_node


!begin_node Awindow.iconblk

A separate icon can be assigned to the window, which is entered
here. Otherwise it is NULL or NIL.

This icon is not only used for (!I)ACSpro(!i)'s own icon management, but
also for the system iconify.

!end_node


!begin_node Awindow.menu

The optional menu bar is entered here. If there is no menu bar,
NULL or NIL is entered.

See an example at (!link [work] [Awindow.work]).

!end_node


!begin_node Awindow.keys

Reference is made here to the routine which operates the keyboard
inputs. The default routine is called Awi_keys..

As of (!I)ACSpro(!i) version 2.20, this routine must return an int16
value, based on which it is evaluated whether a key press has been
processed or can or should be forwarded to an existing AV-server. The
return value indicates to (!I)ACSpro(!i) the following:

!begin_xlist [>=0]
 !item [>=0]  The key was processed by the object with this number. In
      Awi_dialog this is the starting criterion.

 !item [-1]   This key was not processed, but should not be passed on.

 !item [-2]   This key was not processed and should be passed on to the
      AV-server.
!end_xlist

If the window is in a modal window dialog, a positive value means
that the dialog should be ended with this object number.

The parameter kstate is actually superfluous, because due to the
NKCC code, all information is available in key - it was only
adopted for reasons of compatibility with old versions.

Example:

!begin_sourcecode
int16 adr_key( Awindow *this, int16 kstate, int16 key )
{
   if( key<0 )
   {
      /* a function key or    */
      /* a shortcut was pressed */
   }

   /* no processing */
   if( wi->state & AWS_MODAL_WIN )
      return -1;
   else
      return 0;
}
!end_sourcecode

!end_node


!begin_node Awindow.topped

The window should be topped up. The default routine is Awi_topped.

If you include your own routine here, you can, for example, make
the topping dependent on some condition that tests whether the
topping is desired or not.

Example:

!begin_sourcecode
static void adr_topped( Awindow *this )
{
   /* Only top when the mouse is */
   /* inside, not outside!       */
   if( Aob_within(&wi->wi_act, ev_mmox, ev_mmoy) )
   {
      Awi_topped(this);
   }
}
!end_sourcecode

!end_node


!begin_node Awindow.closed

The window should be closed. The default routine is Awi_closed.

For example, if you display a list of files in the window and only
really want to close the window if you are in the main directory
of the drive, you can avoid closing it, as the following example
shows:

!begin_sourcecode
static void file_close( Awindow *this )
{
   FILE_BLOCK  *fb;

   fb = wi->user;
   if( fb==NULL
         || fb->aktuelle_ordner_tiefe==0
         || (wi->state & AWS_ICONIZED) )
      Awi_closed(this);
   else
   {
      /* jump up a folder */
   }
}
!end_sourcecode

(!B)Attention:(!b)
(!I)If AW_ICON is not set in the child component of the window
i.e. the window does not have an (!i)(!I)ACSpro(!i)(!I) icon state, the
service routine is called directly with AS_TERM.(!i)

Often, however, one would like to create some window dialogs in
advance without leaving an icon on the desktop. In this case you
should first delete the AW_ICON bit in the create routine, create
the window and again in the instance set the AW_ICON bit. The
close routine is then called, in which you should use a trick so
that no icon appears:

!begin_sourcecode
static void adr_close( Awindow *this )
{
   this->state |= AWS_TERM;
   Awi_closed(this);
   this->state &= ~AWS_TERM;
}
!end_sourcecode

This routine is also called when the system iconify goes for these
windows. In this case, AWS_ICONIZED is already set and if possible
Awi_closed should be called. If system iconify is not desired for
this window, you should delete this state and not call Awi_closed.

!end_node


!begin_node Awindow.fulled

Here is the pointer to the routine that services the selection of
the FULL box. The default routine is called Awi_fulled.

A separate routine is always necessary when dimensions of certain
objects have to adapt to the new size, because Awi_fulled only
switches between the original and the maximum dimensions of the
work parent object.

In this case, please note that (!I)ACSpro(!i) optimizes the redraw and in
such a case it may be necessary to force the complete redraw with
AWS_FORCEREDRAW. You should also inform affected objects about the
size change via a message (e.g. UserDef Editor with AUO_EDRESIZE).

Example:

!begin_sourcecode
static void adr_fulled( Awindow *this )
{
   if( this->state & AWS_FULL )
   {
      /* Parent object to previous inner dimensions */
      wind_calc(WC_WORK, this->wi_kind,
                this->wi_normal.x, this->wi_normal.y,
                this->wi_normal.w, this->wi_normal.h,
                &dum, &dum,
                &this->work[0].ob_width,
                &this->work[0].ob_height);
      this->state &= ~AWS_FULL;
   }
   else
   {
      /* Work dimensions relative to desktop dimensions */
      wind_calc(WC_WORK, this->wi_kind,
                desk.x, desk.y,
                desk.w, desk.h,
                &dum, &dum,
                &this->work[0].ob_width,
                &this->work[0].ob_height);
      this->state |= AWS_FULL;
   }

   /* Calculate outside dimensions */
   wind_calc(WC_BORDER, this->wi_kind,
             this->wi_work.x, this->wi_work.y,
             this->wi_work.w, this->wi_work.h,
             &this->wi_act.x, &this->wi_act.y,
             &this->wi_act.w, &this->wi_act.h)

   /* Call your own sized routine */
   (wi->sized)(this, &this->wi_act);
   wind_set(this->wi_id, WF_CURRXYWH,
            this_act->x, this_act->y, this_act->w, this_act->h);
}
!end_sourcecode

!end_node


!begin_node Awindow.sized

This routine manages changes in size. The default routine is called
Awi_sized.

The same applies here as with (!link [fulled] [Awindow.fulled]) in that (!I)ACSpro(!i) does not know
whether certain objects should adapt to the user request. So objects
may have to be resized. Likewise (!I)ACSpro(!i) optimizes the redraw if, for
example, the real dimensions do not change - then the redraw must be
forced by setting AWS_FORCEREDRAW. In addition, you must be ensure
that some objects (e.g. A_editor) are informed of this changed size
for internal purposes by means of the message (AUO_EDRESIZE).

Example:

!begin_sourcecode
static_void size_adr( Awindow *this, Axyh *rect )
{
   OBJECT  *entry, *menu, *toolbar;
   int16 x, y;

   entry = this->work;
   menu = this->menu;
   toolbar = this->toolbar;
   wind_calc(WC_WORK, this->wi_kind, 0, 0, area->w, area->h,
             &x, &y,
             &entry->ob_width, &entry->ob_height);

   if( menu!=NULL )
      entry->ob_height -= menu[menu->ob_head].ob_height;

   if( toolbar!=NULL )
      entry->ob_height -= toolbar->ob_height;

   Auo_editor(entry, AUO_EDRESIZE, NULL);
   Auo_editor(entry, AUO_EDSLIDERS, NULL);

   Awi_sized(this, area);
}
!end_sourcecode

!end_node


!begin_node Awiob

This structure is used to describe the indentity of Userdefs.
It contains the window, the pointer to the Userdef in the object
tree and the object number in the tree.

More extensive objects should remember their 'context' so that
when processing messages for the AUSERBLK.service routine all
the required parameters can be determined. For this reason, for
example, an (!link [Editor] [A_editor]) (!B)must(!b), be given its 'context'.

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   Awindow *window;
   OBJECT  *entry;
   int16 obnr;
} Awiob;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
Awiob = RECORD
      window:  AwindowPtr;
      entry:   ACSOBJECTPtr;
      obnr:    Integer;
END;
!end_sourcecode

The components of the structure mean:

!begin_xlist [window]
 !item [window]  Pointer to the window in which the Userdef is displayed.

 !item [entry]   Pointer to the object tree which contains the Userdef.

 !item [obnr]    Number of the Userdef in the object tree.
!end_xlist

!end_node


!begin_node Awi_alert

 !begin_blist [Definition:]
 !item [Summary:]           Display message like form_alert

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_alert( int16 but, char *mess );

 !item [Pascal:]            Function Awi_alert(
                                   but: Integer; mess: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_alert presents a message in a window, completely
analogous to form_alert, which is configured via 'but' and 'mess'.

Depending on the icon, a suitable window title or, if available,
alert_name is used. If there is no more GEM window IDs, form_alert
is immediately jumped to as also in the case of insufficient memory.
The return values are identical to form_alert.

!begin_xlist [mess]
 !item [but]   Specifies which of the buttons should be the default button
       (0=none).

 !item [mess]  The text for mess is structured as follows:

            "[I][ Text line 1 | Text line 2 ][ Button 1 | Button 2 ]"

       Here I is the icon number starting from 1,


!image (!IMAGES)alerts.img

       There is a maximum of 5 lines of text with a maximum of 30
       characters each line, which are separated by '|'. The latter
       also separates each of the (max) three buttons.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item alert_str, Awi_dialog, Awi_alert, Awi_modal
!end_enumerate

!end_node


!begin_node Awi_arrowed

 !begin_blist [Definition:]
 !item [Summary:]           Perform the "arrow" operations

 !item [Category:]          Window functions

 !item [C:]                 void Awi_arrowed( Awindow *window, int16 which );

 !item [Pascal:]            Procedure Awi_arrowed( window: AwindowPtr;
                                   which: Integer);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_arrowed carries out the "arrow" operations.

The parameter which is defined for the GEM message WM_ARROWED:

!begin_xlist [WA_UPPAGE]
!label WA_UPPAGE
 !item [WA_UPPAGE]  Page up

!label WA_DNPAGE
 !item [WA_DNPAGE]  Page down

!label WA_UPLINE
 !item [WA_UPLINE]  Line up

!label WA_DNLINE
 !item [WA_DNLINE]  Line down

!label WA_LTPAGE
 !item [WA_LTPAGE]  Page left

!label WA_RTPAGE
 !item [WA_RTPAGE]  Page right

!label WA_LTLINE
 !item [WA_LTLINE]  Column left

!label WA_RTLINE
 !item [WA_RTLINE]  Column right
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_bubblegem

 !begin_blist [Definition:]
 !item [Summary:]          Display BubbleGEM Help for the object at the
                   coordinates (mx, my)

 !item [Category:]          Window functions, BubbleGEM Protocol

 !item [C:]                 int16 Awi_bubblegem( Awindow *window,
                             int16 mx, int16 my )

 !item [Pascal:]            Function Awi_bubblegem(
                                   window: AwindowPtr; mx, my: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_bubblegem displays a BubbleGEM Help for the object
(from the Work Object or the Toolbar) under the coordinates (mx, my)
if help is available. The procedure of the function is described in
the BubbleGEM Protocol. 

(!B)Note:(!b) The function is called by a short right click with the
mouse in (!I)ACSpro(!i), so it is normally not required.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions, BubbleGEM Protocol

  !item AS_ALLOWBUBBLE, AUO_GETBUBBLE, AS_GETBUBBLE

  !item Awi_context
!end_enumerate

!end_node


!begin_node Awi_closed

 !begin_blist [Definition:]
 !item [Summary:]           Close a window

 !item [Category:]          Window functions

 !item [C:]                 void Awi_closed( Awindow *window );

 !item [Pascal:]            Procedure Awi_closed( window: AwindowPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_closed function closes the window, but keep in mind it still
exists. The associated GEM window is simply closed.

(!B)Important:(!b) If AWS_TERM is set, the window is deleted.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_open
!end_enumerate

!end_node


!begin_node Awi_create

 !begin_blist [Definition:]
 !item [Summary:]           Create a window

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_create( const Awindow *parent );

 !item [Pascal:]            Function Awi_create(
                                   parent: AwindowPtr
                                ) : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_create creates a new window structure.

The parameter parent serves as a template. The window is not yet
visible. Copies of the substructures work, iconblk, menu, name and
info are created if they are defined. Object trees and position
values are converted from character to pixel coordinates. If the
window structure could not be created, NULL or NIL is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_selfcreate

  !item Awi_delete
!end_enumerate

!end_node


!begin_node Awi_delete

 !begin_blist [Definition:]
 !item [Summary:]           Delete a window

 !item [Category:]          Window functions

 !item [C:]                 void Awi_delete( Awindow *window );

 !item [Pascal:]            Procedure Awi_delete( window: AwindowPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_delete deletes the window. All references to the
window are invalid. The substructures work, iconblk, menu, name and
info are released. The window's close routine is called until the
GEM window ID ((!link [wi_id] [Awindow.wi_id])) is released. Very steadfast windows are
removed after 100 attempts with Awi_closed.

Deleting the root window ends the program.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_create

  !item Awi_closed
!end_enumerate

!end_node


!begin_node Awi_diaabort

 !begin_blist [Definition:]
 !item [Summary:]           Exit a modal window dialog

 !item [Category:]          Window functions

 !item [C:]                 void Awi_diaabort( void );

 !item [Pascal:]            Procedure Awi_diaabort;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_diaabort function serves as a click function for setting
the dia_abort flag. This allows you to exit modal window dialogs
such as the "About Me" dialog.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_diaend

 !begin_blist [Definition:]
 !item [Summary:]           End input in an open window dialogue

 !item [Category:]          Window functions

 !item [C:]                 void Awi_diaend( void );

 !item [Pascal:]            Procedure Awi_diaend;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_diaend ends the input in a possibly open dialog,
the input cursor is removed.

The prototype for Pure-C is:

!begin_sourcecode
     void Awi_diaend( void );
!end_sourcecode

The declaration for Pure Pascal is:

!begin_sourcecode
     Procedure Awi_diaend;
!end_sourcecode

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_diastart
!end_enumerate

!end_node


!begin_node Awi_dialog

 !begin_blist [Definition:]
 !item [Summary:]           Carry out a modal window dialog

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_dialog( Awindow *window );

 !item [Pascal:]            Function Awi_dialog(
                                   window: AwindowPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_dialog function carries out a dialog in a window in the same
way as A_dialog.

Any icon for this will be deleted. The window is always put at the
top and at the mouse position when clicked. Routines behind objects
are treated as usual. The window can also be closed using dia_abort.
The window structure is not deleted immediately afterwards - this is
used for evaluating the object tree. A window dialog is ended when the
selected object EXIT and SELECTABLE is set or closed programmatically.
If Awi_dialog (also Awi_alert) is called from A_dialog, the dialog
immediately appears as A_dialog (only the work area)! To prevent any
possible TOUCHEXIT only objects from ending, A_dialog is not ended if
the object only set TOUCHEXIT.

Return values:

!begin_xlist [>=0]
 !item [>=0] Valid return object number

 !item [-1] The opened window dialog was closed externally

 !item [-2] Internal constraints (memory, no ID, etc.) did not allow
    the dialog to appear at all

 !item [-3] Call was illogical (no work object or dialog is already a
    window dialog)
!end_xlist

(!B)Note:(!b) The function A_dialog or A_dialog2 should be replaced by
Awi_dialog. In a multitasking system, users will thank you.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item A_dialog, Awi_doform, Awi_modal, Awi_alert
!end_enumerate

!end_node


!begin_node Awi_diastart

 !begin_blist [Definition:]
 !item [Summary:]           Start input in the open window dialog

 !item [Category:]          Window functions

 !item [C:]                 void Awi_diastart( void );

 !item [Pascal:]            Procedure Awi_diastart;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_diastart starts the text input dialog again. The
input cursor is activated for the object from the window structure
Awindow.ob_edit.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_diaend
!end_enumerate

!end_node


!begin_node Awi_doform

 !begin_blist [Definition:]
 !item [Summary:]           Carry out a modal window dialog

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_doform( Awindow *mod_dia, void *para );

 !item [Pascal:]            Function Awi_doform(
                                   window: AwindowPtr; para: Pointer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_doform function executes a dialog in a window via Awi_dialog.

However, only the necessary window elements for enlarging and for
scrolling are shown. If the call to Awi_dialog was not successful,
A_dialog is used automatically.

(!B)Note:(!b) The required window is created yourself. So that the
template generated by (!I)ACSpro(!i) is transferred directly, Awi_doform
automatically calls Awi_create with the parameter para and also
deletes the window at the end!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item A_dialog, A_dialog2, Awi_modal, Awi_alert
!end_enumerate

!end_node


!begin_node Awi_down

 !begin_blist [Definition:]
 !item [Summary:]           Bring your own previous open window to the front

 !item [Category:]          Window functions

 !item [C:]                 void Awi_down( void );

 !item [Pascal:]            Procedure Awi_down;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_down brings up an own previous and open GEM window.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_up
!end_enumerate

!end_node


!begin_node Awi_fulled

 !begin_blist [Definition:]
 !item [Summary:]           Bring the open window to its maximum size

 !item [Category:]          Window functions

 !item [C:]                 void Awi_fulled( Awindow *window );

 !item [Pascal:]            Procedure Awi_fulled( window: AwindowPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_fulled function brings the open window to its maximum size
in the state AWS_FULL. If the window is already in the state AWS_FULL,
the window takes its previous position and size.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_gemscript

 !begin_blist [Definition:]
 !item [Summary:]           Process GEMScript commands on the window

 !item [Category:]          Window functions, GEMScript Protocol

 !item [C:]                 int16 Awi_gemscript( Awindow *wi,
                             int16 anz, char **cmd,
                             A_GSAntwort *antwort );

 !item [Pascal:]            Function Awi_gemscript(
                                   window: AwindowPtr;
                                   anz: Integer; cmd: Pointer;
                                   antwort: A_GSAntwortPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_gemscript processes some window-specific GEMScript
commands implemented as standard in (!I)ACSpro(!i). These are:

!begin_xlist [GetAllCommands]
 !item [CheckCommand]    Checks whether the specified command is understood

 !item [GetAllCommands]  Returns an alphabetically sorted list of all the
                 GEMScript commands understood by the window

 !item [GetFront]        Returns the name of the top window

 !item [KeyPress]        Simulates a key press

 !item [ToFront]         Brings the specified top window to the front
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions, GEMScript Protocol
!end_enumerate

!end_node


!begin_node Awi_help

 !begin_blist [Definition:]
 !item [Summary:]           Call up the ST-Guide help for the transferred
                    window

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_help( Awindow *window );

 !item [Pascal:]            Function Awi_help( window: AwindowPtr ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_help reads the help data from the window structure
and sends the service routine the message AS_ASK_STGUIDE. The
service routine has the opportunity to change the title of the help
page to display another help (the editor window does this) or to
switch it off completely.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Aev_STGuideHelp, Aus_help
!end_enumerate

!end_node


!begin_node Awi_hslid

 !begin_blist [Definition:]
 !item [Summary:]           Position the window content horizontally

 !item [Category:]          Window functions

 !item [C:]                 void Awi_hslid( Awindow *window, int16 pos );

 !item [Pascal:]            Procedure Awi_hslid( window: AwindowPtr;
                                 pos: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_hslid positions the content of the open window in
the horizontal position pos (left = 1, right = 1000).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_vslid
!end_enumerate

!end_node


!begin_node Awi_init

 !begin_blist [Definition:]
 !item [Summary:]           Init routine of the window (dummy function)

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_init( Awindow *window );

 !item [Pascal:]            Function Awi_init( window: AwindowPtr ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_init function does nothing and simply returns OK. So it is
a pure dummy routine.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_keys

 !begin_blist [Definition:]
 !item [Summary:]           Process key presses for a window

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_keys( Awindow *window, int16 kstate,
                             int16 key );

 !item [Pascal:]            Function Awi_keys(
                                   window: AwindowPtr;
                                   kstate, key: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_keys function services keys in a window. Awi_keysend,
Awi_sendkey and Awi_nokey are available as alternatives.

The function calls Awi_keysend internally, but suppresses the return
value -2. This means that key presses that are not processed are no
longer forwarded to the AV-server.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_keysend, Awi_nokey, Awi_sendkey
!end_enumerate

!end_node


!begin_node Awi_keysend

 !begin_blist [Definition:]
 !item [Summary:]           Process key presses for a window

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_keysend( Awindow *window, int16 kstate,
                             int16 key );

 !item [Pascal:]            Function Awi_keysend(
                                   window: AwindowPtr;
                                   kstate, key: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_keysend function services keys in a window. Awi_keys,
Awi_sendkey and Awi_nokey are available as alternatives.

A distinction is made between two modes that are mutually exclusive:
windows with and without an object list - only the latter may contain
input fields.

!begin_xlist [Dialog window]
 !item [Object list]
                  !begin_xlist [Enter, Return]
                  !item [Cursor key]     Moves the selection one object further.
                                 If there is no selection, an object is
                                 selected.

                  !item [Clr]            Sets the selection to the first
                                 object.

                  !item [Home]           Sets the selection to the last
                                 object.

                  !item [UNDO]           Deselects the selection.

                  !item [Enter, Return]  If a click routine exists for the
                                 object, it is jumped to - practically
                                 a double click.

                  !item [HELP]           The ST-Guide page for the window opens.

                  !item [Character:]     The object is searched for, whose name
                                 determined by Aob_gettext begins with
                                 the character entered  The first valid
                                 letters and numbers are considered.
                  !end_xlist

 !item [Dialog window]
                  !begin_xlist [Enter, Return]
                  !item [Enter, Return]  The (!link [Click-Routine] [Click Routine & Drag Routine]) of the default
                                 object is executed.

                  !item [HELP]           The ST-Guide page for the window opens.

                  !item [Control-Tab]    The next object marked with AO_DEFABLE
                                 becomes the default object.

                  !item [Shift-Cursor]   Places the cursor at the end or
                                 beginning of a line of text or the
                                 entire dialog.

                  !item [Control-Cursor] Jumps one word at a time.

                  !item [other keys]     The character is entered as far
                                 as is possible.
                  !end_xlist
!end_xlist

The return value is not only important for Awi_dialog, but also
signals (!I)ACSpro(!i) whether a key should be passed on:

!begin_xlist [>=0]
 !item [>=0]  The key was consumed by the object with this number. In
      Awi_dialog this is the starting criterion.

 !item [-1]   This key was not processed, but should not be passed on.

 !item [-2]   This button was not processed and should be passed on to
      the AV-server.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_keys, Awi_nokey, Awi_sendkey
!end_enumerate

!end_node


!begin_node Awi_layout

 !begin_blist [Definition:]
 !item [Summary:]           Toggle 3D display and modern menus on/off

 !item [Category:]          Window functions

 !item [C:]                 void Awi_layout( const int16 flag3D,
                            const int16 flagModernMenu,
                            const int16 redraw );

 !item [Pascal:]            Procedure Awi_layout( flag3D, flagModernMenu,
                                 redraw: int16 );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_layout function switches between 3D display and 2D display.
Furthermore, the modern menus are switched on and off. The menus
are switched after asking the associated window by means of the
message AS_CHANGE_LAYOUT. If the window prohibits the changeover,
the menu is not touched.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_list

 !begin_blist [Definition:]
 !item [Summary:]           Determine the next window structure (cyclically)

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_list( void );

 !item [Pascal:]            Function Awi_list : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_list returns the next existing window structure.
The process is cyclical.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_modal

 !begin_blist [Definition:]
 !item [Summary:]           Determine the top modal window dialog

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_modal( void );

 !item [Pascal:]            Function Awi_modal : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_modal determines the top modal window dialog. The
return value NULL or NIL signals that there is no open window dialog.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_alert, Awi_dialog,Awi_doform
!end_enumerate

!end_node


!begin_node Awi_moved

 !begin_blist [Definition:]
 !item [Summary:]           Move window

 !item [Category:]          Window functions

 !item [C:]                 void Awi_moved( Awindow *window, Axywh *new );

 !item [Pascal:]            Procedure Awi_moved( window: AwindowPtr;
                                 new: AxywhPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_moved is responsible for moving windows on the
screen. With the exception that list windows do not have to be
recalculated, it is identical to Awi_sized.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_sized
!end_enumerate

!end_node


!begin_node Awi_name

 !begin_blist [Definition:]
 !item [Summary:]           Find the window based on the window title

 !item [Category:]          Window functions

 !item [C:]

 !item [Pascal:]            Function Awi_name(
                                   title: Pointer; sensitiv: Integer
                                ) : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_name tries to find the window structure based on
the window title (used in GEMScript). The comparison takes place
without leading and without trailing spaces. The passed flag
controls whether the comparison is case sensitive (TRUE) or case
sensitive (FALSE).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_nokey

 !begin_blist [Definition:]
 !item [Summary:]           Process key presses for a window

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_nokey( Awindow *window, int16 kstate,
                             int16 key );

 !item [Pascal:]            Function Awi_nokey(
                                   window: AwindowPtr;
                                   kstate, key: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_nokey function is a keyboard routine that actually does
nothing. It is an alternative to Awi_keys if no editable fields
are edited. Since it returns the return value -1, keystrokes are
ignored and are (!I)not(!i) forwarded to the AV-server

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_keys, Awi_keysend, Awi_sendkey
!end_enumerate

!end_node


!begin_node Awi_obchange

 !begin_blist [Definition:]
 !item [Summary:]           Fast drawing routine for changing the state
                    of an object

 !item [Category:]          Window functions

 !item [C:]                 void Awi_obchange( Awindow *window,
                             int16 obnr, int16 new_state );

 !item [Pascal:]            Procedure Awi_obchange( window: AwindowPtr;
                                   obnr, new_state: Integer);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_obchange function is a fast drawing routine that has been
optimized for changes in state.

If the old and new states are the same, the objects are redrawn from
obnr. This routine is based on the AES call objc_change.

If modified texts with variable length are to be refreshed with this,
the OBJECT type G_BOXTEXT should be used, the frame can be switched
off.

It becomes problematic when e.g. the frame thickness has been reduced.
The formerly larger framework will not be removed. In this case there
is Awi_obredraw, which offers this functionality.

If -1 is passed as 'new_state', the 'ob_state' is retained. Since this
case occurs quite frequently, it saves code and paperwork.

In order to address objects in the toolbar, 'obnr' must be ORed with
A_TOOLBAR. e.g. with Pure-C

!begin_sourcecode
     Awi_obchange (wi, A_TOOLBAR | 0, -1);
!end_sourcecode

The entire toolbar is redrawn.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_obredraw
!end_enumerate

!end_node


!begin_node Awi_obredraw

 !begin_blist [Definition:]
 !item [Summary:]           Drawing routine for redrawing an object
                    using Awi_redraw

 !item [Category:]          Window functions

 !item [C:]                 void Awi_obredraw( Awindow *window, int16 obnr );

 !item [Pascal:]            Procedure Awi_obredraw( window: AwindowPtr;
                                   obnr: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_obredraw redraws everything under the object obnr.
The call Awi_redraw is used for this. The call is slower than
Awi_obchange, but very reliable in refreshing the display.

Smaller frames can also be refreshed correctly. This call is used
especially for hidden objects. If the object was hidden above,
Awi_obchange cannot draw anything. Awi_obredraw refreshes the area
where this object was previously.

In order to address objects in the toolbar, 'obnr' must be ORed with
A_TOOLBAR. e.g. with Pure-C

!begin_sourcecode
     Awi_obredraw(wind, A_TOOLBAR | 0);
!end_sourcecode

The whole toolbar is redrawn.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_obchange
!end_enumerate

!end_node


!begin_node Awi_observice

 !begin_blist [Definition:]
 !item [Summary:]           Send message to an object in the window

 !item [Category:]          Object functions

 !item [C:]                 int16 Awi_observice( Awindow *window, int16 obnr,
                             int16 task, void *in_out );

 !item [Pascal:]            Function Aob_service(
                                   window: AwindowPtr; obnr, task:
                    int16;
                                   in_out: Pointer
                                ) : MFDBPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_observice forwards the transferred message to the
object specified by obnr. The function uses the function Aob_service,
objects of the toolbar are, as usual, represented by the OR link with
A_TOOLBAR.


(!B)Note:(!b) If the flag AB_LAZYEVAL is deleted in (!link [ACSblk->description->flags] [Adescr]),
it is checked that the window exists; if the flag is set, no check
takes place.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Aob_service
!end_enumerate

!end_node


!begin_node Awi_obview

 !begin_blist [Definition:]
 !item [Summary:]          Move the inner object or enlarge the window
                   to make a section visible

 !item [Category:]          Window functions

 !item [C:]                 void Awi_obview( Awindow *window, Axywh *xywh );

 !item [Pascal:]            Procedure Awi_obview( window: AwindowPtr;
                                 xywh: AxywhPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_obview moves the inner object of the open window
or enlarges the window so that the object becomes visible through
the rectangle described by xywh.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_obvisible

 !begin_blist [Definition:]
 !item [Summary:]           Check whether an object is visible

 !item [Category:]          Object functions

 !item [C:]                 int16 Awi_obvisible( Awindow *window, int16 obnr);

 !item [Pascal:]            Function Awi_obvisible(
                                   window: AwindowPtr; obnr: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_obvisible checks whether the object identified by
'obnr' could be visible in the window. As usual, objects of the
toolbar are OR linked with A_TOOLBAR.

The function checks that the window is open, not iconified and not
in the state AWS_SHADED, since then no object of the window can be
visible. Aob_visible is used to check the visibility within the
toolbar or the work object. The return value TRUE signals that the
object is visible, provided the window is suitable. A value of FALSE
indicates that the object cannot be visible.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Aob_visible
!end_enumerate

!end_node


!begin_node Awi_ontop

 !begin_blist [Definition:]
 !item [Summary:]           Find the top window of the Application

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_ontop();

 !item [Pascal:]            Function Awi_ontop : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_ontop returns the top window of the Application.
If no window is open, Awi_root() is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_open

 !begin_blist [Definition:]
 !item [Summary:]           Open a window

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_open( Awindow *window );

 !item [Pascal:]            Function Awi_open( window: AwindowPtr ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_open function opens the transferred window. It will appear
on the desktop. If no GEM window ID could be obtained, this will be
announced in an alert box and FAIL. Returns OK if successful.

The Sliders are set to the values contained in (!link [wi->wi_slider] [Awindow.wi_slider])!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_closed
!end_enumerate

!end_node


!begin_node Awi_redraw

 !begin_blist [Definition:]
 !item [Summary:]           Redraw a rectangle of the window

 !item [Category:]          Window functions

 !item [C:]                 void Awi_redraw( Awindow *window, Axywh *limit );

 !item [Pascal:]            Procedure Awi_redraw( window: AwindowPtr; limit:
                    AxywhPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_redraw function redraws the Window window using the area of
the limitimg rectangle.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_root

 !begin_blist [Definition:]
 !item [Summary:]           Find the root window (desktop)

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_root( void );

 !item [Pascal:]            Function Awi_root : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_root returns the pointer to the structure of the
root window (desktop).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_saved

 !begin_blist [Definition:]
 !item [Summary:]           Notify OLGA manager and other OLGA windows
                    about saving a document

 !item [Category:]          Window functions

 !item [C:]                 void Awi_saved( Awindow *window,
                            const char *datei );

 !item [Pascal:]            Procedure Awi_saved( window: AwindowPtr;
                                 datei: Pointer )

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_saved function sends the AS_OLGA_UPDATE message to all windows
that have an OLGA connection with the specified file. The OLGA manager
is notified of the save via OLGA_UPDATE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_scroll

 !begin_blist [Definition:]
 !item [Summary:]           Scroll the content of the window

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_scroll( Awindow *wi, int16 x, int16 y);

 !item [Pascal:]            Procedure Awi_scroll( wi: AwindowPtr; x, y:
                    Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_scroll shifts the content of the window by using
a grid copy if possible. The object tree wi->work must be moved to
the new position (ob_x, ob_y) before being called. Then Awi_scroll
is called with the OLD position values.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_create

  !item Awi_closed
!end_enumerate

!end_node


!begin_node Awi_selfcreate

 !begin_blist [Definition:]
 !item [Summary:]           Create a "simple" window

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_selfcreate( void *wi );

 !item [Pascal:]            Function Awi_selfcreate( wi: Pointer ) :
                    AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_selfcreate provides an (!link [Create Routine] [Awindow.create]) which is
suitable for windows without their own data and without needing
other initializations. This is the routine that can be entered as
'standard' in the ACS-Builder.

For many windows that do not require initialized data, it is just
sufficient to specify this routine as a 'create' routine in your own
Awindow structure. The address is transferred to the window structure
as a parameter to the function, e.g.

in Pure-C:

     wi = WI_ALERT.create(&WI_ALERT);

in Pure-Pascal:

     wi := WI_ALERT.create(@WI_ALERT);

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_create
!end_enumerate

!end_node


!begin_node Awi_sendall

 !begin_blist [Definition:]
 !item [Summary:]           Send a message to all windows

 !item [Category:]          Window functions

 !item [C:]                 void Awi_sendall( int16 task, void *in_out );

 !item [Pascal:]            Procedure Awi_sendall( task: Integer; in_out:
                    Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_sendall sends the same message to all windows.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_sendkey

 !begin_blist [Definition:]
 !item [Summary:]           Process key presses for a window

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_sendkey( Awindow *window, int16 kstate,
                    int16 key );

 !item [Pascal:]            Function Awi_sendkey(
                                   window: AwindowPtr; kstate, key:
                    Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_sendkey function is a keyboard routine that does nothing.
Since it always returns -2 as the return value, all key presses
are normally forwarded to the AV-server. It is an alternative to
Awi_keys if no editable fields are to be edited, but key presses
are to be reported to the AV-server.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_keys, Awi_keysend, Awi_nokey
!end_enumerate

!end_node


!begin_node Awi_service

 !begin_blist [Definition:]
 !item [Summary:]           Rudimentary (!link [Service Routine] [Awindow.service])

 !item [Category:]          Window functions

 !item [C:]                 int16 Awi_service( Awindow *window,
                             int16 task, void *in_out );

 !item [Pascal:]            Function Awi_service(
                                   window: AwindowPtr; task: Integer;
                                   in_out: Pointer
                                ) : Boolean;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_service function provides a rather rudimentary service
routine. It processes the message AS_TERM, in which the routine
Awi_delete is called, and in the beginning the message AS_GEM_MESS.
The return value (TRUE or FALSE) indicates whether the requested
service was offered and could also be processed successfully.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_sized

 !begin_blist [Definition:]
 !item [Summary:]           Enlarge or reduce a window

 !item [Category:]          Window functions

 !item [C:]                 void Awi_sized( Awindow *window, Axywh *new );

 !item [Pascal:]            Procedure Awi_sized( window: AwindowPtr; new:
                    AxywhPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Awi_sized function sets the open Window window to the size of
rectangle described in the new structure. The window loses the state
AWS_FULL. List windows are recalculated.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_moved
!end_enumerate

!end_node


!begin_node Awi_show

 !begin_blist [Definition:]
 !item [Summary:]           Show or bring up a window

 !item [Category:]          Window functions

 !item [C:]                 void Awi_show( Awindow *window );

 !item [Pascal:]            Procedure Awi_show( window: AwindowPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_show opens the window, or brings the window up if
it is already open.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_topped

 !begin_blist [Definition:]
 !item [Summary:]           Bring an open window up

 !item [Category:]          Window functions

 !item [C:]                 void Awi_topped( Awindow *window );

 !item [Pascal:]            Procedure Awi_topped( window: AwindowPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_topped brings an open window up.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_uoself

 !begin_blist [Definition:]
 !item [Summary:]           Provide all Userdefs of the toolbar and/or
                    work object with the message AUO_SELF

 !item [Category:]          Window functions

 !item [C:]                 void Awi_uoself( void *wind );

 !item [Pascal:]            Procedure Awi_uoself( wi: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_uoself supplies all Userdef objects that are in
the toolbar or work object tree with the necessary AUO_SELF messages.
Awi_create calls this routine itself.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_up

 !begin_blist [Definition:]
 !item [Summary:]           Bring your own next open windows to the front

 !item [Category:]          Window functions

 !item [C:]                 void Awi_up( void );

 !item [Pascal:]            Procedure Awi_up;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_up brings the next, owned and open GEM window up.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_down
!end_enumerate

!end_node


!begin_node Awi_update

 !begin_blist [Definition:]
 !item [Summary:]           To keep a log function for wind_update

 !item [Category:]          Window functions

 !item [C:]                 void Awi_update( int16 mode );

 !item [Pascal:]            Procedure Awi_update( mode: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_update must be used instead of the AES function
wind_update so that (!I)ACSpro(!i) can also log these calls.

The mode value is assigned analogously to wind_update:

!begin_xlist [RESTART_UPDATE]
 !item [BEGIN_UPDATE]    Starts exclusive screen access.

 !item [END_UPDATE]      Ends exclusive screen access.

 !item [BEGIN_MCTR]      Starts exclusive mouse control.

 !item [END_MCTR]        Ends exclusive mouse control.
 
 !item [RESET_UPDATE]    Switches off any control.

 !item [RESTART_UPDATE]  Restores the state before RESET_UPDATE.
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Awi_vslid

 !begin_blist [Definition:]
 !item [Summary:]           Position the content of the window vertically

 !item [Category:]          Window functions

 !item [C:]                 void Awi_vslid( Awindow *window, int16 pos );

 !item [Pascal:]            Procedure Awi_vslid( window: AwindowPtr; pos:
                    Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_vslid positions the content of the open window in
the vertical position pos (top = 1, bottom = 1000).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions

  !item Awi_hslid
!end_enumerate

!end_node


!begin_node Awi_wid

 !begin_blist [Definition:]
 !item [Summary:]           Determine the GEM window ID for a window

 !item [Category:]          Window functions

 !item [C:]                 Awindow *Awi_wid( const int16 wid );

 !item [Pascal:]            Function Awi_wid( wid: Integer ) : AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Awi_wid returns the pointer to the window structure
that uses the GEM ID. If this GEM window ID is not occupied by
(!I)ACSpro (!i), NULL or NIL is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Window functions
!end_enumerate

!end_node


!begin_node Ax_free

 !begin_blist [Definition:]
 !item [Summary:]           Release memory block

 !item [Category:]          Memory management

 !item [C:]                 void Ax_free( void *memory );

 !item [Pascal:]            Procedure Ax_free( memory: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ax_free function marks the transferred memory block as free.
The memory block is only released after returning to the main loop.
Therefore, even after the release, the object can be referenced
without errors until it returns to the main loop.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management

  !item Ax_ifree, Ax_malloc
!end_enumerate

!end_node


!begin_node Ax_ifree

 !begin_blist [Definition:]
 !item [Summary:]           Release the memory block immediately (i.e. unbuffered)

 !item [Category:]          Memory management

 !item [C:]                 void Ax_ifree( void *memory );

 !item [Pascal:]            Procedure Ax_ifree( memory: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ax_ifree function (!I)immediately(!i) releases the transferred
memory block. The memory block may no longer be used after this
function call.

(!B)Note:(!b) This routine should be used with extreme caution. (!I)Under
no circumstances should they be used for window structures,
object trees or userblk structures.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management

  !item Ax_free, Ax_malloc
!end_enumerate

!end_node


!begin_node Ax_getRecycleStat

 !begin_blist [Definition:]
 !item [Summary:]           Configure the management of free lists

 !item [Category:]          Memory management

 !item [C:]                 MemFreeBlockStat *Ax_getRecycleStat(
                                         int16 *anzahl );

 !item [Pascal:]            Function Ax_getRecycleStat(
                                   Var anzahl: int16
                                 ) : MemFreeBlockStatPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ax_getRecycleStat returns the currently valid statistics
of the lists of free blocks. The number of lists is entered in the
transferred pointer, a list with the data is returned as a function
result.

(!B)Note:(!b) A more detailed explanation of how the "lists of free blocks"
work can be found in the memory management.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management

  !item Ax_free, Ax_ifree, Ax_malloc, Ax_recycle

  !item Ax_setRecycleSize
!end_enumerate

!end_node


!begin_node Ax_malloc

 !begin_blist [Definition:]
 !item [Summary:]           Allocate memory block

 !item [Category:]          Memory management

 !item [C:]                 void *Ax_malloc( long size );

 !item [Pascal:]            Function Ax_malloc( size: LongInt ) : Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ax_malloc function allocates a block of memory and makes it
available for use. (!I)ACSpro(!i) internally makes (!I)all(!i) storage requests
through this routine. The function tries to reuse the blocks
"released" and buffered by Ax_recycle for certain block sizes.

The routine is accessory-specific, i.e. memory requested with
Ax_malloc survives the rough GEM behavior!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management

  !item Ax_free, Ax_ifree, Ax_recycle
!end_enumerate

!end_node


!begin_node Ax_memCheck

 !begin_blist [Definition:]
 !item [Summary:]           Check memory block for read and write access

 !item [Category:]          Memory management

 !item [C:]                 int16 Ax_memCheck( const char *buffer,
                             INT32 len, int16 write);

 !item [Pascal:]            Function Ax_memCheck(
                                   buffer: Pointer; len: INT32;
                                   write: int16
                                ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ax_memCheck function checks whether the memory block passed in
buffer can be read and, if necessary, written (for write=TRUE).

Under systems with memory protection (currently only under MiNT),
(!I)global(!i) memory must be procured to exchange information with
other applications. Unfortunately there are some programs that don't
stick to it. As a result, (!I)ACSpro(!i) gets terminated with a
"protection violation" (although it is not at fault) as soon as an
exchange of information with such "bullies" ;-) was underway...

The len parameter has the following meaning:

!begin_xlist [other]
 !item [<-2]    Nothing is checked.

 !item [-2]     The memory block is an ASCIIZZ string as required for
        GEMScript (see also Ast_mergeASCIIZZ). It is checked up
        to and including the first double Null byte

 !item [-1]     The memory block is checked as a string, i.e. up to and
        including the first Null byte

 !item [other]  The memory block is checked up to the length of len bytes
        (inclusive)
!end_xlist

(!I)ACSpro(!i) uses this function to check internally whether or not
addresses passed via the various protocols can also be read and,
if necessary, written to. In the event of an error, an (!link [Error Message] [Ash_error])
is sent to the "villain" via the normal feedback. Calling Ax_memCheck
should therefore normally not be required.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management
!end_enumerate

!end_node


!begin_node Ax_recycle

 !begin_blist [Definition:]
 !item [Summary:]           Release a block of memory, but buffer if necessary

 !item [Category:]          Memory management

 !item [C:]                 void Ax_recycle( void *memory, INT32 size );

 !item [Pascal:]            Procedure Ax_recycle( memory: Pointer;
                                 size: INT32 );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The Ax_recycle function tries to copy the block into a list of free
blocks before releasing the memory.

(!B)Note:(!b) A more detailed explanation of how the "lists of free blocks"
work can be found in the memory management..

(!B)Example:(!b) The function Awi_delete calls the function Ax_recycle
internally as follows: Ax_recycle(wind, sizeof(*wind)).

(!B)Tip:(!b) If, at the closing of the (!I)ACSpro(!i) Application, the statistics
are determined using Ax_getRecycleStat and written to a file, the
management of the free blocks in routine ACSinit0 can be optimized
using Ax_setRecycleSize for each Application and its corresponding
purpose.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management

  !item Ax_free, Ax_ifree, Ax_malloc

  !item Ax_getRecycleStat, Ax_setRecycleSize
!end_enumerate

!end_node


!begin_node Ax_setRecycleSize

 !begin_blist [Definition:]
 !item [Summary:]           Configure the management of free lists

 !item [Category:]          Memory management

 !item [C:]                 int16 Ax_setRecycleSize( INT32 size, int16 amount,
                             char *beschreibung );

 !item [Pascal:]            Function Ax_setRecycleSize(
                                   size: INT32; amount: int16;
                                   beschreibung: Pointer
                                 ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function Ax_setRecycleSize configures the lists of the free
blocks of the (!I)ACSpro(!i) memory management.

(!B)Note:(!b) A more detailed explanation of how the "lists of free blocks"
work can be found in the memory management.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Memory management

  !item Ax_free, Ax_ifree, Ax_malloc, Ax_recycle

  !item Ax_getRecycleStat
!end_enumerate

!end_node


!begin_node A_3Dbutton

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-3D-Button

 !item [Category:]          User defined objects, Userdef-3D-Button

 !item [C:]                 int16 CDECL A_3Dbutton( PARMBLK *pb );

 !item [Pascal:]            Function A_3Dbutton(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_3Dbutton is the draw routine for the Userdef-3D-Button.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item 3D-Button (Auo_string)

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_arrows

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Arrows

 !item [Category:]          User defined objects, Userdef-Arrows

 !item [C:]                 int16 CDECL A_arrows( PARMBLK* pb );

 !item [Pascal:]            Function A_arrows(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_arrows is the draw routine for the Userdef-Arrows.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Arrows

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_boxed

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-BoxEdit

 !item [Category:]          User defined objects, Userdef-BoxEdit

 !item [C:]                 int16 CDECL A_boxed( PARMBLK* pb );

 !item [Pascal:]            Function A_boxed(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_boxed is the draw routine for the Userdef-BoxEdit.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item BoxEdit (Auo_boxed/Aus_boxed)

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_checkbox

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Checkbox or
                            Userdef-Radiobutton

 !item [Category:]          User defined objects, Userdef-Checkbox,
                    Userdef-Radiobutton

 !item [C:]                 int16 CDECL A_checkbox( PARMBLK* pb );

 !item [Pascal:]            Function A_checkbox(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_checkbox is the draw routine for the Userdef-Checkbox and the 
Userdef-Radiobutton. A checkbox/radio button with text is drawn.

A box/ellipse is drawn that is offset inwards by 3 pixels in all
directions, but is at least 6 pixels in size. If the object is
selected, a cross or a filled ellipse is drawn. A string can optionally
be specified. If there is a string, the button is displayed as a
square/ellipse at the height of the system character set. The string
is right justified. A box/ellipse is drawn without a string, depending
on the geometry data.

Since VDI draws very ugly (small) boxes/ellipses, an image is used for
the typical case 16x16 pixels (2x1 characters - monochrome resolution).

If DISABLED is set, a gray-patterned box/circle is drawn, which is
suitable as a basis for tri-state buttons.

Key codes are identified in the text by string codes.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Checkbox

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_cycle

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Cycle

 !item [Category:]          User defined objects, Userdef-Cycle

 !item [C:]                 int16 CDECL A_cycle( PARMBLK* pb );

 !item [Pascal:]            Function A_cycle(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_picture is the draw routine for the Userdef-Cycle.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Cycle (Aus_cycle/Auo_cycle)

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_dd

!label A_ddPtr
This structure is used by Ash_nextdd and provides information about
the external Drag&Drop partners.

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   int16 id;
   long type;
   unsigned int16 xacc_val;
   const char *xacc_name;
   unsigned int16 va_val[3];
   const char *va_name;
} A_dd;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
A_dd = RECORD
      id:        Integer;
      dd_type:   Longint;
      xacc_val:  Word;
      xacc_name: Pointer;
      va_val:    packed array[1..3] of Word;
      va_name:   Pointer;
   END;

A_ddPtr = ^A_dd;
!end_sourcecode

(!I)(!B)Attention:(!b) This data may only be read! (!i)

The components of the structure mean:

!begin_xlist [xacc_name]
 !item [id]         AES identification of the partners.

 !item [type]       Indication of what type of partner it is.  The value
            is to be understood as a bit field and has the
            following assignments so far:

             Bit 1:  reserved

             Bit 2:  XACC-Partner (see constant DD_XACC)

             Bit 3:  VA-Partner (see constant DD_VA)

 !item [xacc_val]   If DD_XACC is set, this is the partner's supported
            message group.

 !item [va_val]     Contains the three values that are provided by
            VA_PROTOSTATUS from the AV-Protocol server.

 !item [xacc_name]
 !item [va_name]    This is the name of the partner for XACC- and
            VA-Protocol.
!end_xlist

!end_node


!begin_node A_dialog

 !begin_blist [Definition:]
 !item [Summary:]           Carry out a system-modal dialogue

 !item [Category:]          Other functions

 !item [C:]                 int16 A_dialog( OBJECT *dia );

 !item [Pascal:]            Function A_dialog( dia: ACSTreePtr ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The A_dialog function draws the dialog box either centered in the
middle of the desktop or near the mouse pointer depending on the
state of the AB_CENTERDIALOG flag.

     (!B)If possible, this function should no longer be used from
     version 2.2. Instead, the functions Awi_doform and Awi_dialog
     are available.(!b)

Returns the number of the selected object. The double-click flag is
removed. Objects with the flags AO_DRAGABLE and (!I)TOUCHEXIT(!i) allow the
dialog to be moved (flying dialog). For objects that have a click
routine, it is called without ending the dialog. The variable dia_abort
allows the dialog to be ended after a click routine. This variable
must be set to TRUE. A double-click outside of the dialog ends it which
then returns the value 0! The modal dialog behaves largely like a
non-modal window. The dialog is assigned to the window ev_window. The
routines obchange and redraw are temporarily replaced, and the window
flag AWS_MODAL is set. Key codes are also supported.

From version 2.2 TOUCHEXIT no longer enough to leave the dialogue, see
also Awi_dialog.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item Awi_dialog, A_dialog2, Awi_doform
!end_enumerate

!end_node


!begin_node A_dialog2

 !begin_blist [Definition:]
 !item [Summary:]           Carry out system modal dialog with your
                    own positioning

 !item [Category:]          Other functions

 !item [C:]                 int16 A_dialog2( OBJECT *dia );

 !item [Pascal:]            Function A_dialog2( dia: ACSTreePtr ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function A_dialog2 draws the dialog at the position designated
in 'dia->ob_x' and 'dia->ob_y'. This gives the programmer the chance
to determine the position himself.

     (!B)If possible, this function should no longer be used from
     version 2.2. Instead, the functions Awi_doform and Awi_dialog
     are available.(!b)

Returns the number of the selected object. The double-click flag is
removed. Objects with the flags AO_DRAGABLE and (!I)TOUCHEXIT(!i) allow the
dialog to be moved (flying dialog). For objects that have a click
routine, it is called without ending the dialog. The variable dia_abort
allows the dialog to be ended after a click routine. This variable
must be set to TRUE. A double-click outside of the dialog ends it which
then returns the value 0! The modal dialog behaves largely like a
non-modal window. The dialog is assigned to the window ev_window. The
routines obchange and redraw are temporarily replaced, and the window
flag AWS_MODAL is set. Key codes are also supported.

From version 2.2 TOUCHEXIT no longer enough to leave the dialogue, see
also Awi_dialog.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item Awi_dialog, A_dialog
!end_enumerate

!end_node


!begin_node A_editor

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Editor

 !item [Category:]          User defined objects, Userdef-Editor

 !item [C:]                 int16 CDECL A_editor( PARMBLK* pb );

 !item [Pascal:]            Function A_editor(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_editor is the draw routine for the Userdef-Editor.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Editor (Auo_editor/Aus_editor)

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_ftext

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-FText

 !item [Category:]          User defined objects, Userdef-FText

 !item [C:]                 int16 CDECL A_ftext( PARMBLK* pb );

 !item [Pascal:]            Function A_ftext(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_ftext is the draw routine for the Userdef-FText.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item FText (Auo_ftext)

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_FileList

!label A_FileListPtr
In this structure the files that Af_readdir determines are stored.
The contents of a directory are thus organized as a linked list.

The definition for Pure-C reads:
!begin_sourcecode
typedef struct afilelist
{
   char *file;
   struct afilelist *next;
   XATTR attribs;
} A_FileList;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
A_FileList = RECORD
      file    : Pointer;
      next    : A_FileListPtr;
      attribs : XATTR;
End;

A_FileListPtr = ^A_FileList;
!end_sourcecode

The components of the structure mean:

!begin_xlist [attribs]
 !item [file]     File or folder name

 !item [attribs]  XATTR structure, which contains important and interesting
          information of the files as far as could be determined.
          Dxreaddir or Fxattr is used for this. If these functions
          are not available (e.g. under TOS ;-), the information
          available from the DTA to Fsfirst/Fsnext is copied here.

 !item [next]     Pointer to the next A_FileList structure or NULL or NIL
          if no other structure exists.
!end_xlist

!end_node


!begin_node A_innerframe

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Innerframe

 !item [Category:]          User defined objects, Userdef-Innerframe

 !item [C:]                 int16 CDECL A_innerframe( PARMBLK* pb );

 !item [Pascal:]            Function A_innerframe(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_innerframe is the draw routine for the Userdef-Innerframe.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Innerframe] [Userdef-Innerframe])

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_OlgaCreate

 !begin_blist [Definition:]
 !item [Summary:]           Create a registered OLGA connection

 !item [Category:]          OLGA Protocol, OLGA-Server und OLGA-Client

 !item [C:]                 OLGA Infos *A_OlgaCreate( const Awindow *window,
                                   const char *datei,
                                   const char *info_datei,


 !item [Pascal:]            Function A_OlgaCreate(
                                   window: AwindowPtr; datei: Pointer;
                                   info_datei: Pointer; flags: Integer
                                ) : OLGA_InfoPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The A_OlgaCreate function creates a registered OLGA connection.
The connection is only registered with (!I)ACSpro(!i) and has not yet
been established.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item OLGA Protocol, OLGA-Server, OLGA-Client

  !item OLGA Infos

  !item A_OlgaDelete
!end_enumerate

!end_node


!begin_node A_pattern

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine  for the Userdef-Pattern

 !item [Category:]          User defined objects, Userdef-Pattern

 !item [C:]                 int16 CDECL A_pattern( PARMBLK* pb );

 !item [Pascal:]            Function A_pattern(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_pattern is the draw routine for the Userdef-Pattern and allows
different VDI patterns to be selected (see also VDI:v_bar)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Pattern] [Userdef-Pattern])

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_picture

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Picture

 !item [Category:]          User defined objects, Userdef-Picture

 !item [C:]                 int16 CDECL A_picture( PARMBLK* pb );

 !item [Pascal:]            Function A_picture(
                                   dummy1, dummy2: Pointer; (nl)
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_picture is the draw routine for the Userdef-Picture.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Picture (Auo_picture)

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_title

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Title

 !item [Category:]          User defined objects, Userdef-Title

 !item [C:]                 int16 CDECL A_title( PARMBLK* pb );

 !item [Pascal:]            Function A_title(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_title is the draw routine for the das Userdef-Title.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Title] [Userdef-Title])

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_select

 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Select

 !item [Category:]          User defined objects, Userdef-Select

 !item [C:]                 int16 CDECL A_select( PARMBLK *pb );

 !item [Pascal:]            Function A_select(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_select is the draw routine for the Userdef-Select.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item (!link [Select] [Userdef-Select])

  !item User defined objects
!end_enumerate

!end_node


!begin_node A_slider

!label A_wislider
 !begin_blist [Definition:]
 !item [Summary:]           Draw routine for the Userdef-Slider

 !item [Category:]          User defined objects, Userdef-Slider

 !item [C:]                 int16 CDECL A_slider( PARMBLK *pb );
                    int16 CDECL A_wislider( PARMBLK *pb );

 !item [Pascal:]            Function A_slider(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer; Function A_wislider(
                                   dummy1, dummy2: Pointer;
                                   parm: PARMBLKPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

A_slider or A_wislider is the draw routine for the Userdef-
Slider.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Slider (Auo_slider/Aus_slider)

  !item User defined objects
!end_enumerate

!end_node


!begin_node basename

 !begin_blist [Definition:]
 !item [Summary:]           Name of the Application

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char basename[20];

 !item [Pascal:]            basename: packed array [1..20] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable basename contains the name of the Application without
an ending such as PRG.  The first two characters are blank.

If this text is changed in ACSinit0, the Application receives this
new name.

(!I)The variable is only valid if the program is running as an application.(!i)

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, appfrom, appname, apppara, apppath, cfg_path, scrp_path, dd_name, alert_name
!end_enumerate

!end_node


!begin_node cfg_path

 !begin_blist [Definition:]
 !item [Summary:]           Path of the configuration file (HOME)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char cfg_path[128];

 !item [Pascal:]            cfg_path: packed array [1..128] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable cfg_path contains the path where the configuration
files are searched for.  The default is the HOME directory from the
environment or the application path if the HOME environment variable
is not set or is invalid.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, Ash_getenv
!end_enumerate

!end_node


!begin_node dd_name

 !begin_blist [Definition:]
 !item [Summary:]           Drag&Drop name of the Application

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char *dd_name;

 !item [Pascal:]            dd_name: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable dd_name contains the Drag&Drop name of the Application.

For Drag&Drop an (!I)ACSpro(!i) program must have a name.  It is derived
from basename under here - AV-Protocol uses this name.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Path variables

  !item Ablk, AblkPtr, ACSblk, Ash_nextdd, Ash_sendall
!end_enumerate

!end_node


!begin_node DEBUG_MEM

 !begin_blist [Definition:]
 !item [Summary:]           Routine for memory errors

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 void (*DEBUG_MEM)( void *defective );

 !item [Pascal:]            DEBUG_MEM: Procedure( defective: Pointer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable DEBUG_MEM contains the address of a routine that (!I)ACSpro(!i)
starts if memory errors occur.

The alert box is shown before. The routine itself can check the
'defective' memory or the developer can use the debugger. A dump
can provide valuable clues as to why this error occurred. The
output of the stack provides further information.

(!B)Note:(!b) Some typical causes of memory errors are:

!begin_enumerate !compressed
  !item Multiple releases

  !item Write beyond the requested memory area. Then the head of
     another memory area is usually destroyed and (!I)ACSpro(!i) no
     longer considers it valid (e.g. when inserting too long a
     text in an OBJECT, see Aob_puttext).

  !item Assign pointers directly to the object tree e.g. for strings
     without using the AOS_CONST flag
!end_enumerate

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Function pointers

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node desk

 !begin_blist [Definition:]
 !item [Summary:]           Dimensions of the desktop without menu bar

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 Axywh desk;

 !item [Pascal:]            desk: Axywh;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable desk describes a rectangle that corresponds to the
dimensions of the desktop without the menu bar (gray area).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node DESKTOP

 !begin_blist [Definition:]
 !item [Summary:]           The root window DESKTOP

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 Awindow DESKTOP;

 !item [Pascal:]            In Pure-Pasacal, the structure DESKTOP
                    (!link [is not directly accessible] [Pure-Pascal]). It must
                    be queried using the get_desktop function.

!label get_desktop
                    Function get_desktop : Awindow;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The DESKTOP variable represents the window structure of the desktop
window that is only available for compatibility.

The background object of the DESKTOP can be configured in the routine
ACSInit0, whereby the values 'ob_type', 'ob_spec', 'ob_width' and
'ob_height' are adopted:

!begin_xlist [Pascal:]
 !item [C:]       DESKTOP.service (NULL, AS_BACKOBJECT, &MYDESK);

 !item [Pascal:]  get_desktop^.service (NIL, AS_BACKOBJECT, @MYDESK);
!end_xlist

The icons of the DESKTOP can be exchanged in the routine ACSinit0:

!begin_xlist [Pascal:]
 !item [C:]       DESKTOP. service (NULL, AS_ICONNEW, &NEW_IC);
          DESKTOP. service (NULL, AS_ICONTRASH, &TRASH_IC);
          DESKTOP. service (NULL, AS_ICONWINDOW, &WINDOW_IC);

 !item [Pascal:]  get_desktop^.service (NIL, AS_ICONNEW, @NEW_IC);
          get_desktop^.service (NIL, AS_ICONTRASH, @TRASH_IC);
          get_desktop^.service (NIL, AS_ICONWINDOW, @WINDOW_IC);
!end_xlist

The menu bar of the DESKTOP can also be replaced:

!begin_xlist [Pascal:]
 !item [C:]       DESKTOP. menu = &MY_MENU;

 !item [Pascal:]  get_desktop^. menu = @MY_MENU;
!end_xlist

The functions in the original menu tree can be used. These are:

!begin_xlist [Action/Icons Horizontal]
 !item [File/Open]               Awd_open

 !item [File/Close]              Awd_close

 !item [File/Delete]             Awd_delete

 !item [File/Info]               Awd_info

 !item [File/Module]             Awd_module

 !item [File/Quit]               Awd_quit

 !item [Window/Change]           Awi_up

 !item [Window/From List]        Awd_list

 !item [Action/Icons Horizontal] Awd_hor

 !item [Action/Icons Vertical]   Awd_ver

 !item [Action/Behavior]         Awd_behaviour

 !item [Action/...Save]          Awd_save
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The generic desktop

  !item PUR_DESK
!end_enumerate

!end_node


!begin_node dia_abort

 !begin_blist [Definition:]
 !item [Summary:]           Cancel flag of a modal (windowed) dialog

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 dia_abort;

 !item [Pascal:]            dia_abort: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable dia_abort allows the modal (window) dialog to be ended
after being called up by a click routine. To do this, the variable
must be set to TRUE in the click routine.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node dither

 !begin_blist [Definition:]
 !item [Summary:]           Definition of the dither modes

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 dither;

 !item [Pascal:]            dither: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

This variable contains the definition of the dither mode for the
(!link [3D-Button] [Userdef-3D-Button]). Dither mode is used for less than 4 planes when the fill
pattern is full (7) and the color is LWHITE (8).

The bits of the variables are assigned as follows:

!begin_xlist [Bit 0-3]
 !item [Bit 0-3]  Color of the fill pattern

 !item [Bit 4-6]  Pattern index of the fill pattern

 !item [Bit 7]    Enforce opaque text (REPLACE)

 !item [Bit 8]    Force capitalization

 !item [Bit 9]    White frame (color 0) is dotted

 !item [Bit 10]   Gray frame (color 9) is dotted
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Ablk, AblkPtr, ACSblk, (!link [3D-Button] [Userdef-3D-Button])
!end_enumerate

!end_node


!begin_node dotted_xline

 !begin_blist [Definition:]
 !item [Summary:]           Draw a horizontal, dotted line

 !item [Category:]          Other functions

 !item [C:]                 void dotted_xline( int16 x1, int16 x2,
                            int16 y );

 !item [Pascal:]            Procedure dotted_xline( x1, x2, y: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The dotted_xline function draws a horizontal, dotted line.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item dotted_yline
!end_enumerate

!end_node


!begin_node dotted_yline

 !begin_blist [Definition:]
 !item [Summary:]           Draw a vertical, dotted line

 !item [Category:]          Other functions

 !item [C:]                 void dotted_yline( int16 y1, int16 y2,
                            int16 x );

 !item [Pascal:]            Procedure dotted_yline( y1, y2, x: Integer );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The dotted_yline function draws a vertical, dotted line.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item dotted_xline
!end_enumerate

!end_node


!begin_node EDITGETS

!label EDITGETSPtr
Due to its complexity, the (!link [Editor] [Userdef-Editor]) object is only addressed with
messages via the (!link [Service] [Auo_editor]) routine. Different structures are used:

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   long row;
   long size;
   char *text;
} EDITGETS;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
EDITGETS = RECORD
      row:  LongInt;
      size: LongInt;
      text: Pointer;
END;

EDITGETSPtr = ^EDITGETS;
!end_sourcecode

In the following structure, before the call, you specify in 'row'
the line that you want to read so that the actual data can be
obtained in 'size' und 'text'.

The components of the structure mean:

!begin_xlist [size]
 !item [row]   The required line number is entered here (!I)before(!i) the structure
       is sent to the Userdef A_editor.

 !item [size]  (!I)After(!i) sending the structure to the Userdef A_editor the
       length of the text is entered here.

 !item [text]  (!I)After(!i) the structure is sent to the Userdef A_editor a
       pointer to the text is entered here.  (!I)The text should only
       be read.(!i)
!end_xlist

!end_node


!begin_node EDITLIVE

!label EDITLIVEPtr
Due to its complexity, the (!link [Editor] [Userdef-Editor]) object is only addressed with
messages via the (!link [Service] [Auo_editor]) routine. Different structures are used
for this.

A live routine can be assigned to the editor to react immediately
to changes.  The EDITLIVE structure is used for this:

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   void (*call)( void *obj, char *text );
   void *obj;
} EDITLIVE;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
EDITLIVE = RECORD
      call  : PROCEDURE( obj: Pointer; text: Pointer );
      obj   : Pointer;
END;

EDITLIVEPtr = ^EDITLIVE;
!end_sourcecode

The components of the structure mean:

 call  Pointer to the live routine

 obj   Pointer to parameters that are passed to the live
       routine when it is called.

!end_node


!begin_node EDITSUBS

!label EDITSUBSPtr
Due to its complexity, the (!link [Editor] [Userdef-Editor]) object is only addressed with
messages via the (!link [Service] [Auo_editor]) routine. Different structures are used
for this.

The following structure is provided to insert a certain number
of lines between two positions:

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   long row1;
   long col1;
   long row2;
   long col2;
   long nrow;
   char **newtext;
} EDITSUBS;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
EDITSUBS = RECORD
      row1:  LongInt;
      col1:  LongInt;
      row2:  LongInt;
      col2:  LongInt;
      nrow:  LongInt;
      newtext:  Pointer;
END;

EDITSUBSPtr = ^EDITSUBS;
!end_sourcecode

The components of the structure mean:

!end_node


!begin_node env

 !begin_blist [Definition:]
 !item [Summary:]           Environment of the Application in environment
                    strings

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char **env;

 !item [Pascal:]            In Pure-Pascal, this variable has no meaning.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable env contains the environment in the form of the
environment strings.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk, apppara, argc, argv
!end_enumerate

!end_node


!begin_node ev_bmask

 !begin_blist [Definition:]
 !item [Summary:]           Bit mask of the mouse buttons monitor

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_bmask;

 !item [Pascal:]            ev_bmask: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_bmask is used to configure the main event loop and
contains a bit field that masks the mouse buttons to be viewed with
a !item Bit 0 corresponds to the left mouse button, bit 1 to the right
mouse button.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop

  !item Ablk, AblkPtr, ACSblk, ev_bstate, ev_mbclicks, ev_mbreturn, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_bstate

 !begin_blist [Definition:]
 !item [Summary:]           Bit mask with the status of the mouse buttons
                    being considered

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_bstate;

 !item [Pascal:]            ev_bstate: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_bstate is used to configure the main event loop and
contains a bit mask such as ev_bmask, which defines the status for
each mouse button that triggers an event. 1 means that the mouse
button is pressed, 0 that the mouse button is not pressed. Bit 0
corresponds to the left mouse button, bit 1 corresponds to the right
mouse button.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_mbclicks, ev_mbreturn, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mbclicks

 !begin_blist [Definition:]
 !item [Summary:]           Number of clicks to watch for

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mbclicks;

 !item [Pascal:]            ev_mbclicks: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mbclicks is used to configure the main event loop
and contains the number of clicks required to trigger an event.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop

  !item Ablk, AblkPtr, ACSblk, ev_bstate, ev_bmask, ev_mbreturn, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mbreturn

 !begin_blist [Definition:]
 !item [Summary:]           Number of mouse clicks that occurred

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mbreturn;

 !item [Pascal:]            ev_mbreturn: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mbreturn is used in the main event loop and contains
the number of mouse clicks that have occurred.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_bstate, ev_mbclicks, ev_mkreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mkdead

 !begin_blist [Definition:]
 !item [Summary:]           Unlocking Dead-Keys

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char ev_mkdead[10];

 !item [Pascal:]            ev_mkdead: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mkdead

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop, Handling dead keys

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ev_mkreturn

 !begin_blist [Definition:]
 !item [Summary:]           NKCC key code of the pressed key

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mkreturn;

 !item [Pascal:]            ev_mkreturn: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mkreturn is used in the main event loop and contains
the NKCC key code of the pressed key.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_bstate, ev_mbclicks, ev_mbreturn, ev_mmobutton
!end_enumerate

!end_node


!begin_node ev_mmobutton

 !begin_blist [Definition:]
 !item [Summary:]           State of the mouse buttons when an event occurs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mmobutton;

 !item [Pascal:]            ev_mmobutton: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mmobutton is used in the main event loop and contains
the state of the mouse buttons when the event occurs. 

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Variables of the event loop

  !item Ablk, AblkPtr, ACSblk, ev_bmask, ev_bstate, ev_mbclicks, ev_mbreturn, ev_mkreturn
!end_enumerate

!end_node


!begin_node ev_mmokstate

 !begin_blist [Definition:]
 !item [Summary:]           State of the special keys when an event occurs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mmokstate;

 !item [Pascal:]            ev_mmokstate: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mmokstate contains the current keyboard status when
selecting the object.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ev_mmox

 !begin_blist [Definition:]
 !item [Summary:]           Current X-coordinate of the mouse at an event

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mmox;

 !item [Pascal:]            ev_mmox: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mmox contains the current X-coordinates of the mouse
at the time of selection when clicking or releasing after dragging. 

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk, ev_mmoy
!end_enumerate

!end_node


!begin_node ev_mmoy

 !begin_blist [Definition:]
 !item [Summary:]           Current Y-coordinate of the mouse at an event

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_mmoy;

 !item [Pascal:]            ev_mmoy: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mmoy contains the current Y-coordinates of the mouse
at the time of selection when clicking or releasing after dragging. 

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk, ev_mmox
!end_enumerate

!end_node


!begin_node ev_mtcount

 !begin_blist [Definition:]
 !item [Summary:]           Main loop waiting time

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 long ev_mtcount;

 !item [Pascal:]            ev_mtcount: LongInt;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_mtcount contains the waiting time of the main loop
in milliseconds. The time is predefined at 500 ms.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ev_object

 !begin_blist [Definition:]
 !item [Summary:]           Pointer to the current object tree

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 OBJECT *ev_object;

 !item [Pascal:]            ev_object: ACSTreePtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_object contains the pointer to the current object
tree. This can be the dialog, the menu bar, the toolbar or a popup
menu.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk, ev_obnr, ev_window
!end_enumerate

!end_node


!begin_node ev_obnr

 !begin_blist [Definition:]
 !item [Summary:]           Object number in object tree ev_object

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ev_obnr;

 !item [Pascal:]            ev_obnr: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_obnr contains the current object number of the object
in the object tree specified by ev_object.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk, ev_object, ev_window
!end_enumerate

!end_node


!begin_node ev_window

 !begin_blist [Definition:]
 !item [Summary:]           Pointer to the current window

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 Awindow *ev_window;

 !item [Pascal:]            ev_window: AwindowPtr;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ev_window contains the pointer to the current window.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, (!link [Click- & Drag-Variables] [Variables for the Drag and Click routines])

  !item Ablk, AblkPtr, ACSblk, ev_object, ev_obnr
!end_enumerate

!end_node


!begin_node fheight

 !begin_blist [Definition:]
 !item [Summary:]           Height of the normal character set for the
                    (!I)ACSpro(!i) Userdefs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 fheight;

 !item [Pascal:]            fheight: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The height of the normal font of the (!I)ACSpro's(!i) own Userdefs can be
set via the variable fheight.  The reloadable module 'SYSFONT' can
subsequently modify this value.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, fontid, fontsid, fsheight
!end_enumerate

!end_node


!begin_node fontid

 !begin_blist [Definition:]
 !item [Summary:]           ID of the normal character set for the
                    (!I)ACSpro(!i) Userdefs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 fontid;

 !item [Pascal:]            fontid: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The (normal) font of the (!I)ACSpro's(!i) own Userdefs can be set via the
variable fontid.  The reloadable module 'SYSFONT' can subsequently
modify this value.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, fheight, fontsid, fsheight
!end_enumerate

!end_node


!begin_node fonts

 !begin_blist [Definition:]
 !item [Summary:]           Number of fonts loaded

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 fonts;

 !item [Pascal:]            fonts: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable fonts indicates the number of fonts loaded using
vst_load_fonts.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node fontsid

 !begin_blist [Definition:]
 !item [Summary:]           ID of the small character set for the
                    (!I)ACSpro(!i) Userdefs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 fontsid;

 !item [Pascal:]            fontsid: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The small font of the (!I)ACSpro's(!i) own Userdefs can be set via the
variable fontsid. The reloadable module 'SYSFONT' can subsequently
modify this value.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, fheight, fontid, fsheight
!end_enumerate

!end_node


!begin_node fsheight

 !begin_blist [Definition:]
 !item [Summary:]           Height of the small character set for the
                    (!I)ACSpro(!i) Userdefs

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 fsheight;

 !item [Pascal:]            fsheight: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The height of the small font of the (!I)ACSpro's(!i) own Userdefs can be
set via the variable fsheight.  The reloadable module 'SYSFONT' can
subsequently modify this value.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, fheight, fontid, fontsid
!end_enumerate

!end_node


!begin_node gl_apid

 !begin_blist [Definition:]
 !item [Summary:]           The AES Application ID

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_apid;

 !item [Pascal:]            gl_apid: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

Contains the AES Application ID. For applications it is usually 1
under SingleTOS. For accessories or under multitasking systems it
is usually greater than 1.


(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node gl_hattr

 !begin_blist [Definition:]
 !item [Summary:]           Cell height of the largest character in the
                    system character set

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_hattr;

 !item [Pascal:]            gl_hattr: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable gl_hattr contains the cell height (in pixels) of the
largest character in the system character set.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk, gl_wattr
!end_enumerate

!end_node


!begin_node gl_hbox

 !begin_blist [Definition:]
 !item [Summary:]           Cell height of the largest character in
                    the normal character set (font id)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_hbox;

 !item [Pascal:]            gl_hbox: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable gl_hbox contains the cell height of the largest character
in the character set used (specified by fontid). 

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, gl_wbox, gl_wchar, gl_hchar
!end_enumerate

!end_node


!begin_node gl_hchar

 !begin_blist [Definition:]
 !item [Summary:]           Character height of the largest character
                    in the normal character set (fontid)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_hchar;

 !item [Pascal:]            gl_hchar: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable gl_hchar contains the character height of the largest
character in the character set used (specified by fontid).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, gl_wbox, gl_hbox, gl_wchar
!end_enumerate

!end_node


!begin_node gl_wattr

 !begin_blist [Definition:]
 !item [Summary:]           Cell width of the largest character in the
                    system character set

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_wattr;

 !item [Pascal:]            gl_wattr: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable gl_wattr contains the cell width (in pixels) of the
largest character in the system character set.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk, gl_hattr
!end_enumerate

!end_node


!begin_node gl_wbox

 !begin_blist [Definition:]
 !item [Summary:]           Cell width of the largest character in the
                    normal character set (fontid)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_wbox;

 !item [Pascal:]            gl_wbox: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable gl_wbox contains the cell width of the largest character
in the character set used (specified by fontid).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, gl_hbox, gl_wchar, gl_hchar
!end_enumerate

!end_node


!begin_node gl_wchar

 !begin_blist [Definition:]
 !item [Summary:]           Character width of the largest character
                    in the normal character set (fontid)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 gl_wchar;

 !item [Pascal:]            gl_wchar: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable gl_wchar contains the character width of the largest
character in the character set used (specified by fontid).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, gl_wbox, gl_hbox, gl_hchar
!end_enumerate

!end_node


!begin_node intersect

 !begin_blist [Definition:]
 !item [Summary:]           Find intersection of two rectangles

 !item [Category:]          Other functions

 !item [C:]                 int16 intersect( Axywh *xywh1, const Axywh *xywh2);

 !item [Pascal:]            Function intersect(
                                   xywh1, xywh2: AxywhPtr
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The intersect function determines the common area of two rectangles.
The result is in xywh1. If the pattern should be empty, xywh1.w (!I)and(!i)
xywh1.h are set to 0.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions
!end_enumerate

!end_node


!begin_node keyAltCtrlSwitch

 !begin_blist [Definition:]
 !item [Summary:]           Process keys without an edit object

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 keyAltCtrlSwitch;

 !item [Pascal:]            keyAltCtrlSwitch: int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The keyAltCtrlSwitch variable controls how key presses are processed
in windows without an edit object.

If no editable object is found, you can try to use a shortcut with
Ctrl or Alt when pressing a key without Ctrl or Alt. The following
variants are possible:

!begin_itemize !compressed
   !item Search for work object can be activated separately

   !item Search for toolbar can be activated separately

   !item Search for Alt+Key can be activated separately

   !item Search for Ctrl+Key can be activated separately

   !item Search for Ctrl+Alt+Key can be activated separately

   !item First search in the work object, then in the toolbar

   !item First search in the toolbar, then in the work object
!end_itemize

Some constants are defined for this:

!begin_xlist [KEY_AC_CTRL_FIRST_WORK]
 !item [KEY_AC_NONE]            Previous behavior (try no variant)

 !item [KEY_AC_ALT_WORK]        Try Alt+Key in the work object (activated
                        by default)

 !item [KEY_AC_CTRL_WORK]       Try Ctrl+Key in the work object (not activated
                        by default)

 !item [KEY_AC_CTRL_FIRST_WORK] For the work object first try Ctrl+Key, then
                        Alt+Key (default: first Alt, then Ctrl)

 !item [KEY_AC_ALT_CTRL_WORK]   Try Ctrl+Alt+Key in the work object (not
                        activated by default)

 !item [KEY_AC_ALT_TOOL]        Try Alt+Key in the toolbar (not activated by
                        default)

 !item [KEY_AC_CTRL_TOOL]       Try Ctrl+Key in the toolbar (not activated by
                        default)

 !item [KEY_AC_CTRL_FIRST_TOOL] For the toolbar try Ctrl+Key, then Alt+Key
                        (default: first Alt, then Ctrl)

 !item [KEY_AC_ALT_CTRL_TOOL]   Try Ctrl+Alt+Key in the toolbar (not activated
                        by default)

 !item [KEY_AC_TOOL_FIRST]      First look in the toolbar, then in the work
                        object (default: first work object, then
                        toolbar)
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node menu_id

 !begin_blist [Definition:]
 !item [Summary:]           Menu index as Accessory or under MultiTOS/N.AES

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 menu_id;

 !item [Pascal:]            menu_id: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable menu_id contains the menu index in the DESK menu.

An entry is made in the DESK menu with an accessory or a suitable
multitasking OS. Its number is entered here and is available to the
partners in the XACC-Protocol. A -1 indicates an invalid menu entry.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node mfsel_count

 !begin_blist [Definition:]
 !item [Summary:]           Maximum number of files the next time the
                    multi-file selection is selected

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 mfsel_count;

 !item [Pascal:]            mfsel_count: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable mfsel_count contains the maximum number of files for the
next A_first_fsel call (multi-file selection).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node multitask

 !begin_blist [Definition:]
 !item [Summary:]           Flag whether a multitasking environment is active

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 multitask;

 !item [Pascal:]            multitask: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The multitask variable indicates whether the program is running in
a multitasking environment such as MultiGEM, MagiC (incl. MaciCPC
and (!link [MagiCMac] [MagiC])), MultiTOS or N.AES. For this purpose, it is checked
whether the AES in the global array permit anything other than a
process. The root window is placed in a GEM window under a 
multitasking environment.

If this is not desired, the flag can be removed in ACSinit0
(and restored in ACSinit).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node ncolors

 !begin_blist [Definition:]
 !item [Summary:]           Number of colors

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 ncolors;

 !item [Pascal:]            ncolors: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable ncolors contains the number of colors.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, nplanes
!end_enumerate

!end_node


!begin_node nkc_cmp

 !begin_blist [Definition:]
 !item [Summary:]           Compare NKCC key codes

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_cmp( int16 refkey, int16 kcode );

 !item [Pascal:]            Function nkc_cmp(
                                   refkey, kcode: Integer
                                ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_cmp compares two NKCC key codes with each other.
It is therefore preferable to the pure comparison because redundant
bits may be set in the code. Certain rules are used to increase
the flexibility of the comparison. The routine receives a reference
code 'refkey' and the code to be checked 'kcode'. The following bits
are particularly treated in the reference code:

!begin_xlist [NKF_IGNUM]
 !item [NKF_IGNUM]  When this bit is set, the ALT_NUM flag is irrelevant
            in the code

 !item [NKF_CAPS]   When set it means that upper/lower case is irrelevant
            for ASCII codes

 !item [NKF_SHIFT]  When set the triggering SHIFT key is irrelevant.
!end_xlist

TRUE is returned if the code matches, otherwise FALSE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_gem2n

 !begin_blist [Definition:]
 !item [Summary:]           Convert GEM key codes to NKCC key codes

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_gem2n( int16 gemkey );

 !item [Pascal:]            Function nkc_gem2n( gemkey: Integer ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_gem2n converts GEM key codes into NKCC key codes.

(!B)Note:(!b) Due to the limitations of the GEM key code, this routine
is not as powerful as nkc_tos2n and should therefore not be used
if possible!

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_gemks2n

 !begin_blist [Definition:]
 !item [Summary:]           Convert GEM key codes to NKCC key codes

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_gemks2n( int16 kstate, int16 gemkey );

 !item [Pascal:]            Function nkc_gemks2n( kstate, gemkey: Integer ) :
                    Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_gemks2n converts GEM key codes with the associated
key press status into NKCC key codes.

(!B)Note:(!b) This routine takes the special key status into account and
is therefore, in contrast to nkc_gem2n, equivalent to the routine
nkc_tos2n.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_kstate

 !begin_blist [Definition:]
 !item [Summary:]           Determine the status of the special keys

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_kstate( void );

 !item [Pascal:]            Function nkc_kstate : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_kstate determines the current status of the special
keys CONTROL, SHIFT, ALTERNATE, CAPSLOCK very quickly.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp
!end_enumerate

!end_node


!begin_node nkc_n2gem

 !begin_blist [Definition:]
 !item [Summary:]           Convert NKCC key codes to GEM key codes

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_n2gem( int16 nkcode );

 !item [Pascal:]            Function nkc_n2gem( nkcode: Integer ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_n2gem converts NKCC key codes into GEM key codes
if the latter is absolutely necessary.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gemks, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_n2gemks

 !begin_blist [Definition:]
 !item [Summary:]           Convert NKCC key codes to GEM key codes and
                    keyboard status

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 void nkc_n2gemks( int16 norm, int16 *kstate,
                            int16 *gemkey )

 !item [Pascal:]            Procedure nkc_n2gemks( nkcode: int16;
                                 Var kstate, gemkey: int16 );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_n2gemks converts NKCC key codes into GEM key codes
and the keyboard status, if this data should absolutely be needed.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2kstate, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_n2kstate

 !begin_blist [Definition:]
 !item [Summary:]           Convert NKCC key codes to GEM key codes and
                    keyboard status

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_n2kstate( int16 nkcode );

 !item [Pascal:]            Function nkc_n2kstate( nkcode: int16 ) : int16;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The nkc_n2kstate function determines the keyboard status based on
the NKCC key code, should this ever be absolutely necessary.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gem, nkc_n2gemks, nkc_n2tos, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_n2tos

 !begin_blist [Definition:]
 !item [Summary:]           Convert NKCC key codes to TOS key codes

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 long nkc_n2tos( int16 nkcode );

 !item [Pascal:]            Function nkc_n2tos( nkcode: Integer ) : LongInt;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The function nkc_n2tos converts NKCC key codes into TOS key codes
if the latter should absolutely be needed.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gemks, nkc_n2gem, nkc_n2kstate, nkc_tos2n

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nkc_tos2n

 !begin_blist [Definition:]
 !item [Summary:]           Convert TOS key codes to NKCC key codes

 !item [Category:]          NKCC functions, NKCC key codes

 !item [C:]                 int16 nkc_tos2n( long toskey );

 !item [Pascal:]            Function nkc_tos2n( toskey: LongInt ) : Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The nkc_tos2n function converts TOS key codes into NKCC key codes.
Since this conversion already takes place in the event loop in
(!I)ACSpro(!i), this function should be used very rarely.

The function can be used in your own programs if you want to import
standard TOS key codes into (!I)ACSpro(!i).

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item NKCC functions

  !item NKCC key codes

  !item nkc_gem2n, nkc_gemks2n, nkc_n2gemks, nkc_n2gem, nkc_n2kstate, nkc_n2tos

  !item nkc_cmp, nkc_kstate
!end_enumerate

!end_node


!begin_node nplanes

 !begin_blist [Definition:]
 !item [Summary:]           Number of color planes

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 nplanes;

 !item [Pascal:]            nplanes: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable nplanes contains the number of color planes.

(!B)Note:(!b) With colors more than 256 color planes are not used.
But with that nplanes still has the value 8.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk, ncolors
!end_enumerate

!end_node


!begin_node OLGA Infos

!label OLGA_InfoPtr
The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   Awindow *window;
   int16 id;
   char *datei;
   int16 info_id;
   char *info_datei;
   int16 olga_flags;
} OLGA Infos;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
OLGA Infos  = RECORD
                 window: AwindowPtr;
                 id: Integer;
                 datei: Pointer;
                 info_id: Integer;
                 info_datei: Pointer;
                 olga_flags: Integer;
              END;

OLGA InfosPtr = ^OLGA Infos;
!end_sourcecode

The components of the structure mean:

!end_node


!begin_node phys_handle

 !begin_blist [Definition:]
 !item [Summary:]           The physical AES VDI workstation

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 phys_handle;

 !item [Pascal:]            phys_handle: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The phys_handle variable contains the number of the physical VDI
workstation that the AES uses.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node PLOTTERDATA

!label PLOTTERDATAPtr
When the plotter window is created, a pointer to the following
structure can be passed in the free parameter, which contains
the initial dimensions of the window:

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   int16 x;
   int16 y;
   int16 w;
   int16 h;
} PLOTTERDATA;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
PLOTTERDATA = RECORD
      x: Integer;
      y: Integer;
      w: Integer;
      h: Integer;
END;

PLOTTERDATAPtr = ^PLOTTERDATA;
!end_sourcecode

The components of the structure mean:

!end_node


!begin_node PROTOCOLDATA

!label PROTOCOLDATAPtr
When the log window is created, a pointer to the following
structure can be passed in the free parameter, with which the
window and the output can be be preconfigured:

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   int16 fontid;
   int16 height;
   int16 col;
   int16 row;
   int16 tabsize;
   int16 wrap;
   int16 x;
   int16 y;
} PROTOCOLDATA;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
PROTOCOLDATA = RECORD
      fontid:  Integer;
      height:  Integer;
      col:     Integer;
      row:     Integer;
      tabsize: Integer;
      wrap:    Integer;
      x:       Integer;
      y:       Integer;
END;

PROTOCOLDATAPtr = ^PROTOCOLDATA;
!end_sourcecode

The components of the structure mean:

!end_node


!begin_node PUR_DESK

 !begin_blist [Definition:]
 !item [Summary:]           The root window PUR_DESK

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 Awindow PUR_DESK;

 !item [Pascal:]            In Pure-Pascal, the structure PUR_DESK 
                    (!link [is not directly accessible] [ImpCVars]). It must be
                    queried using the get_pur_desk function.

!label get_pur_desk
                    Function get_pur_desk : Awindow;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable PUR_DESK represents the window structure of the root
window that is normally used.

The menu bar of the PUR_DESK can be replaced in the routine ACSInit0:

!begin_xlist [Pascal:]
 !item [C:]       PUR_DESK.menu = &MyMenu;

 !item [Pascal:]  get_pur_desk^.menu := @MyMenu;
!end_xlist

The functions in the original menu tree can be used. These are:

!begin_xlist [File/Information]
 !item [File/New]          Apd_new

 !item [File/Open]         Apd_open

 !item [File/Information]  Apd_info

 !item [File/Module]       Apd_module

 !item [File/Quit]         Apd_quit

 !item [Window/Close]      Apd_close

 !item [Window/Delete]     Apd_delete

 !item [Window/Cycle]      Apd_list
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The "pure" desktop

  !item DESKTOP
!end_enumerate

!end_node


!begin_node SC_CHANGED

Newer applications send this message so that data exchange via the
clipboard is automatically recognized by all applications.

If successful, the routines Ascrp_put and Ascrp_clear send this AES
message to other applications so that they are informed of the change.

On the other hand, when SC_CHANGED is received, all ACS windows are
sent the predefined message AS_SCRAP_UPDATE.

(!I)Cross references:(!i)

!begin_enumerate !compressed
   !item Predefined window messages

   !item AS_SCRAP_EXPORT, AS_SCRAP_IMPORT, AS_SCRAP_UPDATE
!end_enumerate

!end_node


!begin_node screenMFDB

 !begin_blist [Definition:]
 !item [Summary:]           MFDB for the screen

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 MFDB screenMFDB;

 !item [Pascal:]            screenMFDB: MFDB;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

To perform the copy operation on the screen you need a special MFDB
(Memory Form Definition Block) using the variable screenMFDB.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node scrp_path

 !begin_blist [Definition:]
 !item [Summary:]           Path of the clipboard

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char *scrp_path

 !item [Pascal:]            scrp_path: Pointer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable scrp_path contains the path that is used for the
clipboard.  The (!link [Clipboard routines] [Clipboard functions]) use this path directly.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, AES oriented variables

  !item Ablk, AblkPtr, ACSblk, Ascrp_clear, Ascrp_get, Ascrp_put
!end_enumerate

!end_node


!begin_node separator

 !begin_blist [Definition:]
 !item [Summary:]           Word separator character

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 char separator[256];

 !item [Pascal:]            separator: packed array [1..256] of char;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The variable separator contains all characters that are interpreted
as word separators.

To separate words from each other special characters are recognized.
If the operating system already has an environment variable named FS
or IFS, its content is used to fill this field, otherwise it is filled
with the following:

!begin_preformatted
     =+-*/()!&|[]{}<>,.;:¯$%?`'^#~@\"
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  as well as tab and spaces
!end_preformatted

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, Other variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node SH_WDRAW

This message is sent to the installed system shell if the contents
of a drive have been changed during a clipboard routine. This can
then refresh the display of the drive.

!end_node


!begin_node SLLIVE

!label SLLIVEPtr
The (!link [Slider] [Userdef-Slider]) object can be assigned a so-called live routine via the (!link [Service] [Auo_slider]) routine, which is always used by (!I)ACSpro(!i) and called automatically when the position of the slider changes.  The programmer can then react immediately to the new position from the user action and carry out area changes, values or other calculations.

The definition for Pure-C reads:
!begin_sourcecode
typedef struct
{
   char *(*call)(void* obj, long pos);
   void *obj;
} SLLIVE;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
SLLIVE  = RECORD
      call: Function( obj: Pointer; pos: LongInt ) : Pointer;
      obj: Pointer;
END;

SLLIVEPtr = ^SLLIVE;
!end_sourcecode

The components of the structure mean:

!begin_xlist [call]
 !item [call]  Pointer to the live routine

 !item [obj]   Parameter that is passed to the live routine.
       (It is advisable to enter a reference to the object
       here so that the live routine can access it.)
!end_xlist

!end_node


!begin_node start_acs

 !begin_blist [Definition:]
 !item [Summary:]           Start (!I)ACSpro(!i) under Pure-Pascal

 !item [Category:]          (!link [Variables] [The Variables]), Function pointers

 !item [C:]                 This function is not necessary for C and
                            is therefore not available.

 !item [Pascal:]            Procedure start_acs( ini: Aretint;
                                 descr: AdescrPtr );

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The routine is required for Pure-Pascal and starts (!I)ACSpro(!i). The
initialization routine 'ini', which takes over the functions of the
ACSinit function, must be transferred. In addition, the structure
ACSdescr is passed, which determines the global behavior.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables

  !item Function pointers

  !item Ablk, ACSblk, ACSinit
!end_enumerate

!end_node


!begin_node ULinList

!label ULinListPtr
The structure ULinList provides a powerful, generically programmed
unsorted, doubly linked linear list as object.

The definition for Pure-C reads:
!begin_sourcecode
typedef struct _ULinList
{
   void *ListData;
   void (*freeElem)( void *elem );
   void (*clear)( ULinList *liste );
   int16 (*append)( ULinList *liste, void *new_data );
   int16 (*insert)( ULinList *liste, void *new_data,
         int16 before_obj );
   void *(*delete)( ULinList *liste, int16 data_nr );
   long (*deleteFor)( ULinList *liste, void *para,
         int16 (*to_delete)(void *para, void *elem) );
   void *(*search)( ULinList *liste, long nr );
   void *(*searchFor)( ULinList *liste, void *para,
         int16 (*found)(void *para,void *elem) );
   void *(*first)( ULinList *liste );
   void *(*last)( ULinList *liste );
   void *(*akt)( ULinList *liste );
   long (*aktNr)( ULinList *liste );
   void *(*skip)( ULinList *liste, int16 vorwaerts,
         long amount );
   long (*count)( ULinList *liste);
   long (*countFor)( ULinList *liste, void *para,
         int16 (*count)(void *para, void *elem) );
   void (*doFor)( ULinList *liste, void *para,
         int16 (*to_work)(void *para, void *elem),
         void (*work)(void *para, void *elem) );
} ULinList;
!end_sourcecode

The definition for Pure-Pascal reads:
!begin_sourcecode
ULinList = RECORD
      ListData    : Pointer;
      freeElem    : Procedure( elem: Pointer );
      clear       : Procedure( liste: ULinListPtr );
      append      : Function( liste: ULinListPtr,
                        new_data: Pointer ) : Integer;
      insert      : Function( liste: ULinListPtr,
                        new_data: Pointer,
                        before_obj: LongInteger ) : Integer;
      delete      : Function( liste: ULinListPtr,
                        data_nr: Integer ) : Pointer;
      deleteFor   : Function( liste: ULinListPtr,
                        para : Pointer,
                        int16 (*to_delete)(void *para,
                           void *elem) ) : Integer;
      search      : Function( liste: ULinListPtr,
                        nr: LongInterger ) : Pointer;
      searchFor   : Function( ULinList *liste, void *para,
                        int16 (*found)(void *para,
                           void *elem) ) : Pointer;
      first       : Function( liste: ULinListPtr ) : Pointer;
      last        : Function( liste: ULinListPtr ) : Pointer;
      akt         : Function( liste: ULinListPtr ) : Pointer;
      aktNr       : Function( liste: ULinListPtr )
                        : LongInteger;
      skip        : Function( liste: ULinListPtr,
                        vorwaerts: Integer,
                        amount: LongInteger ) : Pointer;
      count       : Function( liste: ULinListPtr )
                        : LongInteger;
      countFor    : Function( liste: ULinListPtr, para: Pointer,
                        Function count(para: Pointer,
                           elem: Pointer) : Integer )
                           : LongInteger;
      doFor       : Procedure( liste: ULinList, para: Pointer,
                        Function to_work(para: Pointer,
                           elem: Pointer) : Integer,
                        Procedure work(para: Pointer,
                           elem: Pointer) );
END;

ULinListPtr = ^ULinList;
!end_sourcecode

The components of the structure mean:

!begin_xlist [deleteFor]
!label ULinList.ListData
 !item [ListData]   The pointer to the linear list (should only be used
            internally by ACS!).

!label ULinList.freeElem
 !item [freeElem]   Pointer to release function that is called when the
            list or individual elements are deleted.

            It can be used to manage object trees that were created
            with Aob_create if Aob_delete is entered as the release
            function after creating the list using Alu_create (be
            careful with warnings, the interface provides type-free
            data pointers, but Aob_delete receives a typed pointer!
            In Pure-C, these warnings can be bypassed with the cast
            operator).)

!label ULinList.clear
 !item [clear]      Clear the linear list, release all data.

!label ULinList.append
 !item [append]     Append new data to the list.

!label ULinList.insert
 !item [insert]     Add new data to the list.

!label ULinList.delete
 !item [delete]     Remove data from the list and return the pointer to it.

!label ULinList.deleteFor
 !item [deleteFor]  Delete all data from the list (freeElem is called!) that
            meet a certain condition.  The parameter para is passed
            on to the function to_delete in the parameter with the
            same name (e.g. transfer of the comparison criteria).

!label ULinList.search
 !item [search]     Get the data number nr.

!label ULinList.searchFor
 !item [searchFor]  Find data that meets a condition. The parameter para is
            passed on to the function in the parameter with the
            same name (e.g. transfer of the comparison criteria)

!label ULinList.first
 !item [first]      The first element of the list.

!label ULinList.last
 !item [last]       The last element in the list.

!label ULinList.akt
 !item [akt]        The current element of the list.

!label ULinList.aktNr
 !item [aktNr]      The number of the current element in the list.

!label ULinList.skip
 !item [skip]       Move the current element forward/backward.

!label ULinList.count
 !item [count]      The number of data managed.

!label ULinList.countFor
 !item [countFor]   Find the number of data that meet a condition.  The
            parameter para is passed on to the function in the
            parameter with the same name (e.g. transfer of the
            comparison criteria)

!label ULinList.doFor
 !item [doFor]      Perform an action on all data that meet a condition.
            The parameter para is passed on to the function to_work
            and work in the parameter with the same name (e.g.
            transfer of the comparison criteria).
!end_xlist

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Alu_create
!end_enumerate

!end_node


!begin_node uputs

 !begin_blist [Definition:]
 !item [Summary:]           String output in a USERDEF

 !item [Category:]          Other functions

 !item [C:]                 int16 uputs( char *text, OBJECT *entry );

 !item [Pascal:]            Unfortunately, this function is not
                    available in Pascal.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The C-string 'text' is output to the Userdef 'entry' (A_editor).
OK or FAIL is returned.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item uvprintf

  !item uprintf
!end_enumerate

!end_node


!begin_node uprintf

 !begin_blist [Definition:]
 !item [Summary:]           Output analog to printf in a USERDEF

 !item [Category:]          Other functions

 !item [C:]                 int16 uprintf( OBJECT *entry,
                             const char *format, ... );

 !item [Pascal:]            Unfortunately, this function is not
                    available in Pascal.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The output is made to the Userdef 'entry' (A_editor). 1024 bytes
are available for the result string after formatting.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item uvprintf

  !item uputs
!end_enumerate

!end_node


!begin_node uvprintf

 !begin_blist [Definition:]
 !item [Summary:]           Output analogous to vprintf in a USERDEF

 !item [Category:]          Other functions

 !item [C:]                 int16 uvprintf( OBJECT *entry,
                             const char *format,
                             va_list arg_list );

 !item [Pascal:]            Unfortunately, this function is not
                    available in Pascal.

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The output analogous to vprintf takes place on the Userdef 'entry'
(A_editor). 1024 bytes are available for the result string after
formatting

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item uputs

  !item uprintf
!end_enumerate

!end_node


!begin_node vdi_handle

 !begin_blist [Definition:]
 !item [Summary:]           Virtual VDI workstation of (!I)ACSpro(!i)

 !item [Category:]          (!link [Variables] [The Variables])

 !item [C:]                 int16 vdi_handle;

 !item [Pascal:]            vdi_handle: Integer;

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The vdi_handle variable contains the number of the virtual workstation
that (!I)ACSpro(!i) uses for copy operations and user-defined objects.  The
application can use it.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item The Variables, VDI oriented variables

  !item Ablk, AblkPtr, ACSblk
!end_enumerate

!end_node


!begin_node xywh2array

 !begin_blist [Definition:]
 !item [Summary:]           Convert Axywh structure to pair of points

 !item [Category:]          Other functions

 !item [C:]                 void xywh2array( int16 *to, const Axywh *from );

 !item [Pascal:]            Procedure xywh2array( to: Pointer; from: AxywhPtr);

 !item [Definition:]        in ACS.H or ACS.PAS
!end_blist

The xywh2array function converts an Axywh structure into an int16
field with two diagonal corner points.

(!I)Cross references:(!i)

!begin_enumerate !compressed
  !item Other functions

  !item array2xywh
!end_enumerate

!end_node

!end_node
